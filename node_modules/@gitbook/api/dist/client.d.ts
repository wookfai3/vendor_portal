export interface ApiInformation {
    /** Current release of GitBook */
    version: string;
    /** Date of the latest release in ISO format */
    build: string;
}
export interface User {
    /** Type of Object, always equals to "user" */
    object: 'user';
    /** Unique identifier for the user */
    id: string;
    /** Full name for the user */
    displayName: string;
    /** Email address of the user */
    email?: string;
    /** URL of the user's profile picture */
    photoURL?: string;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the user in the API
         * @format uri
         */
        location: string;
    };
}
export interface List {
    next?: {
        /** Unique identifier to query the next results page */
        page: string;
    };
    /** Total count of objects in the list */
    count?: number;
}
/** @format date-time */
export type Timestamp = string;
/** The API token details, excluding the token itself. */
export interface UserAPIToken {
    /** The API token ID. */
    id: string;
    /** The API token name. */
    label: string;
    /** The API token creation date. */
    createdAt: Timestamp;
}
/** The API token details, including the token itself. */
export type UserAPITokenExtended = UserAPIToken & {
    /** The actual token value. */
    token: string;
};
/**
 * @format uri
 * @maxLength 2048
 */
export type URL = string;
/**
 * Title of the space
 * @maxLength 50
 */
export type SpaceTitle = string;
/**
 * Unicode codepoint or character of the emoji
 * @format emoji
 * @maxLength 50
 * @example "ðŸŽ‰"
 */
export type Emoji = string;
/**
 * * `public`: Anyone can access the content, and the content is indexed by search engines.
 * * `unlisted`: Anyone can access the content, and the content is not indexed by search engines
 * * `share-link`: Anyone with a secret token in the url can access the content.
 * * `visitor-auth`: Anyone authenticated through a JWT token can access the content.
 * * `in-collection`: Anyone who can access the parent collection can access the content.
 *   Only available for spaces in a collection.
 * * `private`: Authorized members can access the content.
 */
export declare enum ContentVisibility {
    Public = "public",
    Unlisted = "unlisted",
    ShareLink = "share-link",
    VisitorAuth = "visitor-auth",
    InCollection = "in-collection",
    Private = "private"
}
/**
 * Determines how a Space can be edited.
 * * `live`: Users can directly edit the space
 * * `locked`: All edits are locked for this space.
 */
export declare enum SpaceEditMode {
    Live = "live",
    Locked = "locked"
}
/** The provider of the Git Sync installation. */
export declare enum GitSyncProvider {
    Github = "github",
    Gitlab = "gitlab",
    GithubLegacy = "github-legacy"
}
export interface GitSyncState {
    /** Repository name. */
    repoName?: string;
    /** The provider of the Git Sync installation. */
    installationProvider?: GitSyncProvider;
    /** The integration name providing the Git Sync. */
    integration?: string;
    /** The URL to the repository tree, used when rendering public content. */
    url?: string;
    /** When the Git provider details were last updated */
    updatedAt?: Timestamp;
}
/** Custom backend for authenticated access */
export interface VisitorAuthCustomBackend {
    /** Custom backend for authenticated access */
    backend: 'custom';
}
/** Integration backend for authenticated access */
export interface VisitorAuthIntegrationBackend {
    /** Integration as backend for authenticated access */
    backend: 'integration';
}
export type VisitorAuth = VisitorAuthCustomBackend | (VisitorAuthIntegrationBackend & {
    /** Name of integration being used as the backend for authenticated access */
    integration: string;
});
/**
 * "The role of a member in an organization.
 * "admin": Can administrate the content: create, delete spaces, ...
 * "create": Can create content.
 * "review": Can review content.
 * "edit": Can edit the content (live or change requests).
 * "comment": Can access the content and its discussions.
 * "read": Can access the content, but cannot update it in any way.
 */
export declare enum MemberRole {
    Admin = "admin",
    Create = "create",
    Edit = "edit",
    Review = "review",
    Comment = "comment",
    Read = "read"
}
/** The role of a member in an organization, null for guests */
export type MemberRoleOrGuest = MemberRole | null;
/** Default level for a piece of content */
export type DefaultLevel = MemberRoleOrGuest | 'inherit';
export interface Space {
    /** Type of Object, always equals to "space" */
    object: 'space';
    /** Unique identifier for the space */
    id: string;
    /** Title of the space */
    title: SpaceTitle;
    /** An emoji for this space. It'll match the emoji shown in the GitBook app. */
    emoji: Emoji;
    /**
     * * `public`: Anyone can access the content, and the content is indexed by search engines.
     * * `unlisted`: Anyone can access the content, and the content is not indexed by search engines
     * * `share-link`: Anyone with a secret token in the url can access the content.
     * * `visitor-auth`: Anyone authenticated through a JWT token can access the content.
     * * `in-collection`: Anyone who can access the parent collection can access the content.
     *   Only available for spaces in a collection.
     * * `private`: Authorized members can access the content.
     */
    visibility: ContentVisibility;
    createdAt: Timestamp;
    updatedAt: Timestamp;
    deletedAt?: Timestamp;
    /**
     * Determines how a Space can be edited.
     * * `live`: Users can directly edit the space
     * * `locked`: All edits are locked for this space.
     */
    editMode?: SpaceEditMode;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the space in the API
         * @format uri
         */
        location: string;
        /**
         * URL of the space in the application
         * @format uri
         */
        app: string;
        /**
         * URL of the published version of the space. Only defined when visibility is not "private."
         * @format uri
         */
        published?: string;
        /**
         * URL of the public version of the space. Only defined when visibility is "public".
         * @format uri
         */
        public?: string;
        /** URL of the icon of this space, if defined. */
        icon?: URL;
    };
    /** ID of the organization owning this space */
    organization: string;
    /** ID of the parent collection. */
    parent?: string;
    gitSync?: GitSyncState;
    visitorAuth?: VisitorAuth;
    /** ID of the active revision in the space. */
    revision: string;
    /** Default level for a piece of content */
    defaultLevel: DefaultLevel;
    /** Count of opened comments on the space. */
    comments: number;
    /** Total count of change requests on the space. */
    changeRequests: number;
    /** Count of open change requests on the space. */
    changeRequestsOpen: number;
    /** Count of draft change requests on the space. */
    changeRequestsDraft: number;
    /** The set of permissions for the space */
    permissions: {
        /** Can the user view the space content. */
        view: boolean;
        /** Can the user access the space in the application. */
        access: boolean;
        /** Can the user edit the title, install integrations, and manage the space. */
        admin: boolean;
        /** Can the user view the invite links of the space. */
        viewInviteLinks: boolean;
        /** Can the user edit the content of the space by creating a change request. */
        edit: boolean;
        /** Can the user trigger a git sync. */
        triggerGitSync: boolean;
        /** Can the user comment on the content. */
        comment: boolean;
        /** Can the user merge change requests. */
        merge: boolean;
        /** Can the user review change requests. */
        review: boolean;
    };
}
export interface SpacePointer {
    type: 'space';
    /** Unique identifier for the space */
    space: string;
}
export interface CollectionPointer {
    type: 'collection';
    /** Unique identifier for the collection */
    collection: string;
}
/** Position at which to insert an item */
export interface ContentPosition {
    before?: SpacePointer | CollectionPointer;
    after?: SpacePointer | CollectionPointer;
}
/** Format the custom block as a codeblock */
export type IntegrationBlockMarkdown = {
    /** Code block syntax to use to identify the block. */
    codeblock: string;
    /** Key of the property to use as body of the codeblock. */
    body: string;
};
export interface IntegrationBlock {
    /** Unique ID in the integration for the block. It also represents the UI component used. */
    id: string;
    /**
     * Short descriptive title for the block.
     * @minLength 2
     * @maxLength 40
     */
    title: string;
    /**
     * Long descriptive text for the block.
     * @minLength 0
     * @maxLength 150
     */
    description?: string;
    /** URL of the icon to represent this block. */
    icon?: string;
    /** URLs patterns to convert as this block. */
    urlUnfurl?: string[];
    /** Format the custom block as a codeblock */
    markdown?: IntegrationBlockMarkdown;
}
export type Embed = {
    title: string;
    site: string;
    icon?: string;
} & ({
    type: 'link';
} | {
    type: 'rich';
    html: string;
} | {
    type: 'integration';
    /** The identifier of the integration performing the rendering */
    integration: string;
    block: IntegrationBlock;
});
/** Search result representing a section in a page. */
export interface SearchSectionResult {
    id: string;
    title: string;
    path: string;
    body: string;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the section in the application
         * @format uri
         */
        app: string;
    };
}
/** Search result representing a page in a space. */
export interface SearchPageResult {
    id: string;
    title: string;
    path: string;
    sections?: SearchSectionResult[];
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the page in the application
         * @format uri
         */
        app: string;
    };
}
/** Update metadata about the Git provider on the space */
export interface UpdateSpaceGitInfo {
    /** The git provider */
    provider?: 'github' | 'gitlab';
    /** The repository's tree URL */
    url?: string;
}
export interface ImportGitRepository {
    /** URL of the Git repository to import. It can contain basic auth credentials. */
    url: string;
    /** Git ref to import in the format "refs/heads/main" */
    ref: string;
    /** Unique identifier to use to cache the Git repository across multiple operations. */
    repoCacheID?: string;
    /** URL to use as a prefix for external file references. */
    repoTreeURL?: string;
    /** URL to use as a prefix for the commit URL. */
    repoCommitURL?: string;
    /** Path to a root directory for the project in the repository. */
    repoProjectDirectory?: string;
    /** The timestamp of the event that triggered this import. It ensures that Git sync import and export operations are executed in the same order on GitBook and on the remote repository. */
    timestamp?: Timestamp;
    force?: boolean;
    /** If true, the import will generate a revision without updating the space primary content. */
    standalone?: boolean;
    /** Optional metadata to store on the space about the Git provider */
    gitInfo?: UpdateSpaceGitInfo;
}
export interface ExportToGitRepository {
    /** URL of the Git repository to export to. It can contain basic auth credentials. */
    url: string;
    /** Git ref to push the commit to in the format "refs/heads/main" */
    ref: string;
    /** Message for the commit generated by the export */
    commitMessage: string;
    /** Unique identifier to use to cache the Git repository across multiple operations. */
    repoCacheID?: string;
    /** URL to use as a prefix for external file references. */
    repoTreeURL?: string;
    /** URL to use as a prefix for the commit URL. */
    repoCommitURL?: string;
    /** Path to a root directory for the project in the repository. */
    repoProjectDirectory?: string;
    /** The timestamp of the event that triggered this export. It ensures that Git sync import and export operations are executed in the same order on GitBook and on the remote repository. */
    timestamp?: Timestamp;
    force?: boolean;
    /** Optional metadata to store on the space about the Git provider */
    gitInfo?: UpdateSpaceGitInfo;
}
export type InviteUsersAndTeams = ({
    /** @minItems 1 */
    teams: string[];
} | {
    /** @minItems 1 */
    users: string[];
}) & {
    /** Role to set. */
    role: MemberRoleOrGuest;
};
/** Permission of a user in a content. */
export interface UserContentPermission {
    /**
     * "The role of a member in an organization.
     * "admin": Can administrate the content: create, delete spaces, ...
     * "create": Can create content.
     * "review": Can review content.
     * "edit": Can edit the content (live or change requests).
     * "comment": Can access the content and its discussions.
     * "read": Can access the content, but cannot update it in any way.
     */
    permission: MemberRole;
    user: User;
}
/**
 * Title of the team
 * @minLength 1
 * @maxLength 64
 */
export type OrganizationTeamTitle = string;
export interface OrganizationTeam {
    /** Type of Object, always equals to "team" */
    object: 'team';
    /** Unique identifier for the team. */
    id: string;
    /** Title of the team */
    title: OrganizationTeamTitle;
    /** Count of members in this team. */
    members: number;
    /** Count of spaces this team has access to. */
    spaces: number;
    /** Date at which the team was created. */
    createdAt: Timestamp;
    /** The set of permissions for the team */
    permissions: {
        /** Can the user manage the team */
        admin: boolean;
        /** Can the user view the team and list its members */
        view: boolean;
    };
}
/**
 * Name of the icon
 * @format icon
 * @maxLength 50
 * @example "gear"
 */
export type Icon = string;
export interface RevisionPageBase {
    /** Unique identifier for the page in the revision */
    id: string;
    /**
     * Title of the page
     * @minLength 1
     */
    title: string;
    /** Emoji of the page, if one has been set. */
    emoji?: Emoji;
    /** Icon of the page, if one has been set. */
    icon?: Icon;
    /** When the page was first created. Only present if page has been edited at least once. */
    createdAt?: Timestamp;
    /** When the page was last edited. Only present if page has been edited at least once. */
    updatedAt?: Timestamp;
}
export interface MarkdownDocument {
    /** Content of the document formatted as markdown */
    markdown: string;
}
export interface DocumentMarkBold {
    object: 'mark';
    type: 'bold';
}
export interface DocumentMarkItalic {
    object: 'mark';
    type: 'italic';
}
export interface DocumentMarkCode {
    object: 'mark';
    type: 'code';
}
export interface DocumentMarkKeyboard {
    object: 'mark';
    type: 'keyboard';
}
export interface DocumentMarkStrikethrough {
    object: 'mark';
    type: 'strikethrough';
}
export interface DocumentMarkColor {
    object: 'mark';
    type: 'color';
    data: {
        text: 'default' | 'green' | 'blue' | 'red' | 'orange' | 'yellow' | 'purple';
        background: 'default' | 'green' | 'blue' | 'red' | 'orange' | 'yellow' | 'purple';
    };
}
export interface DocumentMarkSuperscript {
    object: 'mark';
    type: 'superscript';
}
export interface DocumentMarkSubscript {
    object: 'mark';
    type: 'subscript';
}
export type DocumentTextMark = DocumentMarkBold | DocumentMarkItalic | DocumentMarkCode | DocumentMarkKeyboard | DocumentMarkStrikethrough | DocumentMarkColor | DocumentMarkSuperscript | DocumentMarkSubscript;
export interface DocumentTextLeaf {
    object: 'leaf';
    text: string;
    marks: DocumentTextMark[];
}
export interface DocumentText {
    object: 'text';
    key?: string;
    leaves: DocumentTextLeaf[];
}
export interface ContentRefURL {
    kind: 'url';
    url: string;
}
export interface ContentRefFile {
    kind: 'file';
    file: string;
}
export interface DocumentInlineImage {
    object: 'inline';
    type: 'inline-image';
    key?: string;
    data: {
        ref: ContentRefURL | ContentRefFile;
        refDark?: ContentRefURL | ContentRefFile;
        caption?: string;
        size?: 'original' | 'line';
    };
    isVoid: true;
}
export interface ContentRefPage {
    kind: 'page';
    page: string;
    /** ID of the space the page is in. The page is considered as in the current space if none is provided. */
    space?: string;
}
export interface ContentRefAnchor {
    kind: 'anchor';
    anchor: string;
    /** ID of the space the page is in. The page is considered as in the current space if none is provided. */
    space?: string;
    /** ID of the page the anchor is in. The anchor is considered as in the current page if none is provided. */
    page?: string;
}
export interface ContentRefUser {
    kind: 'user';
    user: string;
}
export interface ContentRefCollection {
    kind: 'collection';
    collection: string;
}
export interface ContentRefSpace {
    kind: 'space';
    space: string;
}
export interface ContentRefReusableContent {
    kind: 'reusable-content';
    reusableContent: string;
    /** The space in which the reusable content is defined. If undefined, the reusable content is assumed to be in the same space as the content reference. */
    space?: string;
}
export interface ContentRefOpenAPI {
    kind: 'openapi';
    /** Slug of the OpenAPI specification */
    spec: string;
}
/** A relative reference to content in GitBook. */
export type ContentRef = ContentRefFile | ContentRefURL | ContentRefPage | ContentRefAnchor | ContentRefUser | ContentRefCollection | ContentRefSpace | ContentRefReusableContent | ContentRefOpenAPI;
export interface DocumentInlineLink {
    object: 'inline';
    type: 'link';
    key?: string;
    nodes: (DocumentText | DocumentInlineImage)[];
    data: {
        /** A relative reference to content in GitBook. */
        ref: ContentRef;
    };
    isVoid?: false;
}
export interface DocumentInlineEmoji {
    object: 'inline';
    type: 'emoji';
    key?: string;
    data: {
        code: string;
    };
    isVoid: true;
}
export interface DocumentInlineIcon {
    object: 'inline';
    type: 'icon';
    key?: string;
    data: {
        icon: string;
    };
    isVoid: true;
}
export interface DocumentInlineExpression {
    object: 'inline';
    type: 'expression';
    key?: string;
    data: {
        expression: string;
    };
    isVoid: true;
}
export interface DocumentInlineMath {
    object: 'inline';
    type: 'inline-math';
    key?: string;
    data: {
        formula: string;
    };
    isVoid: true;
}
export interface DocumentBlockParagraph {
    object: 'block';
    type: 'paragraph';
    key?: string;
    nodes: (DocumentInline | DocumentText)[];
    isVoid?: false;
    data?: {
        align?: TextAlignment;
    };
}
export type DocumentInline = DocumentInlineLink | DocumentInlineEmoji | DocumentInlineIcon | DocumentInlineExpression | DocumentInlineMath | DocumentInlineImage | DocumentInlineAnnotation | DocumentInlineMention | DocumentInlineButton;
export declare enum TextAlignment {
    Start = "start",
    Center = "center",
    End = "end"
}
export interface DocumentBlockHeading {
    object: 'block';
    type: 'heading-1' | 'heading-2' | 'heading-3';
    key?: string;
    nodes: (DocumentInline | DocumentText)[];
    data: {
        /** @pattern ^[-a-z0-9.+_]+$ */
        id?: string;
        align?: TextAlignment;
    };
    meta?: {
        /** Unique ID to be used in an URL for the block. */
        id: string;
    };
    isVoid?: false;
}
export type DocumentBlocksEssentials = DocumentBlockParagraph | DocumentBlockHeading | DocumentBlockListOrdered | DocumentBlockListUnordered | DocumentBlockListTasks | DocumentBlockDivider;
export interface DocumentInlineAnnotation {
    object: 'inline';
    type: 'annotation';
    key?: string;
    fragments: (DocumentFragment & {
        type: 'annotation-body';
        /** @minItems 1 */
        nodes: (DocumentBlocksEssentials | DocumentBlockCode)[];
    })[];
    isVoid: false;
    nodes: DocumentText[];
    data?: object;
}
export interface DocumentBlockCodeLine {
    object: 'block';
    type: 'code-line';
    key?: string;
    nodes: (DocumentText | DocumentInlineAnnotation | DocumentInlineExpression)[];
    data: {
        highlighted?: boolean;
    };
    isVoid?: false;
}
export interface DocumentBlockCode {
    object: 'block';
    type: 'code';
    key?: string;
    data: {
        syntax?: string;
        title?: string;
        /** @default "scroll" */
        overflow?: 'scroll' | 'wrap';
        lineNumbers?: boolean;
        fullWidth?: boolean;
    };
    nodes: DocumentBlockCodeLine[];
    isVoid?: false;
}
export interface DocumentBlockHint {
    object: 'block';
    type: 'hint';
    key?: string;
    data: {
        style: 'info' | 'warning' | 'danger' | 'success';
    };
    nodes: DocumentBlocksEssentials[];
    isVoid?: false;
}
export interface DocumentBlockQuote {
    object: 'block';
    type: 'blockquote';
    key?: string;
    nodes: (DocumentBlocksEssentials | DocumentBlockQuote)[];
    isVoid?: false;
    data?: object;
}
export interface DocumentBlockMath {
    object: 'block';
    type: 'math';
    key?: string;
    data: {
        formula: string;
    };
    isVoid: true;
}
export interface DocumentTableViewGrid {
    type: 'grid';
    /** Ordered list of the definition IDs to display */
    columns: string[];
    /** Percent width of each column */
    columnWidths?: Record<string, number>;
    /** Should we display the header with column titles */
    hideHeader: boolean;
    /**
     * Tables in GitBook originally used a scaled width approach i.e. the width defined
     * in columnWidths would be scaled to ensure a 100% width table.
     *
     * We later changed this to treat the widths in columnWidths as exact values - they are
     * never scaled. A columnWidth of 50 is rendered as 50px.
     *
     * In order to maintain backwards compatibility, we track whether or not we
     * use the new system here.
     *
     * All new tables should have this value set to true, older tables will have it set
     * to undefined.
     */
    useNewSizing?: boolean;
}
export interface DocumentTableViewCards {
    type: 'cards';
    /** Size of the cards. It indicates how many columns will be used */
    cardSize: 'medium' | 'large';
    /** Ordered list of the definition IDs to display */
    columns: string[];
    /** Definition ID to use as a target link for the card */
    targetDefinition?: string;
    /** Definition ID to use as a cover image */
    coverDefinition?: string;
    /** Should we display the column title or not */
    hideColumnTitle?: boolean;
}
export interface DocumentTableRecord {
    orderIndex: string;
    values: Record<string, number | string | boolean | string[] | ContentRef>;
}
export interface DocumentTableDefinitionBase {
    id: string;
    /** Title for the column */
    title: string;
}
export type DocumentTableDefinitionText = DocumentTableDefinitionBase & {
    type: 'text';
    textAlignment: 'center' | 'right' | 'left';
    verticalAlignment?: 'top' | 'middle' | 'bottom';
};
export type DocumentTableDefinitionNumber = DocumentTableDefinitionBase & {
    type: 'number';
};
export type DocumentTableDefinitionCheckbox = DocumentTableDefinitionBase & {
    type: 'checkbox';
};
export type DocumentTableDefinitionFiles = DocumentTableDefinitionBase & {
    type: 'files';
};
export type DocumentTableDefinitionUsers = DocumentTableDefinitionBase & {
    type: 'users';
    multiple: boolean;
};
export type DocumentTableDefinitionRating = DocumentTableDefinitionBase & {
    type: 'rating';
    max: number;
};
export interface DocumentTableSelectOption {
    value: string;
    label: string;
    color: string;
}
export type DocumentTableDefinitionSelect = DocumentTableDefinitionBase & {
    type: 'select';
    multiple: boolean;
    options: DocumentTableSelectOption[];
};
export type DocumentTableDefinitionContentRef = DocumentTableDefinitionBase & {
    type: 'content-ref';
};
export type DocumentTableDefinition = DocumentTableDefinitionText | DocumentTableDefinitionNumber | DocumentTableDefinitionCheckbox | DocumentTableDefinitionFiles | DocumentTableDefinitionUsers | DocumentTableDefinitionRating | DocumentTableDefinitionSelect | DocumentTableDefinitionContentRef;
export interface DocumentFragment {
    object: 'fragment';
    key?: string;
    fragment?: string;
    type?: string;
    nodes: DocumentBlock[];
}
export interface DocumentBlockTable {
    object: 'block';
    type: 'table';
    key?: string;
    isVoid: true;
    data: {
        view: DocumentTableViewGrid | DocumentTableViewCards;
        records: Record<string, DocumentTableRecord>;
        definition: Record<string, DocumentTableDefinition>;
        /** Whether to render the block as a full width one */
        fullWidth?: boolean;
    };
    fragments: DocumentFragment[];
}
export interface DocumentBlockListItem {
    object: 'block';
    type: 'list-item';
    key?: string;
    nodes: (DocumentBlocksEssentials | DocumentBlockCode | DocumentBlockHint | DocumentBlockQuote | DocumentBlockMath | DocumentBlockTable)[];
    isVoid?: false;
    data?: {
        checked?: boolean;
    };
}
export interface DocumentBlockListOrdered {
    object: 'block';
    type: 'list-ordered';
    key?: string;
    data: {
        /** An integer to start counting from for the list items. */
        start?: number;
    };
    nodes: DocumentBlockListItem[];
    isVoid?: false;
}
export interface DocumentBlockListUnordered {
    object: 'block';
    type: 'list-unordered';
    key?: string;
    nodes: DocumentBlockListItem[];
    data?: object;
    isVoid?: false;
}
export interface DocumentBlockListTasks {
    object: 'block';
    type: 'list-tasks';
    key?: string;
    nodes: DocumentBlockListItem[];
    isVoid?: false;
    data?: object;
}
export interface DocumentBlockDivider {
    object: 'block';
    type: 'divider';
    key?: string;
    isVoid: true;
    data: object;
}
export type Length = number | {
    unit: string;
    value: number;
};
export interface DocumentBlockImage {
    object: 'block';
    type: 'image';
    key?: string;
    data: {
        ref: ContentRefURL | ContentRefFile;
        refDark?: ContentRefURL | ContentRefFile;
        width?: Length;
        height?: Length;
        alt?: string;
    };
    fragments: (DocumentFragment & {
        fragment: 'caption';
        nodes: DocumentBlockParagraph[];
    })[];
    isVoid: true;
}
export interface DocumentBlockImages {
    object: 'block';
    type: 'images';
    key?: string;
    data: {
        align?: 'center' | 'left' | 'right';
        fullWidth?: boolean;
    };
    nodes: DocumentBlockImage[];
    isVoid: false;
}
export interface DocumentBlockFile {
    object: 'block';
    type: 'file';
    key?: string;
    data: {
        ref: ContentRefFile;
    };
    isVoid: true;
}
export interface DocumentBlockDrawing {
    object: 'block';
    type: 'drawing';
    key?: string;
    data: {
        ref?: ContentRefFile;
    };
    isVoid: true;
}
export interface DocumentBlockEmbed {
    object: 'block';
    type: 'embed';
    key?: string;
    data: {
        url: string;
        fullWidth?: boolean;
    };
    isVoid: true;
}
export interface DocumentBlockReusableContent {
    object: 'block';
    type: 'reusable-content';
    key?: string;
    data: {
        ref: ContentRefReusableContent;
    };
    isVoid: true;
    meta?: {
        /** A content token that can be used to fetch the reusable content from the API. */
        token?: string;
    };
}
export interface DocumentBlockExpandable {
    object: 'block';
    type: 'expandable';
    key?: string;
    isVoid: true;
    data: object;
    fragments: ((DocumentFragment & {
        fragment: 'expandable-title';
        type: 'expandable-title';
        /**
         * @maxItems 1
         * @minItems 1
         */
        nodes: DocumentBlockParagraph[];
    }) | (DocumentFragment & {
        fragment: 'expandable-body';
        type: 'expandable-body';
        /** @minItems 1 */
        nodes: (DocumentBlocksEssentials | DocumentBlockImages | DocumentBlockCode | DocumentBlockTable | DocumentBlockHint | DocumentBlockQuote | DocumentBlockReusableContent)[];
    }))[];
    meta?: {
        /** Unique ID to be used in an URL for the block. */
        id: string;
    };
}
export interface DocumentBlockContentRef {
    object: 'block';
    type: 'content-ref';
    key?: string;
    data: {
        /** A relative reference to content in GitBook. */
        ref: ContentRef;
    };
    isVoid: true;
}
export type PlainObject = any;
/** Action to open an overlay modal defined by "componentId". */
export type ContentKitDefaultAction = {
    action: '@ui.modal.open';
    componentId: string;
    props: PlainObject;
} | {
    action: '@ui.modal.close';
    returnValue: PlainObject;
} | {
    action: '@ui.url.open';
    url: string;
} | {
    action: '@link.unfurl';
    url: string;
} | {
    action: '@editor.node.updateProps';
    props: PlainObject;
};
/** Custom action to re-render the block. */
export type ContentKitAction = {
    action: string;
    [key: string]: any;
} | ContentKitDefaultAction;
export interface DocumentBlockIntegration {
    object: 'block';
    type: 'integration';
    key?: string;
    data: {
        /** Name of the integration */
        integration: string;
        /** ID of the block in the integration */
        block: string;
        /** Properties passed to the block during rendering */
        props: PlainObject;
        /** Custom action to re-render the block. */
        action?: ContentKitAction;
        /**
         * URL associated with the content represented by the block.
         * This property is set when creating a block from a URL (unfurl) to ensure
         * we can convert the block back to an embed.
         */
        url?: string;
        fullWidth?: boolean;
    };
    isVoid: true;
}
export interface DocumentBlockTabsItem {
    object: 'block';
    type: 'tabs-item';
    key?: string;
    nodes: (DocumentBlocksEssentials | DocumentBlockContentRef | DocumentBlockCode | DocumentBlockEmbed | DocumentBlockFile | DocumentBlockImages | DocumentBlockDrawing | DocumentBlockHint | DocumentBlockQuote | DocumentBlockMath | DocumentBlockIntegration)[];
    data: {
        title?: string;
    };
    meta?: {
        /** Unique ID to be used in an URL for the block. */
        id: string;
    };
    isVoid?: false;
}
export interface DocumentBlockTabs {
    object: 'block';
    type: 'tabs';
    key?: string;
    nodes: DocumentBlockTabsItem[];
    isVoid?: false;
    data?: {
        fullWidth?: boolean;
    };
}
/** Pointer to an operation in the OpenAPI spec. */
export interface OpenAPIOperationPointer {
    /** Path of the operation in the OpenAPI spec. */
    path: string;
    /** HTTP method of the operation in the OpenAPI spec. */
    method: string;
}
export interface DocumentBlockOpenAPI {
    object: 'block';
    type: 'swagger';
    key?: string;
    data: OpenAPIOperationPointer & {
        ref: ContentRefFile | ContentRefURL;
        /** If true, the block is opened by default. */
        expanded?: boolean;
        fullWidth?: boolean;
    };
    isVoid: true;
    meta?: {
        /** Unique ID to be used in an URL for the block. */
        id: string;
    };
}
export interface DocumentBlockOpenAPIOperation {
    object: 'block';
    type: 'openapi-operation';
    key?: string;
    data: OpenAPIOperationPointer & {
        ref: ContentRefOpenAPI;
    };
    isVoid: true;
    meta?: {
        /** Unique ID to be used in an URL for the block. */
        id: string;
    };
}
/** Pointer to schemas in the OpenAPI spec. */
export interface OpenAPISchemasPointer {
    /**
     * Whether the schemas are grouped or not.
     * @default true
     */
    grouped?: boolean;
    /** List of schemas name from the OpenAPI spec. */
    schemas: string[];
}
export interface DocumentBlockOpenAPISchemas {
    object: 'block';
    type: 'openapi-schemas';
    key?: string;
    data: OpenAPISchemasPointer & {
        ref: ContentRefOpenAPI;
    };
    isVoid: true;
    meta?: {
        /** Unique ID to be used in an URL for the block. */
        id: string;
    };
}
/** Pointer to a webhook in the OpenAPI spec. */
export interface OpenAPIWebhookPointer {
    /** Name of the webhook in the OpenAPI spec. */
    name: string;
    /** HTTP method of the webhook in the OpenAPI spec. */
    method: string;
}
export interface DocumentBlockOpenAPIWebhook {
    object: 'block';
    type: 'openapi-webhook';
    key?: string;
    data: OpenAPIWebhookPointer & {
        ref: ContentRefOpenAPI;
    };
    isVoid: true;
    meta?: {
        /** Unique ID to be used in an URL for the block. */
        id: string;
    };
}
export interface DocumentBlockStepperStep {
    object: 'block';
    type: 'stepper-step';
    key?: string;
    nodes: (DocumentBlocksEssentials | DocumentBlockContentRef | DocumentBlockCode | DocumentBlockEmbed | DocumentBlockFile | DocumentBlockImages | DocumentBlockDrawing | DocumentBlockHint | DocumentBlockQuote | DocumentBlockMath | DocumentBlockIntegration)[];
    data: {
        icon?: string;
    };
    isVoid?: false;
}
export interface DocumentBlockStepper {
    object: 'block';
    type: 'stepper';
    key?: string;
    nodes: DocumentBlockStepperStep[];
    isVoid?: false;
    data?: object;
}
export interface DocumentBlockColumn {
    object: 'block';
    type: 'column';
    key?: string;
    nodes: (DocumentBlocksEssentials | DocumentBlockImages | DocumentBlockCode | DocumentBlockHint | DocumentBlockContentRef | DocumentBlockDrawing | DocumentBlockEmbed | DocumentBlockFile | DocumentBlockIntegration | DocumentBlockMath | DocumentBlockQuote)[];
    isVoid?: false;
    data: {
        width?: Length;
    };
}
export interface DocumentBlockColumns {
    object: 'block';
    type: 'columns';
    key?: string;
    data: {
        fullWidth?: boolean;
    };
    nodes: DocumentBlockColumn[];
    isVoid: false;
}
export type DocumentBlock = DocumentBlockParagraph | DocumentBlockHeading | DocumentBlockListOrdered | DocumentBlockListUnordered | DocumentBlockListTasks | DocumentBlockListItem | DocumentBlockDivider | DocumentBlockQuote | DocumentBlockHint | DocumentBlockImages | DocumentBlockImage | DocumentBlockFile | DocumentBlockDrawing | DocumentBlockEmbed | DocumentBlockCode | DocumentBlockCodeLine | DocumentBlockMath | DocumentBlockExpandable | DocumentBlockTabs | DocumentBlockTabsItem | DocumentBlockTable | DocumentBlockOpenAPI | DocumentBlockOpenAPIOperation | DocumentBlockOpenAPISchemas | DocumentBlockOpenAPIWebhook | DocumentBlockContentRef | DocumentBlockIntegration | DocumentBlockReusableContent | DocumentBlockStepper | DocumentBlockStepperStep | DocumentBlockColumns | DocumentBlockColumn;
export interface DocumentInlineMention {
    object: 'inline';
    type: 'mention';
    key?: string;
    data: {
        /** A relative reference to content in GitBook. */
        ref: ContentRef;
    };
    isVoid: true;
}
export interface DocumentInlineButton {
    object: 'inline';
    type: 'button';
    key?: string;
    data: {
        label: string;
        kind: 'primary' | 'secondary';
        /** Name of the icon */
        icon?: Icon;
    } & {
        /** A relative reference to content in GitBook. */
        ref: ContentRef;
    };
    isVoid: true;
}
export type DocumentBlocksTopLevels = DocumentBlocksEssentials | DocumentBlockQuote | DocumentBlockHint | DocumentBlockImages | DocumentBlockFile | DocumentBlockDrawing | DocumentBlockEmbed | DocumentBlockCode | DocumentBlockMath | DocumentBlockExpandable | DocumentBlockTabs | DocumentBlockTable | DocumentBlockOpenAPI | DocumentBlockOpenAPIOperation | DocumentBlockOpenAPISchemas | DocumentBlockOpenAPIWebhook | DocumentBlockContentRef | DocumentBlockIntegration | DocumentBlockReusableContent | DocumentBlockStepper;
export interface JSONDocument {
    object: 'document';
    data: {
        /** The schema version of the document. If undefined, the document is considered to be of the latest schema version. */
        schemaVersion?: number;
        [key: string]: any;
    };
    nodes: DocumentBlocksTopLevels[];
}
export type Document = MarkdownDocument | {
    document: JSONDocument;
} | object;
export type RevisionPageDocument = RevisionPageBase & Document & {
    /** @deprecated */
    kind: 'sheet';
    type: 'document';
    urls: {
        /** Location of the page in the app */
        app: URL;
    };
    /** Page's slug in its direct parent */
    slug: string;
    /** Complete path to access the page in the revision. */
    path: string;
    description?: string;
    /** ID of the document with the page body. If undefined, the page is empty. */
    documentId?: string;
    pages: (RevisionPageDocument | RevisionPageLink | RevisionPageComputed)[];
    git?: GitSyncBlob;
    layout: RevisionPageLayoutOptions;
    cover?: RevisionPageDocumentCover;
    variables?: Variables;
    /**
     * If true, the page is not displayed in the navigation, while still being accessible.
     * @default false
     */
    hidden?: boolean;
    /**
     * If true, the page is not indexable in the search and ask features.
     * @default false
     */
    noIndex?: boolean;
    /**
     * If true, the page is not indexable by search engine robots.
     * @default false
     */
    noRobotsIndex?: boolean;
} & ({
    computed: ComputedContentSourceDocument;
    /** Seed to use for the generation of IDs. */
    computedSeed: string;
} | {
    /** ID of the document with the page body. If undefined, the page is empty. */
    documentId?: string;
});
export type RevisionPageLink = RevisionPageBase & {
    /** @deprecated */
    kind: 'link';
    type: 'link';
    /** A relative reference to content in GitBook. */
    target: ContentRef;
    href?: string;
    /**
     * If true, the page is not displayed in the navigation, while still being accessible.
     * @default false
     */
    hidden?: boolean;
};
export interface ComputedContentDependencyOpenAPI {
    ref: ContentRefOpenAPI;
    /** See `OpenAPI` schema component. */
    value: {
        object: 'openapi-spec';
        id: string;
        slug: string;
        lastVersion?: string;
    } | null;
}
/** Generic parameters from an OpenAPI computed content source */
export interface ComputedContentSourceOpenAPIBase {
    type: 'builtin:openapi';
    dependencies: {
        spec: {
            ref: ContentRefOpenAPI;
        } | ComputedContentDependencyOpenAPI;
    };
}
/** Parameters for an OpenAPI computed revision */
export type ComputedContentSourceRevisionOpenAPI = ComputedContentSourceOpenAPIBase & {
    props: {
        models: boolean;
    };
};
export interface ComputedContentDependencySpace {
    ref: ContentRefSpace;
    /** See `Space` schema component. */
    value: {
        object: 'space';
        id: string;
        revision: string;
    } | null;
}
export declare enum TranslationLanguage {
    En = "en",
    Fr = "fr",
    De = "de",
    Es = "es",
    It = "it",
    Pt = "pt",
    Ru = "ru",
    Ja = "ja",
    Zh = "zh",
    Ko = "ko",
    Ar = "ar",
    Hi = "hi",
    Nl = "nl",
    Pl = "pl",
    Tr = "tr",
    Sv = "sv",
    No = "no",
    Da = "da",
    Fi = "fi",
    El = "el",
    Cs = "cs",
    Hu = "hu",
    Ro = "ro",
    Th = "th",
    Vi = "vi",
    Id = "id",
    Ms = "ms",
    He = "he",
    Uk = "uk",
    Sk = "sk",
    Bg = "bg",
    Hr = "hr",
    Lt = "lt",
    Lv = "lv",
    Et = "et",
    Sl = "sl"
}
export interface TranslationLanguageRef {
    kind: 'translation-language';
    /** ID of the translation settings */
    translationSettings: string;
    language: TranslationLanguage;
}
/** Compiled parameters for the translation */
export interface TranslationParameters {
    /** Instructions for the translation, formatted as markdown */
    instructions: string;
}
export interface ComputedContentDependencyTranslation {
    ref: TranslationLanguageRef;
    /** Compiled parameters for the translation */
    value: TranslationParameters;
}
/** Generic parameters from a translation computed content source */
export interface ComputedContentSourceTranslationBase {
    type: 'builtin:translation';
    dependencies: {
        source: {
            ref: ContentRefSpace;
        } | ComputedContentDependencySpace;
        settings: {
            ref: TranslationLanguageRef;
        } | ComputedContentDependencyTranslation;
    };
}
export type ComputedContentSourceRevisionTranslation = ComputedContentSourceTranslationBase & {
    props: {
        sourceLanguage: TranslationLanguage;
    };
};
/** Dependency for a computation, before its resolution. */
export interface ComputedContentDependency {
    ref: ContentRefSpace | ContentRefOpenAPI | TranslationLanguageRef;
}
/** Dependency for a computation, with its resolved value. */
export type ComputedContentDependencyResolved = ComputedContentDependencySpace | ComputedContentDependencyOpenAPI | ComputedContentDependencyTranslation;
/** Parameters for a computed content managed by an integration */
export interface ComputedContentSourceIntegration {
    /**
     * Type of the computed source
     * @pattern ^integration:[^:]+:[^:]+$
     */
    type: string;
    /** Properties to be passed to the computation */
    props: PlainObject;
    /**
     * Dependencies the computation depends on.
     * The state of the dependencies will be passed to the computation.
     * When the dependency's targets are updated, the computation will be updated.
     */
    dependencies?: Record<string, ComputedContentDependency | ComputedContentDependencyResolved>;
}
export type ComputedContentSourceRevision = ComputedContentSourceRevisionOpenAPI | ComputedContentSourceRevisionTranslation | ComputedContentSourceIntegration;
export type RevisionPageComputed = RevisionPageBase & {
    type: 'computed';
    computed: ComputedContentSourceRevision;
};
export interface GitSyncBlob {
    /** SHA for the blob */
    oid: string;
    /** Path of the blob in the Git tree */
    path: string;
}
/** Size of the cover image. */
export declare enum RevisionPageLayoutOptionsCoverSize {
    Hero = "hero",
    Full = "full"
}
export interface RevisionPageLayoutOptions {
    /** Should the cover be visible? */
    cover?: boolean;
    /** Size of the cover image. */
    coverSize?: RevisionPageLayoutOptionsCoverSize;
    /** Should the title be visible? */
    title?: boolean;
    /** Should the description be visible? */
    description?: boolean;
    /** Should the table of contents be visible? */
    tableOfContents?: boolean;
    /** Should the outline be visible? */
    outline?: boolean;
    /** Should the pagination be visible? */
    pagination?: boolean;
}
export interface RevisionPageDocumentCover {
    /** Content reference pointing to the source image. */
    ref?: ContentRefFile | ContentRefURL;
    /** Content reference pointing to the source image for dark mode. */
    refDark?: ContentRefFile | ContentRefURL;
    /**
     * Vertical position of the cover image.
     * @default 0
     */
    yPos: number;
}
export type VariableValue = string | number | boolean;
export type Variables = Record<string, VariableValue>;
/** Parameters for an OpenAPI computed document */
export type ComputedContentSourceDocumentOpenAPI = ComputedContentSourceOpenAPIBase & {
    props: {
        doc: 'models';
    } | {
        doc: 'operations' | 'info';
        /** @minLength 1 */
        page: string;
    };
};
export type ComputedContentSourceDocumentTranslation = ComputedContentSourceTranslationBase & {
    props: {
        document: string;
        sourceLanguage: TranslationLanguage;
    };
};
export type ComputedContentSourceDocument = ComputedContentSourceDocumentOpenAPI | ComputedContentSourceDocumentTranslation | ComputedContentSourceIntegration;
export type RevisionPageGroup = RevisionPageBase & {
    /** @deprecated */
    kind: 'group';
    type: 'group';
    /** Page's slug in its direct parent */
    slug: string;
    /** Complete path to access the page in the revision. */
    path: string;
    /**
     * If true, the page is not displayed in the navigation, while still being accessible.
     * @default false
     */
    hidden?: boolean;
    /**
     * If true, the page is not indexable in the search and ask features.
     * @default false
     */
    noIndex?: boolean;
    /**
     * If true, the page is not indexable by search engine robots.
     * @default false
     */
    noRobotsIndex?: boolean;
    pages: (RevisionPageDocument | RevisionPageLink | RevisionPageComputed)[];
};
export type RevisionPage = RevisionPageDocument | RevisionPageGroup | RevisionPageLink | RevisionPageComputed;
export interface RevisionFile {
    id: string;
    name: string;
    contentType: string;
    downloadURL: string;
    size: number;
    /** For images, it contains the dimensions of it. */
    dimensions?: {
        width: number;
        height: number;
    };
    git?: GitSyncBlob;
}
export interface RevisionReusableContent {
    id: string;
    title: string;
    document?: string;
    git?: GitSyncBlob;
}
export interface GitSyncCommit {
    /** SHA for the commit */
    oid: string;
    /** Message describing the purpose of the commit */
    message: string;
    /** If true, the Git commit was generated by an export from GitBook */
    createdByGitBook: boolean;
    /** URL of the commit in the GitSync provider */
    url?: string;
    /** Original name of the ref where the commit originated from */
    ref?: string;
}
export interface RevisionBase {
    /** Type of Object, always equals to "revision" */
    object: 'revision';
    /** Unique identifier for the revision */
    id: string;
    /** IDs of the parent revisions */
    parents: string[];
    pages: RevisionPage[];
    files: RevisionFile[];
    reusableContents: RevisionReusableContent[];
    variables?: Variables;
    /** When the revision was created. */
    createdAt: Timestamp;
    /** Metadata about a potential associated git commit. */
    git?: GitSyncCommit;
    urls: {
        /**
         * URL in the application for the revision
         * @format uri
         */
        app: string;
        /**
         * URL of the published version of the revision. Only defined when the space visibility is not "private."
         * @format uri
         */
        published?: string;
        /**
         * URL of the public version of the revision. Only defined when the space visibility is "public".
         * @format uri
         */
        public?: string;
    };
}
export type RevisionTypeEdits = RevisionBase & {
    /** Revision created by editing the content. */
    type: 'edits';
};
export declare enum ChangeRequestStatus {
    Draft = "draft",
    Open = "open",
    Archived = "archived",
    Merged = "merged"
}
/**
 * Subject of the change request
 * @minLength 0
 * @maxLength 100
 */
export type ChangeRequestSubject = string;
export interface ChangeRequest {
    /** Type of Object, always equals to "change-request" */
    object: 'change-request';
    /** Unique identifier for the change request */
    id: string;
    /** Incremental identifier of the change request */
    number: number;
    status: ChangeRequestStatus;
    /** Subject of the change request */
    subject: ChangeRequestSubject;
    createdBy: User;
    createdAt: Timestamp;
    updatedAt: Timestamp;
    /** ID of the active revision in the change request. */
    revision: string;
    /** ID of the initial revision in the space from which the change request was created. */
    revisionInitial: string;
    /** ID of the latest revision when updating from main space content. */
    revisionMergedAncestor?: string;
    /** When merged, ID of the revision resulting from the merge. */
    revisionMerged?: string;
    /** Count of opened comments on the change request. */
    comments: number;
    /** If true, the change request is not up-to-date with latest changes in the main content. */
    outdated: boolean;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the space in the application
         * @format uri
         */
        app: string;
        /**
         * URL of the user in the API
         * @format uri
         */
        location: string;
    };
}
export type RevisionTypeMerge = RevisionBase & {
    /** Revision created when merging a change request with primary. */
    type: 'merge';
    mergedFrom: ChangeRequest;
};
export type RevisionTypeRollback = RevisionBase & {
    /** Revision created as a rollback of a previous revision. */
    type: 'rollback';
};
export type RevisionTypeUpdate = RevisionBase & {
    /** Revision created when updating a change request with changes from primary. */
    type: 'update';
};
export type RevisionTypeComputed = RevisionBase & {
    /** Virtual revision, computed from a source revision */
    type: 'computed';
};
export type Revision = RevisionTypeEdits | RevisionTypeMerge | RevisionTypeRollback | RevisionTypeUpdate | RevisionTypeComputed;
export declare enum ImportContentSource {
    Website = "website",
    Docx = "docx",
    Markdown = "markdown",
    Html = "html",
    Zip = "zip",
    Confluence = "confluence",
    GithubWiki = "github-wiki",
    DropboxPaper = "dropbox-paper",
    Notion = "notion",
    Quip = "quip",
    GoogleDocs = "google-docs"
}
export interface ImportContent {
    /**
     * URL of the content to import.
     * @format uri
     */
    url: string;
    source: ImportContentSource;
}
export interface ImportContentResult {
    /** ID of the newly created revision. */
    revision: string;
    /** How many resources were imported */
    importedResources: number;
    /** How many resources were processed */
    totalResources: number;
}
/**
 * Name of the organization
 * @minLength 2
 * @maxLength 255
 */
export type OrganizationTitle = string;
export type OrganizationEmailDomains = string[];
/**
 * Default hostname for the organization's public content, e.g. <org-hostname>.gitbook.io
 * @minLength 3
 * @maxLength 32
 */
export type OrganizationHostname = string;
export declare enum OrganizationType {
    Business = "business",
    Community = "community"
}
export declare enum OrganizationUseCase {
    InternalDocs = "internalDocs",
    DocsSite = "docsSite",
    AudienceControlledSite = "audienceControlledSite",
    ProductDocs = "productDocs",
    TeamKnowledgeBase = "teamKnowledgeBase",
    DesignSystem = "designSystem",
    OpenSourceDocs = "openSourceDocs",
    Notes = "notes",
    Other = "other"
}
export declare enum OrganizationCommunityType {
    NonProfit = "nonProfit",
    OpenSource = "openSource",
    Education = "education"
}
export interface SitePointer {
    type: 'site';
    /** Unique identifier for the site */
    site: string;
}
/** The default content for the organization */
export type OrganizationDefaultContent = SitePointer;
/** Name of the product */
export declare enum BillingProduct {
    Free2024 = "free_2024",
    Plus2024 = "plus_2024",
    Pro2024 = "pro_2024",
    Enterprise2024 = "enterprise_2024",
    Community2024 = "community_2024",
    Free = "free",
    Plus = "plus",
    Pro = "pro",
    Team = "team",
    Business = "business",
    Legacy = "legacy",
    Startup = "startup",
    Enterprise = "enterprise",
    Community = "community",
    TeamOct2019Free = "team_oct_2019_free",
    TeamDec2021 = "team_dec_2021",
    BusinessDec2021 = "business_dec_2021"
}
/** Interval for a billing subscription */
export declare enum BillingInterval {
    Monthly = "monthly",
    Yearly = "yearly"
}
export interface OrganizationBilling {
    /** Interval for a billing subscription */
    interval: BillingInterval;
    endDate: Timestamp | null;
    /** If true, we were unable to collect the last payment */
    hasPaymentFailed: boolean;
    /** If true, the billing is set to cancel at the end of its current period */
    isScheduledToCancel: boolean;
}
/** - notapplicable, no trial can be started for this organization. - none, no trial has been started yet. - active, trial is active. - ended, the trial has ended and the user has choosen to stay on the free plan or has upgraded to a paid plan. - expired, the trial has ended but the user hasn't deciced yet what to do. */
export declare enum BillingTrialStatus {
    Notapplicable = "notapplicable",
    None = "none",
    Active = "active",
    Ended = "ended",
    Expired = "expired"
}
export declare enum OrganizationBlockReason {
    Security = "security"
}
export interface Organization {
    /** Type of Object, always equals to "organization" */
    object: 'organization';
    /** Unique identifier for the organization */
    id: string;
    /** Name of the organization */
    title: OrganizationTitle;
    createdAt: Timestamp;
    emailDomains: OrganizationEmailDomains;
    /** Default hostname for the organization's public content, e.g. <org-hostname>.gitbook.io */
    hostname?: OrganizationHostname;
    type: OrganizationType;
    useCase?: OrganizationUseCase;
    communityType?: OrganizationCommunityType;
    /** The role of a member in an organization, null for guests */
    defaultRole?: MemberRoleOrGuest;
    /** The default content for the organization */
    defaultContent?: OrganizationDefaultContent;
    /** Whether SSO is enforced organization-wide */
    sso?: boolean;
    /** If true, the organization is configured to use all our AI features. */
    ai?: boolean;
    /** If true, invite links are enabled for this organization. */
    inviteLinks: boolean;
    /** Name of the product */
    plan: BillingProduct;
    /** Billing details, only available for org members. */
    billing?: OrganizationBilling;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the organization in the API
         * @format uri
         */
        location: string;
        /**
         * URL of the organization in the application
         * @format uri
         */
        app: string;
        /** URL of the logo of this organization, if defined. */
        logo?: URL;
    };
    trial: {
        /** - notapplicable, no trial can be started for this organization. - none, no trial has been started yet. - active, trial is active. - ended, the trial has ended and the user has choosen to stay on the free plan or has upgraded to a paid plan. - expired, the trial has ended but the user hasn't deciced yet what to do. */
        status: BillingTrialStatus;
        /** The trial's end date, if the organization has or had a trial. */
        endDate?: Timestamp;
        /** The decision taken by the user at the end of the trial */
        decision?: 'downgrade';
    };
    /** Custom hostname linked to this organization */
    customHostname?: string;
    /** If the organization is blocked, information about the block will appear here */
    blocked?: {
        reason: OrganizationBlockReason;
    };
    /**
     * Deprecated. Always true. All organizations are on new trials.
     * @deprecated
     */
    internal_isOnNewTrial?: true;
    internal_billingMigration?: {
        /** When we will upgrade the organization onto new pricing, if they haven't already. */
        deadline?: Timestamp;
        /** A discount the organization may have received thanks to migrating early. */
        discountPercent?: number;
        /** The expiration date of the discount, after wich regular pricing resumes. */
        discountEndDate?: Timestamp;
    };
    /** The set of permissions for the organization */
    permissions: {
        /** Can the user view the organization. */
        view: boolean;
        /** Can the user manage the title, members, etc. */
        admin: boolean;
        /** Is the user a team owner. */
        ownTeam: boolean;
        /** Can the user create new spaces/collections in the organization. */
        createContent: boolean;
        /** Can the user create new OpenAPI specifications. */
        createOpenAPISpec: boolean;
        /** Can the user ingest conversations in the organization. */
        ingestConversations: boolean;
        /** Can the user view the billing details of the organization. */
        viewBilling: boolean;
        /** Can the user list the members of the organization. */
        listMembers: boolean;
        /** Can the user list the teams in the organization. */
        listTeams: boolean;
        /** Can the user list the integrations in the organization. */
        listIntegrations: boolean;
    };
}
export interface ContentLocationRevisionContext {
    type: 'revision';
    revision: Revision;
}
export interface ContentLocationChangeRequestContext {
    type: 'changeRequest';
    changeRequest: ChangeRequest;
}
export interface ContentLocationFile {
    kind: 'file';
    organization: Organization;
    space: Space;
    versionContext?: ContentLocationRevisionContext | ContentLocationChangeRequestContext;
    file: RevisionFile;
}
export interface ContentLocationURL {
    kind: 'url';
    url: string;
}
export interface ContentLocationPageAnchor {
    type: 'anchor';
    /** The anchor within the page. */
    anchor: string;
}
export interface ContentLocationPageNode {
    type: 'node';
    /** The node id within the page. */
    node: string;
}
export interface ContentLocationPage {
    kind: 'page';
    organization: Organization;
    page: RevisionPage;
    space: Space;
    versionContext?: ContentLocationRevisionContext | ContentLocationChangeRequestContext;
    internalLocation?: ContentLocationPageAnchor | ContentLocationPageNode;
}
export interface ContentLocationUser {
    kind: 'user';
    user: User;
}
/**
 * Title of the collection
 * @maxLength 50
 */
export type CollectionTitle = string;
/**
 * Description of the collection
 * @minLength 0
 * @maxLength 100
 */
export type CollectionDescription = string;
export interface Collection {
    /** Type of Object, always equals to "collection" */
    object: 'collection';
    /** Unique identifier for the collection */
    id: string;
    /** Title of the collection */
    title: CollectionTitle;
    /** Description of the collection */
    description?: CollectionDescription;
    /** ID of the organization owning this collection */
    organization: string;
    /** ID of the parent collection, if any */
    parent?: string;
    /** Default level for a piece of content */
    defaultLevel: DefaultLevel;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the collection in the API
         * @format uri
         */
        location: string;
        /**
         * URL of the collection in the application
         * @format uri
         */
        app: string;
    };
    /** The set of permissions for the collection */
    permissions: {
        /** Can the user view the collection. */
        view: boolean;
        /** Can the user edit the title/description. */
        admin: boolean;
        /** Can the user view the invite links of the collection. */
        viewInviteLinks: boolean;
        /** Can the user create spaces/collections in this collection. */
        create: boolean;
    };
}
export interface ContentLocationCollection {
    kind: 'collection';
    organization: Organization;
    collection: Collection;
}
export interface ContentLocationSpace {
    kind: 'space';
    organization: Organization;
    space: Space;
}
export interface ContentLocationReusableContent {
    kind: 'reusable-content';
    organization: Organization;
    space: Space;
    versionContext?: ContentLocationRevisionContext | ContentLocationChangeRequestContext;
    reusableContent: RevisionReusableContent;
}
/**
 * Slug used as reference
 * @minLength 1
 * @maxLength 100
 * @pattern ^[a-z0-9]+(?:-[a-z0-9]+)*$
 */
export type OpenAPISpecSlug = string;
/** Processing state */
export declare enum OpenAPISpecProcessingState {
    Pending = "pending",
    Progress = "progress",
    Complete = "complete"
}
/** OpenAPI processing error code */
export declare enum OpenAPISpecProcessingErrorCode {
    FETCH_TIMEOUT = "FETCH_TIMEOUT",
    FETCH_ERROR = "FETCH_ERROR",
    PARSE_ERROR = "PARSE_ERROR"
}
export interface OpenAPISpec {
    /** The object type, which is always "openapi-spec" */
    object: 'openapi-spec';
    /** Unique identifier */
    id: string;
    /** Date of creation */
    createdAt: Timestamp;
    /** Date of the last update */
    updatedAt: Timestamp;
    /** Slug used as reference */
    slug: OpenAPISpecSlug;
    sourceURL?: URL;
    /** Processing state */
    processingState: OpenAPISpecProcessingState;
    /** ID of the latest version of the OpenAPI specification */
    lastVersion?: string;
    /** Date of the last processing */
    lastProcessedAt?: Timestamp;
    /** OpenAPI processing error code */
    lastProcessErrorCode?: OpenAPISpecProcessingErrorCode;
    /** The set of permissions for the OpenAPI specification. */
    permissions: {
        /** Can the user view the specification. */
        view: boolean;
        /** Can the user edit the specification. */
        edit: boolean;
    };
    /** URLs associated with the object */
    urls: {
        /** URL of the OpenAPI specification in the API */
        location: URL;
        /** URL of the OpenAPI specification in the application */
        app: URL;
    };
}
export interface ContentLocationOpenAPI {
    kind: 'openapi';
    organization: Organization;
    openAPISpec: OpenAPISpec;
}
/** An absolute reference to content in GitBook. */
export type ContentLocation = ContentLocationFile | ContentLocationURL | ContentLocationPage | ContentLocationUser | ContentLocationCollection | ContentLocationSpace | ContentLocationReusableContent | ContentLocationOpenAPI;
/**
 * Text to display to represent the reference. Possible values include:
 * - `ok` - No problems detected for this content reference.
 * - `broken` - The target does not exist in the revision.
 * - `in-app` - The target is a URL link pointing to an internal location in the app.
 */
export declare enum ContentReferenceStatus {
    Ok = "ok",
    Broken = "broken",
    InApp = "in-app"
}
export interface ContentReferencesStats {
    /** Total count of links */
    total: number;
    broken: {
        /** Count of broken links */
        total: number;
        /** Count of broken links that were broken in current change request, if applicable. */
        changeRequest?: number;
    };
}
/**
 * Indicator of the relationship with the content ref target.
 * - `reference` - The content soft-references the ref target
 * - `dependsOn` - The content depends on the ref target
 */
export declare enum ContentReferenceRelation {
    Reference = "reference",
    DependsOn = "dependsOn"
}
export interface ContentReferenceUsage {
    /**
     * Text to display to represent the reference. Possible values include:
     * - `ok` - No problems detected for this content reference.
     * - `broken` - The target does not exist in the revision.
     * - `in-app` - The target is a URL link pointing to an internal location in the app.
     */
    status: ContentReferenceStatus;
    /**
     * Indicator of the relationship with the content ref target.
     * - `reference` - The content soft-references the ref target
     * - `dependsOn` - The content depends on the ref target
     */
    relation: ContentReferenceRelation;
    /** The reference target where a list of pages are pointing at */
    targetReference?: ContentLocation;
    /** Pages locations where a link to the target is found. */
    locationReferences: ContentLocation[];
}
/** Status of a change request review. */
export declare enum ChangeRequestReviewStatus {
    ChangesRequested = "changes-requested",
    Approved = "approved"
}
/** An emoji reaction by one or many users */
export interface EmojiReaction {
    /** The Emoji of the reaction */
    emoji: string;
    /** The number of users who reacted with this emoji */
    count: number;
    /** The users who reacted with this emoji */
    users: {
        user: User;
        reactedAt: Timestamp;
    }[];
}
export type EmojiReactions = EmojiReaction[];
export type Comment = {
    /** Type of Object, always equals to "comment" */
    object: 'comment';
    /** Unique identifier for the comment. */
    id: string;
    /** The user who posted the comment. */
    postedBy: User;
    /** When the comment was posted. */
    postedAt: Timestamp;
    /** Date when the comment was edited, if it has been edited. */
    editedAt?: Timestamp;
    /** Any emoji reactions to the comment. */
    reactions: EmojiReactions;
    /** The number of replies to this comment. */
    replies: number;
    /** The content of the comment. */
    body: Document;
    /** Information about the target of the comment. */
    target: {
        /** The node this comment is attached to. */
        node?: {
            id: string;
            preview?: string;
        };
        /** The change request containing this comment, if the comment was made inside a change request. */
        changeRequest?: string;
        /** The review containing this comment, if this comment was made as part of a review. */
        review?: string;
        /** Information about the page, if this comment refers to a specific page. */
        page?: RevisionPageBase & {
            /** The fully qualified path to the page */
            path: string;
            /** True if the target of this comment no longer exists in the primary content */
            outdated: boolean;
        };
        /** The space containing this comment. */
        space: string;
        /** The revision in which the target can be found in. */
        revision: string;
    };
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the comment in the API
         * @format uri
         */
        location: string;
    };
    /** The set of permissions for the comment */
    permissions: {
        /** Can the user view the comment. */
        view: boolean;
        /** Can the user edit the comment. */
        edit: boolean;
        /** Can the user react or send a reply to the comment. */
        reply?: boolean;
        /** Can the user delete the comment. */
        delete: boolean;
    };
} & ({
    /** Status of the comment. */
    status: 'resolved';
    /** If the comment has been resolved, the date at which it was resolved. If this field is not defined, the comment is not resolved. */
    resolvedAt: Timestamp;
    /** If the comment has been resolved, the user who resolved it. If this field is not defined, the comment is not resolved. */
    resolvedBy: User;
} | {
    /** Status of the comment. */
    status: 'open';
});
export interface ChangeRequestReview {
    /** Type of Object, always equals to "change-request-review" */
    object: 'change-request-review';
    /** Unique identifier for the review. */
    id: string;
    /** The revision this review was made against. */
    revision: string;
    /** The user who performed the review. */
    reviewer: User;
    /** The user who requested the review. If undefined, the review was left without a request. */
    requestedBy?: User;
    /** The status of the review. */
    status: ChangeRequestReviewStatus;
    comment?: Comment;
    createdAt: Timestamp;
    updatedAt: Timestamp;
}
export interface Team {
    /** Type of Object, always equals to "team" */
    object: 'team';
    /** Unique identifier for the team */
    id: string;
}
export type ChangeRequestRequestedReviewer = {
    /** Type of Object, always equals to "change-request-requested-reviewer" */
    object: 'change-request-requested-reviewer';
    /** The revision of the content when the request was made. */
    revision: string;
    /** The user who made the request. */
    requestedBy: User;
    createdAt: Timestamp;
} & ({
    kind: 'user';
    /** The user who was requested to review. */
    user: User;
} | {
    kind: 'team';
    /** The team who was requested to review. */
    team: Team;
});
export interface PostCommentSchema {
    /** The node to which the comment is posted, if any. */
    node?: string;
    /** The page to which the comment is posted, if any. */
    page?: string;
    /** The content of the comment. */
    body: Document;
}
export interface UpdateCommentSchema {
    /** Whether the comment is resolved or not. */
    resolved?: boolean;
    /** Content of the comment. */
    body?: Document;
    /** Reactions to add to the comment. */
    addedReactions?: string[];
    /** Reactions to remove from the comment. */
    removedReactions?: string[];
}
export interface CommentReply {
    /** Type of Object, always equals to "comment-reply" */
    object: 'comment-reply';
    /** Unique identifier for the reply. */
    id: string;
    postedBy: User;
    postedAt: Timestamp;
    /** Date when the reply was edited, if it has been edited. */
    editedAt?: Timestamp;
    reactions: EmojiReactions;
    body: Document;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the comment reply in the API
         * @format uri
         */
        location: string;
    };
    /** The set of permissions for the comment reply */
    permissions: {
        /** Can the user view the comment reply. */
        view: boolean;
        /** Can the user edit the comment reply. */
        edit: boolean;
        /** Can the user react or reply to the comment reply. */
        reply?: boolean;
        /** Can the user delete the comment reply. */
        delete: boolean;
    };
}
export interface PostCommentReplySchema {
    /** The content of the comment. */
    body: Document;
}
/** Contributor towards content. */
export interface UserContributor {
    updatedAt: Timestamp;
    count: number;
    user: User;
}
export declare enum RevisionPageType {
    Document = "document",
    Group = "group",
    Link = "link",
    Computed = "computed"
}
export interface ChangedRevisionPage {
    id: string;
    type: RevisionPageType;
    title: string;
    path?: string;
}
export interface RevisionSemanticChangePageCreated {
    type: 'page_created';
    page: ChangedRevisionPage;
}
export interface ChangeAttributeString {
    before?: string;
    after?: string;
}
export interface ChangeAttributeRevisionPageDocumentCover {
    before?: RevisionPageDocumentCover;
    after?: RevisionPageDocumentCover;
}
/** The core layout presets for a page. */
export declare enum RevisionPageLayoutPreset {
    Docs = "docs",
    Editorial = "editorial",
    Landing = "landing"
}
export type RevisionPageLayout = RevisionPageLayoutPreset | RevisionPageLayoutOptions;
export interface ChangeAttributeRevisionPageLayout {
    before?: RevisionPageLayout;
    after?: RevisionPageLayout;
}
export interface ChangeAttributeVariables {
    before?: Variables;
    after?: Variables;
}
export interface RevisionPageDocumentChangeAttributes {
    title?: ChangeAttributeString;
    description?: ChangeAttributeString;
    slug?: ChangeAttributeString;
    document?: ChangeAttributeString;
    cover?: ChangeAttributeRevisionPageDocumentCover;
    emoji?: ChangeAttributeString;
    layout?: ChangeAttributeRevisionPageLayout;
    variables?: ChangeAttributeVariables;
}
export interface RevisionPageGroupChangeAttributes {
    title?: ChangeAttributeString;
    emoji?: ChangeAttributeString;
    slug?: ChangeAttributeString;
}
export interface ChangeAttributeContentReference {
    /** A relative reference to content in GitBook. */
    before?: ContentRef;
    /** A relative reference to content in GitBook. */
    after?: ContentRef;
}
export interface RevisionPageLinkChangeAttributes {
    title?: ChangeAttributeString;
    emoji?: ChangeAttributeString;
    target?: ChangeAttributeContentReference;
}
export interface RevisionSemanticChangePageEdited {
    type: 'page_edited';
    page: ChangedRevisionPage;
    attributes: RevisionPageDocumentChangeAttributes | RevisionPageGroupChangeAttributes | RevisionPageLinkChangeAttributes;
}
export interface RevisionSemanticChangePageDeleted {
    type: 'page_deleted';
    page: ChangedRevisionPage;
}
export interface RevisionSemanticChangePageMoved {
    type: 'page_moved';
    page: ChangedRevisionPage;
    parent: {
        before?: ChangedRevisionPage;
        after?: ChangedRevisionPage;
    };
}
export interface ChangedRevisionFile {
    id: string;
    name: string;
    contentType: string;
    downloadURL: string;
}
export interface RevisionSemanticChangeFileCreated {
    type: 'file_created';
    file: ChangedRevisionFile;
}
export interface ChangeAttributeNumber {
    before?: number;
    after?: number;
}
export interface RevisionFileImageDimensions {
    height: number;
    width: number;
}
export interface ChangeAttributeRevisionFileImageDimensions {
    before?: RevisionFileImageDimensions;
    after?: RevisionFileImageDimensions;
}
export interface RevisionFileChangeAttributes {
    name?: ChangeAttributeString;
    downloadURL?: ChangeAttributeString;
    size?: ChangeAttributeNumber;
    contentType?: ChangeAttributeString;
    dimensions?: ChangeAttributeRevisionFileImageDimensions;
}
export interface RevisionSemanticChangeFileEdited {
    type: 'file_edited';
    file: ChangedRevisionFile;
    attributes: RevisionFileChangeAttributes;
}
export interface RevisionSemanticChangeFileDeleted {
    type: 'file_deleted';
    file: ChangedRevisionFile;
}
export interface ChangeAttributeVariable {
    before?: VariableValue;
    after?: VariableValue;
}
export interface RevisionSemanticChangeVariablesEdited {
    type: 'variables_edited';
    variables: Record<string, ChangeAttributeVariable>;
}
export interface ChangedRevisionReusableContent {
    id: string;
    title: string;
    document?: string;
}
export interface RevisionSemanticChangeReusableContentCreated {
    type: 'reusable_content_created';
    reusableContent: ChangedRevisionReusableContent;
}
export interface RevisionSemanticChangeReusableContentDeleted {
    type: 'reusable_content_deleted';
    reusableContent: ChangedRevisionReusableContent;
}
export interface RevisionReusableContentChangeAttributes {
    title?: ChangeAttributeString;
    document?: ChangeAttributeString;
}
export interface RevisionSemanticChangeReusableContentEdited {
    type: 'reusable_content_edited';
    reusableContent: ChangedRevisionReusableContent;
    attributes: RevisionReusableContentChangeAttributes;
}
export type RevisionSemanticChange = RevisionSemanticChangePageCreated | RevisionSemanticChangePageEdited | RevisionSemanticChangePageDeleted | RevisionSemanticChangePageMoved | RevisionSemanticChangeFileCreated | RevisionSemanticChangeFileEdited | RevisionSemanticChangeFileDeleted | RevisionSemanticChangeVariablesEdited | RevisionSemanticChangeReusableContentCreated | RevisionSemanticChangeReusableContentDeleted | RevisionSemanticChangeReusableContentEdited;
export interface RevisionSemanticChanges {
    /** The change request object that initiated the changes in the case of a merge revision. */
    mergedFrom?: ChangeRequest;
    changes: RevisionSemanticChange[];
    /** How many changes were omitted because above the result limit */
    more?: number;
}
export interface UpdateCommentReplySchema {
    /** Content of the comment. */
    body?: Document;
    /** Reactions to add to the comment. */
    addedReactions?: string[];
    /** Reactions to remove from the comment. */
    removedReactions?: string[];
}
export interface OrganizationMember {
    /** Type of Object, always equals to "member" */
    object: 'member';
    /** Unique identifier for the user. */
    id: string;
    /** The role of a member in an organization, null for guests */
    role: MemberRoleOrGuest;
    user: User;
    /** Whatever the membership of this user is disabled and prevent them from accessing content. */
    disabled: boolean;
    /** Date at which the user joined the organization. */
    joinedAt: Timestamp;
    /** Date at which the user was last seen active in the organization. */
    lastSeenAt?: Timestamp;
    /** Whether the user can login with SSO. */
    sso: boolean;
    spaces: number;
    teams: number;
}
/**
 * Title of the integration
 * @minLength 2
 * @maxLength 30
 */
export type IntegrationTitle = string;
/**
 * Description of the integration
 * @maxLength 100
 */
export type IntegrationDescription = string;
/**
 * Long form markdown summary of the integration
 * @maxLength 2048
 */
export type IntegrationSummary = string;
/** The target on which the integration can operate and needs to be configured for */
export declare enum IntegrationTarget {
    All = "all",
    Site = "site",
    Space = "space",
    Organization = "organization"
}
export declare enum IntegrationVisibility {
    Public = "public",
    Private = "private",
    Unlisted = "unlisted"
}
export declare enum IntegrationScope {
    SpaceViewsRead = "space:views:read",
    SpaceContentRead = "space:content:read",
    SpaceContentWrite = "space:content:write",
    SpaceMetadataRead = "space:metadata:read",
    SpaceMetadataWrite = "space:metadata:write",
    SpaceScriptInject = "space:script:inject",
    SpaceScriptCookies = "space:script:cookies",
    SpaceGitSync = "space:git:sync",
    SpaceVisitorAuth = "space:visitor:auth",
    SiteMetadataRead = "site:metadata:read",
    SiteViewsRead = "site:views:read",
    SiteScriptInject = "site:script:inject",
    SiteScriptCookies = "site:script:cookies",
    SiteVisitorAuth = "site:visitor:auth",
    SiteAdaptiveRead = "site:adaptive:read",
    SiteAdaptiveWrite = "site:adaptive:write",
    OpenapiRead = "openapi:read",
    OpenapiWrite = "openapi:write",
    ConversationsIngest = "conversations:ingest"
}
/** Permissions that should be granted to the integration */
export type IntegrationScopes = IntegrationScope[];
export declare enum IntegrationCategory {
    Analytics = "analytics",
    Collaboration = "collaboration",
    Content = "content",
    Gitsync = "gitsync",
    Marketing = "marketing",
    VisitorAuth = "visitor-auth",
    Other = "other"
}
/** Categories for which the integration is listed in the marketplace */
export type IntegrationCategories = IntegrationCategory[];
/** Custom blocks defined by this integration. */
export type IntegrationBlocks = IntegrationBlock[];
/** ContentKit component for configuration */
export interface IntegrationConfigurationComponent {
    /** ID of the ContentKit component defined in the integration */
    componentId: string;
}
/** Definition of a content source provided by the integration. */
export interface IntegrationContentSource {
    /** Unique ID in the integration for the source. */
    id: string;
    /**
     * Short descriptive title for the source.
     * @minLength 2
     * @maxLength 40
     */
    title: string;
    /**
     * Long descriptive text for the source.
     * @minLength 0
     * @maxLength 150
     */
    description?: string;
    /** URL of the icon to represent this source. */
    icon?: string;
    /** ContentKit component for configuration */
    configuration: IntegrationConfigurationComponent;
}
/** Schema for a configuration */
export interface IntegrationConfigurationSchema {
    properties: Record<string, {
        /** @maxLength 30 */
        title?: string;
        /** @maxLength 100 */
        description?: string;
    } & ({
        type: 'string';
        default?: string;
        /** If specified, this URL will be called to fetch suggestions for auto-completing the property. */
        completion_url?: string;
        /** If specified, only values from this array are allowed as inputs. */
        enum?: string[];
    } | {
        type: 'number';
        default?: number;
    } | {
        type: 'boolean';
        default?: boolean;
    } | {
        type: 'button';
        callback_url: string;
        button_text: string;
    })>;
    /** @uniqueItems true */
    required?: string[];
}
export type IntegrationConfiguration = IntegrationConfigurationSchema | IntegrationConfigurationComponent;
export interface IntegrationConfigurations {
    account?: IntegrationConfiguration;
    space?: IntegrationConfiguration;
    site?: IntegrationConfiguration;
}
/**
 * External urls configured by the developer of the integration
 * @maxItems 5
 */
export type IntegrationExternalLinks = {
    url: URL;
    label: string;
}[];
/**
 * Security policy to validate the content of the integrations scripts and Contentkit. Will be sent as
 * headers when processing the script fetch event and the blocks fetch events.
 */
export type IntegrationContentSecurityPolicy = string | {
    'base-uri'?: string;
    'block-all-mixed-content'?: string;
    'child-src'?: string;
    'connect-src'?: string;
    'default-src'?: string;
    'font-src'?: string;
    'form-action'?: string;
    'frame-ancestors'?: string;
    'frame-src'?: string;
    'img-src'?: string;
    'manifest-src'?: string;
    'media-src'?: string;
    'navigate-to'?: string;
    'object-src'?: string;
    'plugin-types'?: string;
    'prefetch-src'?: string;
    referrer?: string;
    'report-to'?: string;
    'report-uri'?: string;
    'require-sri-for'?: string;
    'require-trusted-types-for'?: string;
    sandbox?: string;
    'script-src'?: string;
    'script-src-attr'?: string;
    'script-src-elem'?: string;
    'style-src'?: string;
    'style-src-attr'?: string;
    'style-src-elem'?: string;
    'trusted-types'?: string;
    'upgrade-insecure-requests'?: string;
    'worker-src'?: string;
};
export interface Integration {
    object: 'integration';
    /** Unique named identifier for the integration */
    name: string;
    /** Version of the integration */
    version: number;
    /** Title of the integration */
    title: IntegrationTitle;
    /** Description of the integration */
    description?: IntegrationDescription;
    /** Long form markdown summary of the integration */
    summary?: IntegrationSummary;
    /**
     * URLs of images to showcase the integration
     * @maxItems 3
     */
    previewImages: string[];
    /** The target on which the integration can operate and needs to be configured for */
    target: IntegrationTarget;
    /** If true, the integration has been verified by the GitBook team */
    verified: boolean;
    visibility: IntegrationVisibility;
    /** Permissions that should be granted to the integration */
    scopes: IntegrationScopes;
    /** Categories for which the integration is listed in the marketplace */
    categories: IntegrationCategories;
    /** Custom blocks defined by this integration. */
    blocks?: IntegrationBlocks;
    contentSources?: IntegrationContentSource[];
    configurations?: IntegrationConfigurations;
    /** External urls configured by the developer of the integration */
    externalLinks: IntegrationExternalLinks;
    owner: Organization;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the integration in the API
         * @format uri
         */
        location: string;
        /**
         * URL of the icon associated to the integration
         * @format uri
         */
        icon?: string;
        /**
         * URL of the integration in the application
         * @format uri
         */
        app: string;
        /**
         * URL of the integration's assets.
         * @format uri
         */
        assets: string;
        /**
         * Public HTTP endpoint for the integration
         * @format uri
         */
        publicEndpoint: string;
    };
    /** The set of permissions for the integration */
    permissions: {
        admin: boolean;
        /** Integration can be installed whatever the permissions of the user. */
        install: boolean;
    };
    /**
     * Security policy to validate the content of the integrations scripts and Contentkit. Will be sent as
     * headers when processing the script fetch event and the blocks fetch events.
     */
    contentSecurityPolicy?: IntegrationContentSecurityPolicy;
}
export type SpaceIntegrationBlocks = {
    /** Unique named identifier for the integration */
    name: string;
    blocks: IntegrationBlock[];
}[];
export interface SpaceIntegrationScript {
    /** Script URL to load. */
    script: URL;
    /** Content Security Policy to secure the loading of this script. */
    contentSecurityPolicy?: string;
    /** If true, the script will potentially load use cookies and visitors should be aware. */
    cookies: boolean;
}
/** Secrets stored on the integration and passed at runtime. */
export type IntegrationSecrets = Record<string, string>;
export interface PublishIntegration {
    /**
     * The runtime version to use for the integration. If not specified, the integration will use the default runtime.
     * @default "v1"
     */
    runtime?: 'v1' | 'v2';
    /**
     * Base64 content of the icon
     * @format byte
     */
    icon?: string;
    /** Title of the integration */
    title: IntegrationTitle;
    /** Description of the integration */
    description: IntegrationDescription;
    /** Long form markdown summary of the integration */
    summary?: IntegrationSummary;
    /** @maxItems 3 */
    previewImages?: string[];
    visibility?: IntegrationVisibility;
    /** Allowed installation target for the integration. If not specified, the integration can be installed at `all` targets (org, spaces etc) */
    target?: IntegrationTarget;
    /** Permissions that should be granted to the integration */
    scopes: IntegrationScopes;
    /** Categories for which the integration is listed in the marketplace */
    categories?: IntegrationCategories;
    /** Custom blocks defined by this integration. */
    blocks?: IntegrationBlocks;
    contentSources?: IntegrationContentSource[];
    /** External urls configured by the developer of the integration */
    externalLinks?: IntegrationExternalLinks;
    configurations?: IntegrationConfigurations;
    /** Content of the script to use */
    script: string;
    /** The ID or subdomain of the organization under which the integration should be published */
    organization: string;
    /** Secrets stored on the integration and passed at runtime. */
    secrets?: IntegrationSecrets;
    /**
     * Security policy to validate the content of the integrations scripts and Contentkit. Will be sent as
     * headers when processing the script fetch event and the blocks fetch events.
     */
    contentSecurityPolicy?: IntegrationContentSecurityPolicy;
}
export declare enum IntegrationInstallationStatus {
    Active = "active",
    Pending = "pending",
    Paused = "paused"
}
/** Describe whether all spaces have been selected or there's a selection involved */
export declare enum IntegrationInstallationSpaceSelection {
    All = "all",
    Selected = "selected"
}
/** Describe whether all sites have been selected or there's a selection involved */
export declare enum IntegrationInstallationSiteSelection {
    All = "all",
    Selected = "selected"
}
/** Configuration of the integration at the account level */
export type IntegrationInstallationConfiguration = Record<string, any>;
/**
 * External IDs assigned by the integration.
 * @maxItems 5
 */
export type IntegrationInstallationExternalIds = string[];
export interface OrganizationTarget {
    organization: string;
}
export type IntegrationInstallationTarget = OrganizationTarget;
/** Installation of an integration on an account */
export interface IntegrationInstallation {
    id: string;
    status: IntegrationInstallationStatus;
    /** Describe whether all spaces have been selected or there's a selection involved */
    space_selection: IntegrationInstallationSpaceSelection;
    /** Describe whether all sites have been selected or there's a selection involved */
    site_selection: IntegrationInstallationSiteSelection;
    /** Count of spaces, the installation is managing */
    spaces: number;
    /** Configuration of the integration at the account level */
    configuration: IntegrationInstallationConfiguration;
    createdAt: Timestamp;
    updatedAt: Timestamp;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the installation in the API
         * @format uri
         */
        location: string;
        /**
         * URL of the integration's installation in the application
         * @format uri
         */
        app: string;
        /**
         * Public HTTP endpoint for the integration's installation
         * @format uri
         */
        publicEndpoint: string;
    };
    /** External IDs assigned by the integration. */
    externalIds: IntegrationInstallationExternalIds;
    /** Target of the integration installation */
    target: IntegrationInstallationTarget;
}
/** Common properties for all events. */
export interface BaseEvent {
    /** Unique identifier for the event. */
    eventId: string;
    /** Type of the event. */
    type: string;
}
/** Common properties for all events related to an installation */
export type InstallationEvent = BaseEvent & {
    /** ID of the integration installation */
    installationId: string;
};
/** Event received when integration has been installed or updated. */
export type InstallationSetupEvent = InstallationEvent & {
    type: 'installation_setup';
    status: IntegrationInstallationStatus;
    /** The state of the installation at the account level before it was updated. */
    previous?: {
        status: IntegrationInstallationStatus;
        /** The previous configuration of the installation at the account level. */
        configuration?: object;
    };
};
/** Common properties for all events related to a specific space. */
export type SpaceEvent = InstallationEvent & {
    /** ID of the space */
    spaceId: string;
};
/** Event received when integration has been installed or updated on a space. */
export type SpaceInstallationSetupEvent = SpaceEvent & {
    type: 'space_installation_setup';
    status: IntegrationInstallationStatus;
    /** The state of the Space installation before it was updated. */
    previous?: {
        status: IntegrationInstallationStatus;
        /** The previous configuration of the Space installation. */
        configuration?: object;
    };
};
/** Event received when integration has been uninstalled from a space. */
export type SpaceInstallationDeletedEvent = SpaceEvent & {
    type: 'space_installation_deleted';
    /** The state of the Space installation before it was deleted. */
    previous: {
        /** The previous configuration of the Space installation. */
        configuration?: object;
    };
};
/** Common properties for all events related to a specific site. */
export type SiteEvent = InstallationEvent & {
    /** ID of the site */
    siteId: string;
};
/** Event received when integration has been installed or updated on a site. */
export type SiteInstallationSetupEvent = SiteEvent & {
    type: 'site_installation_setup';
    status: IntegrationInstallationStatus;
    /** The state of the site installation before it was updated. */
    previous?: {
        status: IntegrationInstallationStatus;
        /** The previous configuration of the site installation. */
        configuration?: object;
    };
};
/** Event received when integration has been uninstalled from a site. */
export type SiteInstallationDeletedEvent = SiteEvent & {
    type: 'site_installation_deleted';
    /** The state of the site installation before it was deleted. */
    previous: {
        /** The previous configuration of the site installation. */
        configuration?: object;
    };
};
/** Event received when a page has been visited. */
export type SpaceViewEvent = SpaceEvent & {
    type: 'space_view';
    /** Unique identifier of the visited page. */
    pageId?: string;
    /** Analytics info on the GitBook's content visitor. */
    visitor: {
        /** GitBook's unique identifier of the visitor. */
        anonymousId: string;
        /** The visitors cookies. */
        cookies: Record<string, string>;
        /** User-agent of the visitor. */
        userAgent: string;
        /** IP address of the visitor. */
        ip: string;
        /** Language of the visitor. */
        language?: string;
    };
    /** The GitBook content's URL visited (including URL params). */
    url: string;
    /** The URL of referrer that linked to the page. */
    referrer: string;
};
/** Event received when a page has been visited on a site. */
export type SiteViewEvent = SiteEvent & {
    type: 'site_view';
    /**
     * Unique identifier of the visited space in the site.
     * @deprecated
     */
    spaceId?: string;
    /** The site-space that was viewed */
    siteSpaceId?: string;
    /** Unique identifier of the visited page. */
    pageId?: string;
    /** Analytics info on the GitBook's content visitor. */
    visitor: {
        /** GitBook's unique identifier of the visitor. */
        anonymousId: string;
        /** The visitors cookies. */
        cookies: Record<string, string>;
        /** User-agent of the visitor. */
        userAgent: string;
        /** IP address of the visitor. */
        ip: string;
        /** Language of the visitor. */
        language?: string;
    };
    /** The GitBook content's URL visited (including URL params). */
    url: string;
    /** The URL of referrer that linked to the page. */
    referrer: string;
};
/** Event when the primary content of a space has been updated. */
export type SpaceContentUpdatedEvent = SpaceEvent & {
    type: 'space_content_updated';
    /** Unique identifier of the new content revision */
    revisionId: string;
};
/** Event when a GitSync operation has been completed. */
export type SpaceGitSyncCompletedEvent = SpaceEvent & {
    type: 'space_gitsync_completed';
    state: 'success' | 'failure';
    /** Unique identifier of the new content revision */
    revisionId: string;
    /** Unique identifier for the commit (sha) */
    commitId: string;
};
/** Event when a GitSync operation has been started. */
export type SpaceGitSyncStartedEvent = SpaceEvent & {
    type: 'space_gitsync_started';
    /** Unique identifier of the new content revision */
    revisionId: string;
    /** Unique identifier for the commit (sha) */
    commitId: string;
};
/** Event when the visibility of the space has been changed. */
export type SpaceVisibilityUpdatedEvent = SpaceEvent & {
    type: 'space_visibility_updated';
    /**
     * * `public`: Anyone can access the content, and the content is indexed by search engines.
     * * `unlisted`: Anyone can access the content, and the content is not indexed by search engines
     * * `share-link`: Anyone with a secret token in the url can access the content.
     * * `visitor-auth`: Anyone authenticated through a JWT token can access the content.
     * * `in-collection`: Anyone who can access the parent collection can access the content.
     *   Only available for spaces in a collection.
     * * `private`: Authorized members can access the content.
     */
    previousVisibility: ContentVisibility;
    /**
     * * `public`: Anyone can access the content, and the content is indexed by search engines.
     * * `unlisted`: Anyone can access the content, and the content is not indexed by search engines
     * * `share-link`: Anyone with a secret token in the url can access the content.
     * * `visitor-auth`: Anyone authenticated through a JWT token can access the content.
     * * `in-collection`: Anyone who can access the parent collection can access the content.
     *   Only available for spaces in a collection.
     * * `private`: Authorized members can access the content.
     */
    visibility: ContentVisibility;
};
export interface FetchRequest {
    method: 'post' | 'get' | 'put' | 'delete';
    url: string;
    headers: Record<string, string>;
}
/** Event representing an incoming HTTP request. */
export type FetchEvent = BaseEvent & {
    /** The space ID, if requests are specific to a single space */
    spaceId?: string;
    /** The site ID, if requests are specific to a single site */
    siteId?: string;
    /** The installation ID, if requests are specific to a single installation */
    installationId?: string;
    auth?: {
        /** The user's ID. */
        userId: string;
    };
    type: 'fetch';
    request: FetchRequest;
};
/** Common properties for all events related to fetching a published script from an installation */
export type FetchPublishedScriptEvent = (SpaceEvent | SiteEvent) & {
    type: 'fetch_published_script';
};
/** Common properties for all events related to authenticated access from an installation */
export type FetchVisitorAuthenticationEvent = (SpaceEvent | SiteEvent) & {
    type: 'fetch_visitor_authentication';
    location?: string;
};
/** Common properties for ContentKit context. */
export interface ContentKitContextBase {
    theme: 'dark' | 'light';
}
/** Context while rendering in an account installation's configuration. */
export type ContentKitContextConfigurationAccount = ContentKitContextBase & {
    type: 'configuration_account';
    /** ID of the organization the account installation configuration is in. */
    organizationId: string;
};
/** Context while rendering in a space-installation's configuration. */
export type ContentKitContextConfigurationSpace = ContentKitContextBase & {
    type: 'configuration_space';
    /** ID of the space the space-installation configuration is in. */
    spaceId: string;
};
/** Context while rendering in a site-installation's configuration. */
export type ContentKitContextConfigurationSite = ContentKitContextBase & {
    type: 'configuration_site';
    /** ID of the site the site-installation configuration is in. */
    siteId: string;
};
/** Context while rendering the configuration flow of a content source. */
export type ContentKitContextConfigurationContentSource = ContentKitContextBase & {
    type: 'configuration_contentsource';
    /** ID of the organization the content source installation configuration is in. */
    organizationId: string;
    /** Optional ID of the space the content source installation configuration is in. */
    spaceId?: string;
};
/** Context while rendering in a document. */
export type ContentKitContextDocument = ContentKitContextBase & {
    type: 'document';
    /** ID of the space content the document is in. */
    spaceId: string;
    editable: boolean;
};
/** Object representing the context in which a ContentKit component is rendered. */
export type ContentKitContext = ContentKitContextConfigurationAccount | ContentKitContextConfigurationSpace | ContentKitContextConfigurationSite | ContentKitContextConfigurationContentSource | ContentKitContextDocument;
/** Event generated when rendering a UI */
export type UIRenderEvent = (SpaceEvent | SiteEvent | InstallationEvent) & {
    auth?: {
        /** The user's ID. */
        userId: string;
    };
    type: 'ui_render';
    componentId: string;
    /** Properties to render the UI. */
    props: object;
    /** State of the UI. */
    state?: object;
    /** Object representing the context in which a ContentKit component is rendered. */
    context: ContentKitContext;
    action?: object;
};
/** Generic event when computing the content of a space */
export type ContentComputeEvent = SpaceEvent & {
    sourceId: string;
    /** Properties passed to the rendering. */
    props: PlainObject;
    /** Dependencies of the computation. */
    dependencies: Record<string, ComputedContentDependencyResolved>;
};
/**
 * Event generated when computing the document of a pages.
 * The integration should respond with a `Document`.
 */
export type ContentComputeDocumentEvent = ContentComputeEvent & {
    type: 'content_compute_document';
};
/**
 * Event generated when computing revision in a content.
 * The integration should respond with an array of pages and files.
 */
export type ContentComputeRevisionEvent = ContentComputeEvent & {
    type: 'content_compute_revision';
};
/** Any event that can be received from GitBook. */
export type Event = InstallationSetupEvent | SpaceInstallationSetupEvent | SpaceInstallationDeletedEvent | SiteInstallationSetupEvent | SiteInstallationDeletedEvent | SpaceViewEvent | SiteViewEvent | SpaceContentUpdatedEvent | SpaceGitSyncCompletedEvent | SpaceGitSyncStartedEvent | SpaceVisibilityUpdatedEvent | FetchEvent | FetchPublishedScriptEvent | FetchVisitorAuthenticationEvent | UIRenderEvent | ContentComputeDocumentEvent | ContentComputeRevisionEvent;
export interface IntegrationEvent {
    /** Unique ID of the event. */
    id: string;
    /** Unique ID of the integration. */
    integrationId: string;
    /** Unique ID of the integration installation. */
    installationId?: string;
    createdAt: Timestamp;
    /** Any event that can be received from GitBook. */
    payload: Event;
    /** Status of the event. */
    status: 'success' | 'failed';
}
export interface IntegrationEventLog {
    /** The message of the log entry. */
    message?: string;
    timestamp?: Timestamp;
    /** The level of the log entry. */
    level?: 'debug' | 'info' | 'warn' | 'error';
}
export interface IntegrationEventTrace {
    logs: IntegrationEventLog[];
}
/** Base properties of an installation of an integration on a site or space. */
export interface IntegrationContentInstallationBase {
    /** Unique name identifier of the integration */
    integration: string;
    /** ID of the integration installation */
    installation: string;
    status: IntegrationInstallationStatus;
    /** Configuration of the integration for this site */
    configuration: object;
    /** External IDs assigned by the integration. */
    externalIds: IntegrationInstallationExternalIds;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the integration's installation in the API
         * @format uri
         */
        location: string;
        /**
         * Public HTTP endpoint for the integration's installation
         * @format uri
         */
        publicEndpoint: string;
    };
}
export type IntegrationSpaceInstallation = IntegrationContentInstallationBase & {
    /** The space the integration is installed on. Using the string value is deprecated in favor of space.id */
    space: string | Space;
};
/** The type of the site */
export declare enum SiteType {
    Basic = "basic",
    Premium = "premium",
    Ultimate = "ultimate",
    Sponsored = "sponsored",
    LegacyBasic = "legacy-basic",
    LegacyPremium = "legacy-premium"
}
/**
 * Title of the site
 * @minLength 2
 * @maxLength 128
 */
export type SiteTitle = string;
export interface CustomizationThemedURL {
    light: URL;
    dark: URL;
}
export type CustomizationFavicon = {
    icon: CustomizationThemedURL;
} | {
    /** Unicode codepoint or character of the emoji */
    emoji: Emoji;
} | object;
/**
 * Custom hostname for the site, for e.g. docs.mycompany.com
 * @maxLength 512
 * @pattern ^([a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?[.]){2,}[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$
 */
export type SiteHostname = string;
/**
 * Basename for the site. For e.g. api
 * @minLength 1
 * @maxLength 100
 */
export type SiteBasename = string;
/**
 * Proxy URL for the site, for e.g. company.com/docs or www.company.com/developer/docs etc.
 * @maxLength 512
 * @pattern ^([\w-]+\.)*[\w-]+\.[a-zA-Z]{2,}(\/[\w-]+)+$
 */
export type SiteProxyOrigin = string;
export interface SiteProxy {
    /** Proxy URL for the site, for e.g. company.com/docs or www.company.com/developer/docs etc. */
    origin: SiteProxyOrigin;
    /** The target URL to which the requests at the origin URL should be proxied to. */
    target: string;
}
/**
 * The visibility setting of the site determines the audience of the site.
 * * `public`: Anyone can access the site, and the site is indexed by search engines.
 * * `unlisted`: Anyone can access the site, and the site is not indexed by search engines
 * * `share-link`: Anyone with a secret token in the url can access the site.
 * * `visitor-auth`: Anyone authenticated through a JWT token can access the site.
 */
export declare enum SiteVisibility {
    Public = "public",
    Unlisted = "unlisted",
    ShareLink = "share-link",
    VisitorAuth = "visitor-auth"
}
export interface SiteAdaptiveContent {
    /** Whether adaptive content should be enabled on the site. */
    enabled: boolean;
}
/** Topic of the content */
export declare enum SiteAdsTopic {
    Webdev = "webdev",
    Crypto = "crypto"
}
export type SiteAds = {
    status: 'pending';
    /** True if the user can submit the site for review. */
    submittable: boolean;
} | {
    status: 'in-review';
    /** Topic of the content */
    topic: SiteAdsTopic;
} | {
    status: 'rejected';
    /** Reason for the rejection */
    reason?: string;
} | {
    status: 'live' | 'disabled';
    /** Topic of the content */
    topic: SiteAdsTopic;
    /** The ad network zone ID */
    zoneId: string;
};
/**
 * Defines if the site will be included in the agent's context.
 * - `excluded` means that the agent will not be able to access the site.
 * - `included` means that the agent will be able to access the site.
 */
export declare enum SiteAgentsContext {
    Excluded = "excluded",
    Included = "included"
}
/** The site feature identifier */
export declare enum SiteFeatureKey {
    SitesAdaptiveContent = "sites-adaptive-content",
    SitesAdvancedCustomization = "sites-advanced-customization",
    SitesAdvancedInsights = "sites-advanced-insights",
    SitesAds = "sites-ads",
    SitesAiSearch = "sites-ai-search",
    SitesApiPlayground = "sites-api-playground",
    SitesBasicCustomization = "sites-basic-customization",
    SitesCustomDomain = "sites-custom-domain",
    SitesCustomFonts = "sites-custom-fonts",
    SitesCustomSubdirectory = "sites-custom-subdirectory",
    SitesFullTextSearch = "sites-full-text-search",
    SitesMultivariantSite = "sites-multivariant-site",
    SitesNoCustomDomain = "sites-no-custom-domain",
    SitesPageFeedback = "sites-page-feedback",
    SitesPageTrafficInsights = "sites-page-traffic-insights",
    SitesPdfExport = "sites-pdf-export",
    SitesPreviewDeployments = "sites-preview-deployments",
    SitesPublicVisibility = "sites-public-visibility",
    SitesRedirects = "sites-redirects",
    SitesSearchInsights = "sites-search-insights",
    SitesSections = "sites-sections",
    SitesSeo = "sites-seo",
    SitesShareLinks = "sites-share-links",
    SitesUnlistedVisibility = "sites-unlisted-visibility",
    SitesUserContribution = "sites-user-contribution",
    SitesVisitorAuthentication = "sites-visitor-authentication",
    SitesVisitors = "sites-visitors"
}
/** A list of all premium customizations. */
export declare enum SiteCustomizationFeature {
    HeaderLogo = "header-logo",
    ThemePreset = "theme-preset",
    PremiumFonts = "premium-fonts",
    CustomIcons = "custom-icons",
    FooterLogo = "footer-logo",
    FooterLinks = "footer-links",
    FooterCopyright = "footer-copyright",
    SemanticColors = "semantic-colors"
}
/** A site feature and the plan it is available on. */
export interface SiteFeature {
    /** The site feature identifier */
    id: SiteFeatureKey;
    /** The type of the site */
    plan: SiteType;
    /** A frozen feature is still enabled but cannot be changed or modified. */
    frozen: boolean;
    /** A list of the actual advanced customizations used (only applicable for sites-advanced-customization) */
    customizations?: SiteCustomizationFeature[];
}
export interface Site {
    object: 'site';
    /** Unique identifier of the site */
    id: string;
    /** The type of the site */
    type: SiteType;
    /** Title of the site */
    title: SiteTitle;
    icon?: CustomizationFavicon | null;
    /** Custom hostname for the site, for e.g. docs.mycompany.com */
    hostname?: SiteHostname;
    /** Basename for the site. For e.g. api */
    basename?: SiteBasename;
    proxy?: SiteProxy;
    /**
     * The visibility setting of the site determines the audience of the site.
     * * `public`: Anyone can access the site, and the site is indexed by search engines.
     * * `unlisted`: Anyone can access the site, and the site is not indexed by search engines
     * * `share-link`: Anyone with a secret token in the url can access the site.
     * * `visitor-auth`: Anyone authenticated through a JWT token can access the site.
     */
    visibility: SiteVisibility;
    /** Whether the site is live or not. If true, the site is accessible to the audience defined by the visibility setting. */
    published: boolean;
    siteSpaces: number;
    /** @format date-time */
    createdAt: string;
    adaptiveContent?: SiteAdaptiveContent;
    ads?: SiteAds;
    /**
     * Defines if the site will be included in the agent's context.
     * - `excluded` means that the agent will not be able to access the site.
     * - `included` means that the agent will be able to access the site.
     */
    agentsContext: SiteAgentsContext;
    /** A list of all premium features enabled on this site. For each feature we list the plan they belong to and whether the feature is frozen. A frozen feature is still enabled but cannot be changed or modified. */
    features: SiteFeature[];
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the site in the API
         * @format uri
         */
        location: string;
        /**
         * URL of the site in the application
         * @format uri
         */
        app: string;
        /**
         * URL of the published version of the site. Only defined when site is published.
         * @format uri
         */
        published?: string;
    };
}
export type IntegrationSiteInstallation = IntegrationContentInstallationBase & {
    /** The site the integration is installed on. Using the string value is deprecated in favor of site.id */
    site: string | Site;
};
export declare enum ContentKitIcon {
    Close = "close",
    Edit = "edit",
    Github = "github",
    Gitlab = "gitlab",
    Maximize = "maximize",
    Email = "email",
    Settings = "settings",
    Search = "search",
    Delete = "delete",
    Star = "star",
    Warning = "warning",
    Link = "link",
    LinkExternal = "link-external",
    Eye = "eye",
    EyeOff = "eye-off",
    Lock = "lock",
    Check = "check",
    CheckCircle = "check-circle"
}
/** A confirm object that defines an optional confirmation dialog after the input is clicked. */
export interface ContentKitConfirm {
    /**
     * A text value that defines the dialog's title.
     * @maxLength 100
     */
    title: string;
    /**
     * A text value that defines the explanatory text that appears in the confirm dialog.
     * @maxLength 300
     */
    text: string;
    /**
     * A text value to define the text of the button that confirms the action.
     * @maxLength 30
     */
    confirm: string;
    style?: 'primary' | 'danger';
}
/** Pressable button triggering an action. */
export interface ContentKitButton {
    type: 'button';
    style?: 'primary' | 'secondary' | 'danger';
    /** Custom action to re-render the block. */
    onPress: ContentKitAction;
    icon?: ContentKitIcon;
    trailingIcon?: ContentKitIcon;
    label?: string;
    tooltip?: string;
    /** A confirm object that defines an optional confirmation dialog after the input is clicked. */
    confirm?: ContentKitConfirm;
    disabled?: boolean;
}
/** Text input to prompt the user. */
export interface ContentKitTextInput {
    type: 'textinput';
    disabled?: boolean;
    /** State binding. The value of the input will be stored as a property in the state named after this ID. */
    state: string;
    /** Text value to initialize the input with. */
    initialValue?: string;
    /** Text that appears in the form control when it has no value set */
    placeholder?: string;
    multiline?: boolean;
    /** @default "text" */
    inputType?: 'text' | 'password' | 'email';
}
/** Any element that can be used as children. */
export type ContentKitDescendantElement = ContentKitButton | ContentKitTextInput | ContentKitHStack | ContentKitVStack | ContentKitBox | ContentKitDivider | ContentKitWebFrame | ContentKitCodeBlock | ContentKitMarkdown | ContentKitCard | ContentKitImage | ContentKitInput | ContentKitSelect | ContentKitSwitch | ContentKitCheckbox | ContentKitRadio | ContentKitText | ContentKitHint | ContentKitLink | ContentKitStepperStep;
/** Horizontal stack of boxes. */
export interface ContentKitHStack {
    type: 'hstack';
    /** @default "start" */
    align?: 'start' | 'center' | 'end';
    children: ContentKitDescendantElement[];
}
/** Vertical stack of boxes. */
export interface ContentKitVStack {
    type: 'vstack';
    /** @default "start" */
    align?: 'start' | 'center' | 'end';
    children: ContentKitDescendantElement[];
}
export interface ContentKitBox {
    type: 'box';
    /** specifies how much of the remaining space in the container should be assigned to the element */
    grow?: number;
    children: ContentKitDescendantElement[];
}
/** Divider between 2 boxes in a stack. */
export interface ContentKitDivider {
    type: 'divider';
    size?: 'small' | 'medium' | 'large';
}
/** Binding between a property and a state value. */
export interface ContentKitDynamicBinding {
    /** Key in the state */
    $state: string;
}
/** Frame for a webpage */
export interface ContentKitWebFrame {
    type: 'webframe';
    /** Ratio between width and height. Used to size the webframe. */
    aspectRatio?: number;
    /** Content to load in the frame. */
    source: {
        url: string;
    };
    /** Controls button shown as an overlay in a corner of the frame. */
    buttons?: ContentKitButton[];
    /** Data to communicated to the webframe's content. Each state update will cause the webframe to receive a message. */
    data?: Record<string, string | ContentKitDynamicBinding>;
}
/** Code block with syntax highlighting */
export interface ContentKitCodeBlock {
    type: 'codeblock';
    /** Code content to display */
    content: ContentKitDynamicBinding | string;
    /** Syntax to use for highlighting (ex: javascript, python) */
    syntax?: string;
    /** Line number to start at. */
    lineNumbers?: boolean | number;
    /** Controls button shown as an overlay in a corner of the code block. */
    buttons?: ContentKitButton[];
    /** State binding when editable. The value of the input will be stored as a property in the state named after this ID. */
    state?: string;
    /** Custom action to re-render the block. */
    onContentChange?: ContentKitAction;
    /** Header displayed before the code lines */
    header?: ContentKitDescendantElement[];
    /** Footer displayed after the code lines */
    footer?: ContentKitDescendantElement[];
}
/** Block with rich text formatting of a markdown content. */
export interface ContentKitMarkdown {
    type: 'markdown';
    /** Markdown content to display */
    content: ContentKitDynamicBinding | string;
}
/** Low level text element. */
export interface ContentKitText {
    type: 'text';
    style?: 'bold' | 'italic' | 'code' | 'strikethrough';
    children: string | (string | ContentKitText | ContentKitLink)[];
}
/** Specification for an URL in ContentKit. */
export interface ContentKitURL {
    /**
     * Hostname of the URL along with the port number if required.
     * @example "api.example.com"
     */
    host: string;
    /**
     * Path of the URL prefixed with a `/`.
     * @example "/v1/options"
     */
    pathname: string;
    query?: Record<string, string | ContentKitDynamicBinding>;
}
export interface ContentKitLink {
    type: 'link';
    target: {
        url: string | ContentKitURL;
    };
    children: string | string[];
}
export interface ContentKitImage {
    type: 'image';
    source: {
        /** @format uri */
        url: string;
    };
    aspectRatio: number;
}
/** Any element that is inline. */
export type ContentKitInlineElement = ContentKitText | ContentKitImage | ContentKitLink;
export interface ContentKitCard {
    type: 'card';
    title?: string;
    hint?: string | ContentKitInlineElement[];
    icon?: ContentKitIcon | ContentKitImage;
    /** Custom action to re-render the block. */
    onPress?: ContentKitAction;
    children?: ContentKitDescendantElement[];
    /** Buttons displayed in the top right corner of the card. */
    buttons?: ContentKitButton[];
}
/** Built-in sources that can be used to provide a ContentKitSelect. */
export interface ContentKitBuiltInSource {
    source: 'openapi';
}
/** An individual option in a select element */
export interface ContentKitSelectOption {
    id: string;
    label: string;
    icon?: ContentKitIcon | ContentKitImage;
}
/** Creates a drop down menu with a list of options for a user to choose. */
export interface ContentKitSelect {
    type: 'select';
    disabled?: boolean;
    /** State binding. The value of the input will be stored as a property in the state named after this ID. */
    state: string;
    /** Value to initialize the select with. */
    initialValue?: string | string[];
    /** Custom action to re-render the block. */
    onValueChange?: ContentKitAction;
    /** Text that appears in the form control when it has no value set */
    placeholder?: string;
    /** Should the select accept the selection of multiple options. If true, the state will be an array. */
    multiple?: boolean;
    /** Should the filter input be allowed to be selected as an option. */
    acceptInput?: boolean;
    /** Options to be displayed in the select. */
    options: ContentKitBuiltInSource | ContentKitSelectOption[] | {
        /** External source of options. The URL should respond with an array of options. */
        url: string | ContentKitURL;
    };
}
/** Renders a boolean input. */
export interface ContentKitSwitch {
    type: 'switch';
    disabled?: boolean;
    /** State binding. The value of the input will be stored as a property in the state named after this ID. */
    state: string;
    /** Value to initialize the switch with. */
    initialValue?: boolean;
    /** Custom action to re-render the block. */
    onValueChange?: ContentKitAction;
    /** A confirm object that defines an optional confirmation dialog after the input is clicked. */
    confirm?: ContentKitConfirm;
}
export interface ContentKitRadio {
    type: 'radio';
    disabled?: boolean;
    /** State binding. The value of the input will be stored as a property in the state named after this ID. */
    state: string;
    /** Value to store in th state when the checkbox is selected. */
    value: string | number;
    /** A confirm object that defines an optional confirmation dialog after the input is clicked. */
    confirm?: ContentKitConfirm;
}
export interface ContentKitCheckbox {
    type: 'checkbox';
    /** State binding. The value of the input will be stored as a property in the state named after this ID. */
    state: string;
    /** Value to store in a state array when the checkbox is selected. */
    value: string | number;
    /** A confirm object that defines an optional confirmation dialog after the input is clicked. */
    confirm?: ContentKitConfirm;
}
/** Field for an input. */
export interface ContentKitInput {
    type: 'input';
    /** Text label displayed next to the input. */
    label: string;
    hint?: string | ContentKitInlineElement;
    element: ContentKitTextInput | ContentKitSelect | ContentKitSwitch | ContentKitRadio | ContentKitCheckbox | ContentKitButton | ContentKitCodeBlock;
}
/** Element used to contextualize other elements or info. */
export interface ContentKitHint {
    type: 'hint';
    children: ContentKitInlineElement[];
}
export interface ContentKitStepperStep {
    type: 'step';
    /** unique identifier for the step */
    id: string;
    /**
     * title of the step
     * @maxLength 50
     */
    title?: string;
    /**
     * indicates if the user can progress to the next step based on some internal validation or condition
     * @default false
     */
    next?: boolean;
    /** @minItems 1 */
    children: ContentKitDescendantElement[];
}
/** Control menu item displayed for the block. */
export interface ContentKitBlockControl {
    icon?: ContentKitIcon;
    label: string;
    /** Custom action to re-render the block. */
    onPress: ContentKitAction;
    /** A confirm object that defines an optional confirmation dialog after the input is clicked. */
    confirm?: ContentKitConfirm;
}
/** Higher level element to represent a custom block. */
export interface ContentKitBlock {
    type: 'block';
    children: ContentKitDescendantElement[];
    controls?: (ContentKitBlockControl | ContentKitBlockControl[])[];
}
/** Overlay modal. */
export interface ContentKitModal {
    type: 'modal';
    title?: string;
    subtitle?: ContentKitInlineElement[];
    size?: 'medium' | 'xlarge' | 'fullscreen';
    /** Data passed back to the parent view when the modal is closed. These data are accessible in the "@ui.modal.close" */
    returnValue?: object;
    children: ContentKitDescendantElement[];
    /** Pressable button triggering an action. */
    submit?: ContentKitButton;
}
export interface ContentKitStepper {
    type: 'stepper';
    /** id of the currently active step */
    activeStep: string;
    /** Custom action to re-render the block. */
    onStepChange: ContentKitAction;
    /** Custom action to re-render the block. */
    onComplete: ContentKitAction;
    /** @minItems 1 */
    children: ContentKitStepperStep[];
}
/** Higher level element to define a configuration block. Does not add any UI elements or wrappers. Must be used as a top level element for any configuration component. */
export interface ContentKitConfiguration {
    type: 'configuration';
    children: ContentKitStepper[] | ContentKitDescendantElement[];
}
/** Element used as root */
export type ContentKitRootElement = ContentKitBlock | ContentKitModal | ContentKitConfiguration;
/** Output of type element in the lifecycle of the component. */
export interface ContentKitRenderOutputElement {
    type?: 'element';
    /** Element used as root */
    element: ContentKitRootElement;
    state: object;
    props: PlainObject;
}
/** Output of completed lifecycle of the component. */
export interface ContentKitRenderOutputComplete {
    type: 'complete';
    returnValue?: object;
}
/** Output of the integration when rendering a UI. */
export type ContentKitRenderOutput = ContentKitRenderOutputElement | ContentKitRenderOutputComplete;
export interface RenderIntegrationUI {
    /** ID of the component to render in the integration. */
    componentId: string;
    /** Current properties of the UI. */
    props: PlainObject;
    /** Current local state of the UI. */
    state?: object;
    /** Object representing the context in which a ContentKit component is rendered. */
    context: ContentKitContext;
    /** Custom action to re-render the block. */
    action?: ContentKitAction;
}
export interface UpdateIntegrationInstallation {
    /** External IDs assigned by the integration. */
    externalIds?: IntegrationInstallationExternalIds;
    /** Configuration of the integration at the account level */
    configuration?: IntegrationInstallationConfiguration;
    /** Describe whether all spaces have been selected or there's a selection involved */
    space_selection?: IntegrationInstallationSpaceSelection;
    /** Describe whether all sites have been selected or there's a selection involved */
    site_selection?: IntegrationInstallationSiteSelection;
}
export interface APITemporaryToken {
    /** Temporary access token to authenticate with the API */
    token: string;
}
export interface UpdateIntegrationSpaceInstallation {
    /** External IDs assigned by the integration. */
    externalIds?: IntegrationInstallationExternalIds;
    /** Configuration of the integration at the account level */
    configuration?: IntegrationInstallationConfiguration;
}
export interface UpdateIntegrationSiteInstallation {
    /** External IDs assigned by the integration. */
    externalIds?: IntegrationInstallationExternalIds;
    /** Configuration of the integration at the account level */
    configuration?: IntegrationInstallationConfiguration;
}
export interface CreateOrganization {
    /** Name of the organization */
    title: OrganizationTitle;
    emailDomains?: OrganizationEmailDomains;
    type?: OrganizationType;
    useCase?: OrganizationUseCase;
}
/**
 * Title of the site section
 * @minLength 2
 * @maxLength 128
 */
export type SiteSectionTitle = string;
/**
 * Description of the site section
 * @minLength 0
 * @maxLength 256
 */
export type SiteSectionDescription = string;
/**
 * Path to the section on the site
 * @minLength 1
 * @maxLength 100
 */
export type SiteSectionPath = string;
/**
 * @minLength 1
 * @maxLength 1024
 */
export type Condition = string;
/**
 * Path to the space on the site
 * @minLength 1
 * @maxLength 100
 */
export type SiteSpacePath = string;
export interface SiteSpace {
    /** The object type, which is always "site-space" */
    object: 'site-space';
    /** Unique identifier of the site-space */
    id: string;
    /** Path to the space on the site */
    path: SiteSpacePath;
    /** ID of the section the space belongs to in the site */
    section?: string;
    space: Space;
    title: string;
    /** Whether this is the default space for the site */
    default?: boolean;
    /** Conditional expression used to evaluate whether the site space should be shown to the site's visitor. */
    condition?: Condition;
    /** Whether the space has advanced customization feature enabled */
    hasAdvancedCustomizationFeature?: boolean;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the published version of the site-space. Only defined when site is published.
         * @format uri
         */
        published?: string;
    };
}
export interface SiteSection {
    /** The object type, which is always "site-section" */
    object: 'site-section';
    /** Unique identifier of the site section */
    id: string;
    /** Title of the site section */
    title: SiteSectionTitle;
    /** Description of the site section */
    description?: SiteSectionDescription;
    /** Whether this is the default section for the site */
    default?: boolean;
    /** Path to the section on the site */
    path: SiteSectionPath;
    /** Conditional expression used to evaluate whether the site section should be shown to the site's visitor. */
    condition?: Condition;
    /** ID of the section group the section belongs to in the site */
    sectionGroup?: string;
    siteSpaces: SiteSpace[];
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the published version of the site section. Only defined when site is published.
         * @format uri
         */
        published?: string;
    };
    /** Name of the icon */
    icon?: Icon;
}
/**
 * Title of the site section group
 * @minLength 1
 * @maxLength 100
 */
export type SiteSectionGroupTitle = string;
export interface SiteSectionGroup {
    /** The object type, which is always "site-section-group" */
    object: 'site-section-group';
    /** Unique identifier of the site section group */
    id: string;
    /** Title of the site section group */
    title: SiteSectionGroupTitle;
    /** List of site section ids that are members of the group */
    sections: SiteSection[];
    /** Name of the icon */
    icon?: Icon;
}
export type SiteStructure = {
    type: 'sections';
    structure: (SiteSection | SiteSectionGroup)[];
} | {
    type: 'siteSpaces';
    structure: SiteSpace[];
};
export interface OrganizationAllSite {
    site: Site;
    structure: SiteStructure;
}
export interface OrganizationAllCollection {
    collection: Collection;
    content: (OrganizationAllCollection | OrganizationAllSpace)[];
}
export interface OrganizationAllSpace {
    space: Space;
}
export interface OrganizationAllContent {
    sites: OrganizationAllSite[];
    spaces: (OrganizationAllCollection | OrganizationAllSpace)[];
    /** List of soft-deleted spaces. */
    deletedSpaces: OrganizationAllSpace[];
}
/** Permission of a member in a content. */
export interface MemberContentPermission {
    /**
     * "The role of a member in an organization.
     * "admin": Can administrate the content: create, delete spaces, ...
     * "create": Can create content.
     * "review": Can review content.
     * "edit": Can edit the content (live or change requests).
     * "comment": Can access the content and its discussions.
     * "read": Can access the content, but cannot update it in any way.
     */
    permission: MemberRole;
    space: Space;
}
/**
 * "The role of a team member.
 * "owner": Can manage team members.
 * "member": Is a member of the team.
 */
export declare enum TeamMemberRole {
    Owner = "owner",
    Member = "member"
}
export interface TeamMember {
    /**
     * "The role of a team member.
     * "owner": Can manage team members.
     * "member": Is a member of the team.
     */
    role: TeamMemberRole;
}
/** A member of a team in an organization, including its relationship to it */
export interface OrganizationTeamMember {
    /** User information as an organization member */
    organization: OrganizationMember;
    /** User information as a team member */
    team: TeamMember;
    /** The set of permissions for the team member */
    permissions: {
        /** Can the user view the team member */
        view: boolean;
    };
}
export interface UpdateMembersInOrganizationTeam {
    add?: string[];
    memberships?: Record<string, TeamMember>;
    remove?: string[];
}
export interface InviteUsersToOrganization {
    emails: (string | {
        /** The email address of the user to invite as a member */
        email: string;
        /** The role of a member in an organization, null for guests */
        role: MemberRoleOrGuest;
    })[];
    /** Default role to set on newly invited members. */
    role?: MemberRoleOrGuest;
    /** If true, invites the user as an SSO user of the organization. Defaults to false. */
    sso?: boolean;
}
/** An invite link to a specific collection in an organization */
export interface InviteLinkToCollection {
    /** Type of Object, always equals to "invite" */
    object: 'invite';
    /** Unique identifier for the invite link to the collection */
    id: string;
    /** The level of the member in the target collection */
    level: MemberRoleOrGuest;
    /** An invite is redundant if the requesting user already has all necessary permissions. */
    redundant: boolean;
    /** The collection the member has been invited to */
    collection: Collection;
}
/** An invite link to a specific space in an organization */
export interface InviteLinkToSpace {
    /** Type of Object, always equals to "invite" */
    object: 'invite';
    /** Unique identifier for the invite link to the space */
    id: string;
    /** The level of the member in the target space */
    level: MemberRoleOrGuest;
    /** An invite is redundant if the requesting user already has all necessary permissions. */
    redundant: boolean;
    /** The space the member has been invited to */
    space: Space;
}
/** An invite link to an organization */
export interface InviteLinkToOrganization {
    /** Type of Object, always equals to "invite" */
    object: 'invite';
    /** Unique identifier for the invite link to the organization */
    id: string;
    /** The role in the organization the invite link is for */
    role: MemberRoleOrGuest;
    /** An invite is redundant if the requesting user already has all necessary permissions. */
    redundant: boolean;
}
export interface CreateInviteToOrganization {
    /** The role of the member in the organization */
    role: MemberRoleOrGuest;
}
export interface CreateInviteToSpace {
    /** The level of the member in the target space */
    level: MemberRoleOrGuest;
    /** The ID of space the member has been invited to */
    space: string;
}
export interface CreateInviteToCollection {
    /** The level of the member in the target collection */
    level: MemberRoleOrGuest;
    /** The ID of collection the member has been invited to */
    collection: string;
}
export type CreateOrganizationInvite = CreateInviteToOrganization | CreateInviteToSpace | CreateInviteToCollection;
/** An invite link created in an organization */
export type OrganizationInviteLink = InviteLinkToOrganization | InviteLinkToSpace | InviteLinkToCollection;
/** Changes to apply during a subscription upgrade or downgrade */
export interface SubscriptionChanges {
    /** A list of member identifiers to be removed */
    removeMembers: string[];
    /** A list of site updates to be applied before upgrading.  If a site is not present in this list, it'll be upgraded to whichever type matches its features and its published status will be unchanged. When downgrading to a lower type all relevant paid features will be disabled before applying the new type. */
    updateSites: ({
        /** The site identifier */
        id: string;
        /** The site type to migrate to */
        type: SiteType;
    } | {
        /** The site identifier */
        id: string;
        /** Can be set to `false` to unpublish a site */
        isPublished: false;
    })[];
}
export interface UpgradeOrganizationBilling {
    /** Name of the product */
    product: BillingProduct;
    /** Interval for a billing subscription */
    interval: BillingInterval;
    /** Changes to apply during a subscription upgrade or downgrade */
    changes?: SubscriptionChanges;
    /**
     * Deprecated. Use `changes` instead.
     * @deprecated
     */
    exclude?: {
        /** A list of member identifiers to be removed, `all` to remove all members but the current admin */
        members?: string[] | 'all';
        /** A list of site identifiers to be unpublished, 'all' to unpublish all sites */
        sites?: string[] | 'all';
    };
    /** Reason that triggered the billing upgrade */
    reason?: string;
    /** Mode to use for the upgrade (default value is `commit`): - `auto`: user is redirect to checkout if possible, other a preview of the auto-upgrade is returned. - `commit`: a checkout session is returned or an auto-upgrade is done - `preview`: a preview invoice is always returned */
    mode?: 'auto' | 'commit' | 'preview';
}
export interface BillingInvoicePreview {
    /** Amount of the invoice */
    amount: number;
    /** Amount that will be immediately charged. */
    amountDueToday: number;
    /** Current balance, if any, being stored on the customer. If positive, the customer has credit to apply to their next invoice. */
    customerBalance: number;
    /** Current balance after potential upgrade. */
    remainingCustomerBalance: number;
    /** Details of the change happening on the subscription. */
    lines: {
        description: string;
        amount: number;
        periodStart: Timestamp;
        periodEnd: Timestamp;
    }[];
    /** Discount applied to the subscription. */
    discount?: {
        /** The combined description of all discounts applied to the subscription. */
        description: string;
        /** The total amount of all discounts applied to the subscription. */
        amount: number;
    };
}
export type BillingUpgrade = {
    result: 'checkout';
    /** Stripe payment session ID */
    sessionId: string;
} | {
    result: 'preview';
    invoice: BillingInvoicePreview;
} | {
    result: 'upgraded';
} | {
    result: 'downgraded';
} | {
    result: 'interval_changed';
};
export interface MigrateOrganizationParameters {
    /** The desired billing interval */
    interval: BillingInterval;
    /** The new product to upgrade to */
    product: 'free_2024' | 'plus_2024' | 'pro_2024';
    /** Changes to apply during a subscription upgrade or downgrade */
    changes: SubscriptionChanges;
}
export interface Error {
    error: {
        /** @format int32 */
        code: number;
        message: string;
    };
}
export interface BillingDiscount {
    /** How many months the discount will last */
    duration: number;
    /** Percent that will be deducted from the subtotal of the invoice */
    percentOff: number;
}
export interface SiteToMigrate {
    object: 'site-to-migrate';
    site: Site;
    /** The new type of the site */
    newType: SiteType;
    traffic: {
        /** Number of pageviews in the past 30 days */
        pageviews: number;
    };
    features: SiteFeature[];
}
export interface BillingPortal {
    /** URL to the billing portal for an organization */
    url: string;
}
export declare enum BillingSwitchAction {
    Trial = "trial",
    Upgrade = "upgrade",
    UpgradePassive = "upgrade_passive",
    Downgrade = "downgrade",
    UndoCancel = "undo_cancel",
    SwitchInterval = "switch_interval"
}
/** Search result representing a space. */
export interface SearchSpaceResult {
    id: string;
    title: string;
    pages: SearchPageResult[];
}
export interface CreateSpace {
    /** @maxLength 50 */
    title?: string;
    /** Unicode codepoint or character of the emoji */
    emoji?: Emoji;
    /** ID of a parent collection */
    parent?: string;
}
/**
 * @minLength 1
 * @maxLength 30
 */
export type SAMLProviderLabel = string;
/** @maxLength 1024 */
export type SAMLProviderEntityID = string;
/** @maxLength 10000 */
export type SAMLProviderCertificate = string;
/**
 * Status of the provider.
 * - `active`: The provider is active and can be used to authenticate users.
 * - `pending`: The provider is pending and is not yet fully configured.
 */
export declare enum SAMLProviderStatus {
    Active = "active",
    Pending = "pending"
}
export interface OrganizationSAMLProvider {
    /** Type of Object, always equals to "saml-provider" */
    object: 'saml-provider';
    /** Unique identifier for the provider. */
    id: string;
    label: SAMLProviderLabel;
    ssoURL: URL;
    entityID: SAMLProviderEntityID;
    certificate: SAMLProviderCertificate;
    defaultTeam?: OrganizationTeam;
    /** The role of a member in an organization, null for guests */
    defaultRole: MemberRoleOrGuest;
    /** Date at which the provider was created. */
    createdAt: Timestamp;
    /**
     * Status of the provider.
     * - `active`: The provider is active and can be used to authenticate users.
     * - `pending`: The provider is pending and is not yet fully configured.
     */
    status: SAMLProviderStatus;
    /** Metadata about the service provider. */
    service: {
        /**
         * Assertion Consumer Service (ACS) URL
         * @format uri
         */
        acsURL: string;
        /**
         * Start URL for the Identity Provider
         * @format uri
         */
        startURL: string;
        entityID: SAMLProviderEntityID;
    };
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the SAML Provider in the API
         * @format uri
         */
        location: string;
    };
}
export interface OrganizationSSOProviderLogin {
    /** Unique identifier for the provider. */
    id: string;
    label: SAMLProviderLabel;
    /**
     * The starting login URL for the Identity Provider
     * @format uri
     */
    startURL: string;
}
/** Spaces usage metrics of an organization */
export interface OrganizationUsageSpaces {
    /** Count of all spaces */
    total: number;
}
/** Collections usage metrics of an organization */
export interface OrganizationUsageCollections {
    /** Count of all collections */
    total: number;
}
/** Sites usage metrics of an organization */
export type OrganizationUsageSites = {
    /** Count of all sites */
    total: number;
    /** Count of all legacy basic sites */
    legacyBasic: number;
    /** Count of all legacy premium sites */
    legacyPremium: number;
} | {
    /** Count of all sites */
    total: number;
    /** Count of all basic sites */
    basic: number;
    /** Count of all premium sites */
    premium: number;
    /** Count of all ultimate sites */
    ultimate: number;
    /** Count of all sponsored sites */
    sponsored: number;
};
/** Team members usage metrics of an organization */
export interface OrganizationUsageTeams {
    /** Count of all teams */
    total: number;
}
/** Members usage metrics of an organization */
export interface OrganizationUsageMembers {
    /** Count of all members */
    total: number;
    /** Count of all paid seats */
    seats: number;
    /** Count of all admins */
    admin: number;
    /** Count of all creators */
    create: number;
    /** Count of all editors */
    edit: number;
    /** Count of all reviewers */
    review: number;
    /** Count of all commenters */
    comment: number;
    /** Count of all readers */
    read: number;
    /** Count of all guests */
    guest: number;
}
/** Team members usage metrics of an organization */
export interface OrganizationUsageTeamMembers {
    /** Count of all organization members in a team */
    total: number;
    /** Count of all team owners */
    owner: number;
    /** Count of all team members */
    member: number;
}
/** All usage metrics of an organization */
export interface OrganizationUsage {
    /** Spaces usage metrics of an organization */
    spaces: OrganizationUsageSpaces;
    /** Collections usage metrics of an organization */
    collections: OrganizationUsageCollections;
    /** Sites usage metrics of an organization */
    sites: OrganizationUsageSites;
    /** Team members usage metrics of an organization */
    teams: OrganizationUsageTeams;
    /** Members usage metrics of an organization */
    members: OrganizationUsageMembers;
    /** Team members usage metrics of an organization */
    teamMembers: OrganizationUsageTeamMembers;
    /** The set of permissions for the organization's usage. */
    permissions: {
        /** Can the user view the organization's usage. */
        view: boolean;
    };
}
export interface SearchAIQuery {
    query: string;
    /**
     * @deprecated
     * @maxItems 10
     */
    previousQueries?: string[];
}
/**
 * Page source
 * The source points to a page in a space.
 */
export interface SearchAIAnswerSource {
    type: 'page';
    /** Short explanation of how the source was used to answer. */
    reason?: string;
    /** The page ID of the source. */
    page: string;
    /** The revision ID where the page was extracted from. */
    revision: string;
    /** The space ID owning the page. */
    space: string;
    /** The IDs of the sections of the page that were used to answer the question. */
    sections: string[];
}
/** Answer from AI for a question asked on a content. */
export interface SearchAIAnswer {
    answer?: Document;
    followupQuestions: string[];
    /** The sources used to generate the answer. */
    sources: SearchAIAnswerSource[];
}
/** Questions recommended by the AI for the given content. */
export interface SearchAIRecommendedQuestions {
    questions: string[];
}
export interface SearchAIRecommendedQuestionStream {
    question: string;
}
export interface SearchAIAnswerStream {
    type: 'answer';
    /** Answer from AI for a question asked on a content. */
    answer: SearchAIAnswer;
}
/** Create a specification from an URL */
export type OpenAPISpecSource = {
    url: URL;
} | {
    /**
     * OpenAPI specification as text
     * @minLength 1
     */
    text: string;
};
export interface OpenAPISpecVersion {
    /** The object type, which is always "openapi-spec-version" */
    object: 'openapi-spec-version';
    /** Unique identifier */
    id: string;
    /** Date of creation */
    createdAt?: Timestamp;
    /** URL where the specification is accessible. */
    url: URL;
    /** URLs associated with the object */
    urls: {
        /** URL of the OpenAPI specification version in the API */
        location: URL;
    };
}
/** Content of the specification available through filesystem or public URL. */
export interface OpenAPISpecContent {
    /** Filesystem containing all specifications. */
    filesystem: object;
    url: URL;
}
export interface ConversationsIssuesCluster {
    object: 'issues-cluster';
    /** The ID of the conversations issues cluster */
    id: string;
    /** The label of the conversations issues cluster */
    label: string;
    createdAt: Timestamp;
    updatedAt: Timestamp;
    /** Name of the icon */
    icon: Icon;
    /** The summary of the conversations issues cluster */
    summary: string;
    /**
     * The weekly pulse of the conversations issues cluster for the past 3 months
     * @maxItems 13
     * @minItems 13
     */
    weeklyPulse: number[];
    sources: Record<string, number>;
    /** The stats of the conversations issues cluster */
    stats: {
        /** The number of issues in the conversations issues cluster */
        issues: number;
        /** The number of conversations in the conversations issues cluster */
        conversations: number;
        /** The number of tasks in the conversations issues cluster */
        tasksTotal: number;
        /** The number of tasks in the backlog in the conversations issues cluster */
        tasksBacklog: number;
        /** The number of tasks done in the conversations issues cluster */
        tasksStarted: number;
        /** The number of tasks completed in the conversations issues cluster */
        tasksCompleted: number;
        /** The number of tasks canceled in the conversations issues cluster */
        tasksCancelled: number;
    };
    /** URLs associated with the conversations issues cluster */
    urls: {
        /**
         * URL of the conversations issues cluster in the API
         * @format uri
         */
        location: string;
        /**
         * URL of the conversations issues cluster in the application
         * @format uri
         */
        app: string;
    };
}
export interface ConversationIssue {
    object: 'conversation-issue';
    /** The ID of the conversation issue */
    id: string;
    /** The title of the conversation issue */
    title: string;
    /** The summary of the conversation issue */
    summary: string;
    createdAt: Timestamp;
    ingestedAt: Timestamp;
    /** The ID of the conversation the issue belongs to */
    conversation: string;
    /** The ID of the cluster the issue has been linked to */
    cluster?: string;
    /** URLs associated with the conversation issue */
    urls: {
        /**
         * URL of the conversation issue in the API
         * @format uri
         */
        location: string;
    };
}
/** Integration source */
export type ConversationSource = string | 'email';
export interface Conversation {
    object: 'conversation';
    /** The ID of the conversation */
    id: string;
    /** The subject of the conversation */
    subject?: string;
    createdAt: Timestamp;
    processedAt?: Timestamp;
    /** Integration source */
    source: ConversationSource;
    /** URLs associated with the conversation */
    urls: {
        /**
         * URL of the conversation in the API
         * @format uri
         */
        location: string;
        /**
         * URL of the conversation in the source
         * @format uri
         */
        source?: string;
    };
}
export interface ConversationMetadata {
    /** URL to the conversation */
    url?: string;
    attributes?: Record<string, string>;
    /** Date of the conversation creation */
    createdAt?: Timestamp;
}
/** A message posted in the conversation by a user or a team member. */
export interface ConversationPartMessage {
    type: 'message';
    role: 'user' | 'assistant' | 'team-member';
    /** Markdown or HTML body of the message. */
    body: string;
}
export type ConversationPart = ConversationPartMessage;
export interface ConversationInput {
    /**
     * The unique identifier for the conversation, relative to the source in which it was created.
     * @minLength 1
     * @maxLength 255
     */
    id: string;
    metadata?: ConversationMetadata;
    /**
     * The subject of the conversation.
     * @maxLength 512
     */
    subject?: string;
    parts: ConversationPart[];
}
/** State and settings of the agent */
export interface AgentsSetupState {
    /** The email address of the agent. Emails can be forwarded to it to ingest conversations. */
    email: string;
    /** The stats of the agent. */
    stats: {
        /** The number of tasks in the backlog. */
        backlogTasks: number;
        /** The number of tasks in progress. */
        startedTasks: number;
        /** The number of tasks that have been completed. */
        completedTasks: number;
        /** The number of tasks that have been canceled. */
        canceledTasks: number;
        /** The number of conversations the agent has indexed. */
        conversations: number;
        /** The number of issues the agent has indexed. */
        issues: number;
        /** The number of issues clusters the agent has indexed. */
        issuesClusters: number;
        sources: Record<string, number>;
    };
    /** The settings for the agent. */
    settings: object;
}
/** The status of the agent task. - `backlog`: The task has not been started yet, a human should review its specification. - `started`: The task is open, a change request is associated with it. - `completed`: The task is completed. - `canceled`: The task has been canceled by a human. */
export declare enum AgentTaskStatus {
    Backlog = "backlog",
    Started = "started",
    Completed = "completed",
    Canceled = "canceled"
}
export interface AgentTask {
    object: 'agent-task';
    /** The ID of the agent task */
    id: string;
    /** The title of the agent task */
    title: string;
    /** The description of the agent task */
    description: string;
    instructions: JSONDocument;
    /** The status of the agent task. - `backlog`: The task has not been started yet, a human should review its specification. - `started`: The task is open, a change request is associated with it. - `completed`: The task is completed. - `canceled`: The task has been canceled by a human. */
    status: AgentTaskStatus;
    createdAt: Timestamp;
    updatedAt: Timestamp;
    /** ID of the cluster the agent task is associated with. */
    cluster?: string;
    /** ID of the space the agent task will act on. */
    space: string;
    /** ID of the change request the agent task is associated with. */
    changeRequest?: string;
    /** URLs associated with the agent task */
    urls: {
        /**
         * URL of the agent task in the API
         * @format uri
         */
        location: string;
        /**
         * URL of the agent task in the application
         * @format uri
         */
        app: string;
    };
}
/**
 * Title of the translation settings
 * @minLength 1
 * @maxLength 100
 */
export type TranslationTitle = string;
export interface TranslationSettings {
    object: 'translation-settings';
    /** Unique identifier of the translation settings */
    id: string;
    /** Title of the translation settings */
    title: TranslationTitle;
    languages: TranslationLanguage[];
    /** @format date-time */
    createdAt: string;
    /** @format date-time */
    updatedAt: string;
    permissions: {
        /** Whether the user can view the object */
        view: boolean;
        /** Whether the user can edit the object */
        edit: boolean;
    };
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the translation settings in the API
         * @format uri
         */
        location: string;
    };
}
export interface TranslationLanguageSettings {
    object: 'translation-language-settings';
    language: TranslationLanguage;
    instructions: JSONDocument;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the translation language settings in the API
         * @format uri
         */
        location: string;
    };
}
export interface StorageFileMetadata {
    /** Original filename */
    name: string;
    /** MIME type of the file */
    type: string;
    /** Size of the file in bytes */
    size: number;
}
export declare enum StorageUploadKind {
    CustomizationFont = "customization_font"
}
export interface StorageUploadURL {
    /** The kind of file to upload */
    object: 'storage-signed-url';
    /** Presigned URL for uploading the file */
    url: URL;
    /** The bucket object key for the file */
    key: string;
}
/**
 * The human-readable font-family name used in CSS (e.g., "Open Sans", "Playfair Display").
 * @minLength 1
 * @maxLength 50
 */
export type FontFamily = string;
/**
 * Numeric representation of the font weight (400=regular, 500=medium, 700=bold, 900=black).
 * @min 1
 * @max 1000
 */
export type FontWeight = number;
/** A font file referenced within a font-face declaration, specifying the file's location and format. */
export interface FontSource {
    /** The absolute or relative URL pointing to the font file. */
    url: URL;
    /** The format of the font file. Prefer 'woff2' for modern browsers. */
    format?: 'woff2' | 'woff';
}
/** A single font-face declaration specifying the weight and source files for a particular variation of the font. */
export interface FontFace {
    /** Numeric representation of the font weight (400=regular, 500=medium, 700=bold, 900=black). */
    weight: FontWeight;
    /**
     * Font source files provided in supported formats (e.g., woff2, woff).
     * @minItems 1
     */
    sources: FontSource[];
}
/** Defines a font family along with its various font-face declarations for use in CSS '@font-face' rules. */
export interface CustomizationFontDefinitionInput {
    /** A globally unique identifier for the font definition. */
    id: string;
    /** Whether the font is a custom font. If false, this font is provided by GitBook. */
    custom: boolean;
    /** The human-readable font-family name used in CSS (e.g., "Open Sans", "Playfair Display"). */
    fontFamily: FontFamily;
    /**
     * A list of font-face definitions, specifying variations such as weight and style.
     * @minItems 1
     */
    fontFaces: FontFace[];
}
export type CustomizationFontDefinition = CustomizationFontDefinitionInput & {
    /** The set of permissions for the font definition */
    permissions: {
        /** Can the user edit the font definition */
        edit: boolean;
    };
};
/**
 * The path of the file in the storage bucket
 * @minLength 1
 * @maxLength 512
 */
export type StorageFileKey = string;
/** A response to a request to preview a paid operation or action. A user might preview an operation before executing it to see which billing steps would be required (if any). This schema defines the response of that preview request. */
export type BillingOperationPreviewResponse = {
    /** User can go ahead with the operation without any additional steps. Their subscription will be updated to reflect the new changes. */
    type: 'go-ahead';
} | {
    /** By going ahead with this operation, the user will be starting a trial in GitBook. */
    type: 'trial-available';
} | {
    /** User must checkout to complete the operation. */
    type: 'checkout';
    invoice?: BillingInvoicePreview;
};
export type SiteAdaptiveJSONSchemaClaimsProperties = {
    type: 'boolean';
    description: string;
} | {
    type: 'string';
    enum: string[];
    description: string;
} | {
    type: 'object';
    description: string;
    properties: Record<string, SiteAdaptiveJSONSchemaClaimsProperties>;
    additionalProperties: false;
};
/** JSON schema describing the expected attributes of an Adaptive site schema. */
export interface SiteAdaptiveJSONSchema {
    $schema?: 'http://json-schema.org/draft-07/schema#';
    $id?: string;
    type: 'object';
    properties: {
        /** Unsigned claims of the site visitor. */
        unsigned?: {
            type: 'object';
            description: 'Unsigned claims of the site visitor.';
            properties: Record<string, SiteAdaptiveJSONSchemaClaimsProperties>;
            additionalProperties: false;
        };
        [key: string]: any;
    };
    additionalProperties: false;
}
export interface SiteAdaptiveSchema {
    object: 'site-adaptive-schema';
    /** JSON schema describing the expected attributes of an Adaptive site schema. */
    jsonSchema: SiteAdaptiveJSONSchema;
    /** When the adaptive schema was updated. */
    updatedAt: Timestamp;
}
/** A template condition based on the site visitor schema. */
export interface SiteAdaptiveTemplateCondition {
    /** A short description of the suggested condition. */
    description: string;
    /** The suggested condition. */
    condition: string;
}
/**
 * The theme to apply to the site. Supercedes the old header preset themes.
 * - `clean`: Modern theme featuring translucency and minimally-styled elements.
 * - `muted`: Sophisticated theme with decreased contrast between elements.
 * - `bold`: High-impact theme with prominent colors and strong contrasts.
 * - `gradient`: Trendy theme featuring colorful gradients and splashes of color.
 */
export declare enum CustomizationTheme {
    Clean = "clean",
    Muted = "muted",
    Bold = "bold",
    Gradient = "gradient"
}
/** @pattern ^#(?:[0-9a-fA-F]{3}){1,2}$ */
export type Color = string;
export interface CustomizationThemedColor {
    light: Color;
    dark: Color;
}
export interface CustomizationTint {
    color: CustomizationThemedColor;
}
export declare enum CustomizationCorners {
    Straight = "straight",
    Rounded = "rounded",
    Circular = "circular"
}
/**
 * The degree of visual depth (through shadows, gradients and elevation effects) of elements on the site.
 * - `subtle`: Subtle shadows and minimal elevation.
 * - `flat`: Flat elements, no shadows and no elevation.
 */
export declare enum CustomizationDepth {
    Subtle = "subtle",
    Flat = "flat"
}
/**
 * The style used for regular links in the main content, header and footer. Sidebar items are styled separately.
 * - `default`: Links are colored in the primary color and feature an underline in the same color.
 * - `accent`: Links are colored the same as body text and feature an underline in the primary color.
 */
export declare enum CustomizationLinksStyle {
    Default = "default",
    Accent = "accent"
}
export declare enum CustomizationDefaultFont {
    ABCFavorit = "ABCFavorit",
    Inter = "Inter",
    Roboto = "Roboto",
    RobotoSlab = "RobotoSlab",
    OpenSans = "OpenSans",
    SourceSansPro = "SourceSansPro",
    Lato = "Lato",
    Ubuntu = "Ubuntu",
    Raleway = "Raleway",
    Merriweather = "Merriweather",
    Overpass = "Overpass",
    NotoSans = "NotoSans",
    IBMPlexSerif = "IBMPlexSerif",
    Poppins = "Poppins",
    FiraSans = "FiraSans"
}
export type CustomizationFont = CustomizationDefaultFont | CustomizationFontDefinitionInput;
/**
 * The background style has been deprecated and will be removed in a future release. Use the `tint` settings instead.
 * @deprecated
 */
export declare enum CustomizationBackground {
    Plain = "plain",
    Match = "match"
}
export declare enum CustomizationIconsStyle {
    Regular = "regular",
    Solid = "solid",
    Duotone = "duotone",
    Light = "light",
    Thin = "thin"
}
/**
 * - `default`: No background, content sits directly against sidebar edge.
 * - `filled`: Muted background color that extends to sidebar edges.
 */
export declare enum CustomizationSidebarBackgroundStyle {
    Default = "default",
    Filled = "filled"
}
/**
 * - `default`: Simple list items without special styling, groups are inset with a line.
 * - `pill`: Rounded capsule shape around selected/active items.
 * - `line`: Continuous line next to all items, with colored line part for selected/active items.
 */
export declare enum CustomizationSidebarListStyle {
    Default = "default",
    Pill = "pill",
    Line = "line"
}
/**
 * The style of the search button.
 * - `prominent`: large search bar in the middle of the header, with less room for other header items,
 * - `subtle`: small search bar in the corner of the header, with more room for other header items.
 */
export declare enum CustomizationSearchStyle {
    Prominent = "prominent",
    Subtle = "subtle"
}
/** Language for the UI element */
export declare enum CustomizationLocale {
    En = "en",
    Fr = "fr",
    Es = "es",
    Zh = "zh",
    Ja = "ja",
    De = "de",
    Nl = "nl",
    No = "no",
    PtBr = "pt-br"
}
/**
 * The header preset to use for the site. This is a legacy setting and the site styling theme should be used instead.
 * @deprecated
 */
export declare enum CustomizationHeaderPreset {
    Default = "default",
    Bold = "bold",
    Contrast = "contrast",
    Custom = "custom",
    None = "none"
}
/** @maxLength 64 */
export type CustomizationContentLinkTitle = string;
export interface CustomizationContentLink {
    title: CustomizationContentLinkTitle;
    /** A relative reference to content in GitBook. */
    to: ContentRef;
}
export interface CustomizationHeaderItem {
    title: string;
    style?: 'link' | 'button-primary' | 'button-secondary';
    to: ContentRef | null;
    links: CustomizationContentLink[];
    /** Conditional expression used to evaluate whether the header item should be shown to the site's visitor. */
    condition?: Condition;
}
export interface CustomizationFooterGroup {
    title: string;
    links: CustomizationContentLink[];
}
/**
 * The text content of the announcement.
 * @minLength 2
 * @maxLength 128
 */
export type CustomizationAnnouncementMessage = string;
export interface CustomizationAnnouncement {
    /** Whether to show the site's announcement. */
    enabled: boolean;
    /** The text content of the announcement. */
    message: CustomizationAnnouncementMessage;
    /** The content or URL the announcement links to when clicked. */
    link?: CustomizationContentLink;
    /** The style of the announcement. Used to style the banner with the right semantic color and enable/disable features like hiding the banner. */
    style: 'info' | 'warning' | 'danger' | 'success';
}
export declare enum CustomizationThemeMode {
    Light = "light",
    Dark = "dark"
}
/**
 * How external links should open when clicked.
 * - `self`: External links open in the current tab.
 * - `blank`: External links open in a new browser tab.
 */
export declare enum SiteExternalLinksTarget {
    Self = "self",
    Blank = "blank"
}
export interface SiteCustomizationSettings {
    /** Title to use for the published site. If not defined, it'll fallback to the default content title. */
    title?: SiteTitle;
    styling: {
        /**
         * The theme to apply to the site. Supercedes the old header preset themes.
         * - `clean`: Modern theme featuring translucency and minimally-styled elements.
         * - `muted`: Sophisticated theme with decreased contrast between elements.
         * - `bold`: High-impact theme with prominent colors and strong contrasts.
         * - `gradient`: Trendy theme featuring colorful gradients and splashes of color.
         */
        theme: CustomizationTheme;
        primaryColor: CustomizationThemedColor;
        tint?: CustomizationTint;
        infoColor: CustomizationThemedColor;
        successColor: CustomizationThemedColor;
        warningColor: CustomizationThemedColor;
        dangerColor: CustomizationThemedColor;
        corners: CustomizationCorners;
        /**
         * The degree of visual depth (through shadows, gradients and elevation effects) of elements on the site.
         * - `subtle`: Subtle shadows and minimal elevation.
         * - `flat`: Flat elements, no shadows and no elevation.
         */
        depth: CustomizationDepth;
        /**
         * The style used for regular links in the main content, header and footer. Sidebar items are styled separately.
         * - `default`: Links are colored in the primary color and feature an underline in the same color.
         * - `accent`: Links are colored the same as body text and feature an underline in the primary color.
         */
        links: CustomizationLinksStyle;
        font: CustomizationFont;
        /**
         * The background style has been deprecated and will be removed in a future release. Use the `tint` settings instead.
         * @deprecated
         */
        background: CustomizationBackground;
        icons: CustomizationIconsStyle;
        sidebar: {
            /**
             * - `default`: No background, content sits directly against sidebar edge.
             * - `filled`: Muted background color that extends to sidebar edges.
             */
            background: CustomizationSidebarBackgroundStyle;
            /**
             * - `default`: Simple list items without special styling, groups are inset with a line.
             * - `pill`: Rounded capsule shape around selected/active items.
             * - `line`: Continuous line next to all items, with colored line part for selected/active items.
             */
            list: CustomizationSidebarListStyle;
        };
        /**
         * The style of the search button.
         * - `prominent`: large search bar in the middle of the header, with less room for other header items,
         * - `subtle`: small search bar in the corner of the header, with more room for other header items.
         */
        search: CustomizationSearchStyle;
    };
    internationalization: {
        /** Language for the UI element */
        locale: CustomizationLocale;
    };
    favicon: CustomizationFavicon;
    header: {
        /** The header preset to use for the site. This is a legacy setting and the site styling theme should be used instead. */
        preset: CustomizationHeaderPreset;
        logo?: CustomizationThemedURL;
        /**
         * Color of the background in the header. This value is now deprecated in favour of the new theming colors.
         * @deprecated
         */
        backgroundColor?: CustomizationThemedColor;
        /**
         * Color of the links in the header. This value is now deprecated and will be phased out in favour of the new theming colors.
         * @deprecated
         */
        linkColor?: CustomizationThemedColor;
        links: CustomizationHeaderItem[];
    };
    footer: {
        logo?: CustomizationThemedURL;
        groups: CustomizationFooterGroup[];
        /** @maxLength 300 */
        copyright?: string;
    };
    announcement?: CustomizationAnnouncement;
    /** Customization options for the dark/light theme modes. */
    themes: {
        default: CustomizationThemeMode;
        /** Should the reader be able to switch between dark and light mode */
        toggeable: boolean;
    };
    pdf: {
        /** If true, PDF export is enabled for the published site. */
        enabled: boolean;
    };
    feedback: {
        /** If true, feedback gathering is enabled */
        enabled: boolean;
    };
    aiSearch: {
        /** If true, AI search is enabled */
        enabled: boolean;
    };
    ai?: {
        pageLinkSummaries: {
            /** If true, AI page links summaries is enabled */
            enabled: boolean;
        };
    };
    advancedCustomization: {
        /** If true, Advanced customization is enabled */
        enabled: boolean;
    };
    git: {
        /** Whether the published site should show a link to edit the content on the git provider set up in the Git Sync */
        showEditLink: boolean;
    };
    externalLinks: {
        /**
         * How external links should open when clicked.
         * - `self`: External links open in the current tab.
         * - `blank`: External links open in a new browser tab.
         */
        target: SiteExternalLinksTarget;
    };
    pagination: {
        /** Whether the pagination navigation should be displayed on pages. */
        enabled: boolean;
    };
    trademark: {
        /** Whether the GitBook trademark ("Powered by GitBook") should be visible */
        enabled: boolean;
    };
    privacyPolicy: {
        url?: URL;
    };
    socialPreview: {
        url?: URL;
    };
    insights: {
        /**
         * Whether GitBook identifies the visitor on the site using a cookie.
         * @default true
         */
        trackingCookie: boolean;
    };
}
export interface SiteIntegrationScript {
    /** Script URL to load. */
    script: URL;
    /** Content Security Policy to secure the loading of this script. */
    contentSecurityPolicy?: string;
    /** If true, the script will potentially load use cookies and visitors should be aware. */
    cookies: boolean;
}
export interface PublishedContentSite {
    object: 'published-content-site';
    site: Site;
    structure: SiteStructure;
    customizations: {
        site: SiteCustomizationSettings;
        siteSpaces: Record<string, SiteCustomizationSettings>;
    };
    scripts: SiteIntegrationScript[];
}
/**
 * Name of the share link
 * @minLength 0
 * @maxLength 50
 */
export type ShareLinkName = string;
export interface ShareLink {
    /** Type of Object, always equals to "share-link" */
    object: 'share-link';
    /** Unique identifier for the share-link */
    id: string;
    createdAt: Timestamp;
    /** Name of the share link */
    name?: ShareLinkName;
    active?: boolean;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the published version of the share-link.
         * @format uri
         */
        published?: string;
    };
}
export interface SiteStructureItemPointer {
    type: 'site-space' | 'site-section' | 'site-section-group';
    /** Unique identifier for the site structure item (site space, site section or site section group). */
    id: string;
}
/** Position at which to move the site structure item (site space, site section or site section group). */
export interface SiteStructureItemMovePosition {
    before?: SiteStructureItemPointer;
    after?: SiteStructureItemPointer;
}
/**
 * Site Structure Item
 * A site structure item can be a site space, a site section or a site section group.
 * It is used to represent the structure of a site.
 */
export type SiteStructureItem = SiteSpace | SiteSection | SiteSectionGroup;
/** The reason or feature that triggered the site upgrade */
export type SiteUpgradeReason = SiteFeatureKey | 'settings' | 'publish-downgrade' | 'from-billing-modal' | 'payment-failed-modal';
export type SitePublishingAuth = (VisitorAuthCustomBackend | VisitorAuthIntegrationBackend) & {
    /** Type of Object, always equals to "publishing-auth" */
    object: 'publishing-auth';
    /** Private key used to sign JWT tokens. */
    privateKey: string;
    /**
     * URL to redirect to when the authenticated access secret is invalid.
     * @format uri
     */
    fallbackURL?: string;
    /**
     * Name of the authenticated access integration installed on the site (if any).
     * It is also the one being used as VA backend when the published auth settings are configured to use "integration" as backend.
     */
    integration?: string;
};
export type SitePublishingAuthUpdate = (VisitorAuthCustomBackend | VisitorAuthIntegrationBackend) & {
    /**
     * A fallback URL that will be used if authentication fails. If not provided, the fallback URL will not be changed. If set to null, the fallback URL will be unset.
     * @format uri
     */
    fallbackURL?: string | null;
};
export type SiteSearchScope = {
    /** Search across all sections of a site, only including the default content of each section. This scope is wide and shallow. You may optionally specify a list of additional site spaces to search in alongside the default content. */
    mode: 'default';
    includedSiteSpaces?: string[];
} | {
    /** Only search in the provided site spaces. */
    mode: 'specific';
    /** @minLength 1 */
    siteSpaceIds: string[];
} | {
    /** Search in all sections and site spaces. This scope is wide and deep. */
    mode: 'all';
};
export type SiteSpaceCustomizationSettings = SiteCustomizationSettings & {
    /** Indicates whether the site customization settings have been overridden. */
    hasOverrides: boolean;
};
export interface SiteSectionGroupPointer {
    type: 'site-section' | 'site-section-group';
    /** Unique identifier for the site section */
    id: string;
}
/** Position at which to move the site section group. */
export interface SiteSectionGroupMovePosition {
    before?: SiteSectionGroupPointer;
    after?: SiteSectionGroupPointer;
}
export interface SiteSectionPointer {
    type: 'site-section';
    /** Unique identifier for the site section */
    siteSection: string;
}
/** Position at which to move the site section to. */
export interface SiteSectionMovePosition {
    before?: SiteSectionPointer;
    after?: SiteSectionPointer;
}
export interface SiteSpacePointer {
    type: 'site-space';
    /** Unique identifier for the site space */
    siteSpace: string;
}
/** Position at which to move the site space to. */
export interface SiteSpaceMovePosition {
    before?: SiteSpacePointer;
    after?: SiteSpacePointer;
}
export interface OrganizationPointer {
    type: 'organization';
    /** Unique identifier for the organization */
    organization: string;
}
/** Permission of a user in a site. */
export interface UserSitePermission {
    /** The role of a member in an organization, null for guests */
    permission: MemberRoleOrGuest;
    user: User;
    /** The content or organization that enforced this permission level. */
    origin: SpacePointer | OrganizationPointer;
}
export declare enum AIMessageRole {
    User = "user",
    Assistant = "assistant",
    Developer = "developer"
}
/** Attachment to attach search results to a message. */
export interface AIMessageAttachmentSearch {
    type: 'search';
    /** The query to use to extract the knowledge. */
    query: string;
}
/** Attachment representing the profile of the visitor */
export interface AIMessageAttachmentVisitorProfile {
    type: 'visitor_profile';
}
/** Attachment to extract and pass the content of a page to the AI. */
export interface AIMessageAttachmentPage {
    type: 'page';
    /** The ID of the space to extract the content from. */
    spaceId: string;
    /** The ID of the page to extract the content from. */
    pageId: string;
}
/** Attachment to pass the tree of pages to the AI */
export interface AIMessageAttachmentPages {
    type: 'pages';
    /** The ID of the space to extract the content from. */
    spaceId: string;
}
export type AIMessageAttachment = AIMessageAttachmentSearch | AIMessageAttachmentVisitorProfile | AIMessageAttachmentPage | AIMessageAttachmentPages;
/** Context about the current user sending a message. */
export interface AIMessageContext {
    location?: {
        /** ID of the current space. */
        spaceId: string;
        /** ID of the current page. */
        pageId: string;
    };
}
/** Input version of an AI message. */
export interface AIMessageInput {
    role: AIMessageRole;
    content: string | JSONDocument;
    attachments?: AIMessageAttachment[];
    /** Context about the current user sending a message. */
    context?: AIMessageContext;
}
/** Indicate that the AI should response with a JSON object corresponding to the provided schema. */
export interface AIOutputObject {
    type: 'object';
    /** The JSON schema to use for the object. */
    schema: object;
}
/** Indicate that the AI should respond with a rich text document. */
export interface AIOutputDocument {
    type: 'document';
}
export type AIOutputFormat = AIOutputObject | AIOutputDocument;
export declare enum AIModel {
    Fast = "fast",
    ReasoningLow = "reasoning-low",
    ReasoningMedium = "reasoning-medium",
    ReasoningHigh = "reasoning-high"
}
/** Tools provided to the AI */
export interface AIToolCapabilities {
    /** Whether the AI can read the content of a page */
    getPageContent?: boolean;
    /** Whether the AI can read the table of contents of a space */
    getPages?: boolean;
    /** Whether the AI can search for content */
    search?: boolean;
}
/** Message emitted by the server to indicate the end of the AI response. It contains the ID of the response to be referenced for followup requests. */
export interface AIStreamResponseFinish {
    type: 'response_finish';
    /** The ID of the message that this event is composing. */
    messageId: string;
    /** The ID of the response */
    responseId: string;
}
/** Message emitted by the server to indicate the latest block of the document. The block can either be a new block or an update to the previous block. */
export interface AIStreamResponseDocument {
    type: 'response_document' | 'response_reasoning';
    /** The ID of the message that this event is composing. */
    messageId: string;
    /** The index of the step of the message that this event is composing. */
    stepIndex: number;
    operation: 'insert' | 'update';
    blocks: DocumentBlocksTopLevels[];
}
/** Message emitted by the server to indicate a chunk of the JSON object response. */
export interface AIStreamResponseObject {
    type: 'response_object';
    /** The ID of the message that this event is composing. */
    messageId: string;
    /** The chunk of the JSON object response */
    jsonChunk: string;
}
export interface AIToolCallGetPageContent {
    tool: 'getPageContent';
    /** The ID of the space being accessed. */
    spaceId: string;
    page: ChangedRevisionPage;
}
export interface AIToolCallGetPages {
    tool: 'getPages';
    /** The ID of the space being accessed. */
    spaceId: string;
}
/** Result of a search */
export interface AIToolCallSearchResult {
    /** The ID of the space */
    spaceId: string;
    /** The ID of the page */
    pageId: string;
    /** The anchor of the result */
    anchor?: string;
    /** The title of the result */
    title: string;
    /** The description of the result */
    description?: string;
}
/** Tool to search for content */
export interface AIToolCallSearch {
    tool: 'search';
    /** The query that has been searched for. */
    query: string;
    results: AIToolCallSearchResult[];
}
export interface AIToolCallEditPage {
    tool: 'editPage';
    /** The ID of the space being edited. */
    spaceId: string;
    page: ChangedRevisionPage;
}
export interface AIToolCallCreatePage {
    tool: 'createPage';
    /** The ID of the space being edited. */
    spaceId: string;
    page: ChangedRevisionPage;
}
export interface AIToolCallDeletePage {
    tool: 'deletePage';
    /** The ID of the space being edited. */
    spaceId: string;
    page: ChangedRevisionPage;
}
export interface AIToolCallRenamePage {
    tool: 'renamePage';
    /** The ID of the space being edited. */
    spaceId: string;
    page: ChangedRevisionPage;
    /** The new title of the page. */
    title: string;
}
export interface AIToolCallMovePage {
    tool: 'movePage';
    /** The ID of the space being edited. */
    spaceId: string;
    page: ChangedRevisionPage;
    to?: ChangedRevisionPage;
    /**
     * Indicates how the page was moved relative to the "to" page.
     * - `within`: moved as the last child of the target page (or to the root when `to` is omitted)
     * - `before`: moved directly before the target page
     * - `after`: moved directly after the target page
     */
    moveType: 'within' | 'before' | 'after';
}
export interface AIToolCallListModifiedPages {
    tool: 'listModifiedPages';
    /** The ID of the space being accessed. */
    spaceId: string;
}
export interface AIToolCallGetPageDiff {
    tool: 'getPageDiff';
    /** The ID of the space being accessed. */
    spaceId: string;
    page: ChangedRevisionPage;
}
export interface AIToolCallCreateAgentTask {
    tool: 'createAgentTask';
    /** The ID of the space the task belongs to. */
    spaceId: string;
    action: 'create' | 'update';
    task: {
        /** The unique identifier of the task. */
        id: string;
        /** The title of the task. */
        title: string;
    };
}
export type AIToolCall = AIToolCallGetPageContent | AIToolCallGetPages | AIToolCallSearch | AIToolCallEditPage | AIToolCallCreatePage | AIToolCallDeletePage | AIToolCallRenamePage | AIToolCallMovePage | AIToolCallListModifiedPages | AIToolCallGetPageDiff | AIToolCallCreateAgentTask;
/** Message emitted by the server to indicate that the AI has called a tool. */
export interface AIStreamResponseToolCall {
    type: 'response_tool_call';
    /** The ID of the message that this event is composing. */
    messageId: string;
    /** The index of the step of the message that this event is composing. */
    stepIndex: number;
    toolCall: AIToolCall;
}
export type AIStreamResponse = AIStreamResponseFinish | AIStreamResponseDocument | AIStreamResponseObject | AIStreamResponseToolCall;
/** Analytics info on the GitBook's site session. */
export interface SiteInsightsEventSession {
    /** GitBook's unique identifier of the visitor. */
    visitorId: string;
    /** GitBook's unique identifier of the visitor's session. */
    sessionId: string;
    /** The visitors cookies. */
    cookies: Record<string, string>;
    /**
     * IP address of the visitor.
     * If not defined, it'll default to the IP executing the request.
     */
    ip?: string;
    /**
     * User-agent of the visitor.
     * https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userAgent
     */
    userAgent: string;
    /**
     * Language of the visitor.
     * https://developer.mozilla.org/en-US/docs/Web/API/Navigator/language
     */
    language: string | null;
    /** Referrer of the session */
    referrer: '' | null | URL;
    /**
     * Deprecated, use visitorAuthClaims instead.
     * @deprecated
     */
    visitorAuthToken?: string | null;
    /**
     * Claims of the visitor.
     * This is used to identify the visitor with adaptive content.
     */
    visitorAuthClaims?: PlainObject;
}
/** Location of the event. */
export interface SiteInsightsEventLocation {
    /** URL of the location. */
    url: URL;
    /** ID of the concerned site section. */
    siteSection: string | null;
    /** ID of the concerned site space. */
    siteSpace: string | null;
    /** ID of the concerned site share key. */
    siteShareKey: string | null;
    /** ID of the concerned space. */
    space: string | null;
    /** ID of the concerned revision. */
    revision: string | null;
    /** ID of the concerned page. */
    page: string | null;
}
export interface SiteInsightsEventBase {
    /** Analytics info on the GitBook's site session. */
    session: SiteInsightsEventSession;
    /** Location of the event. */
    location: SiteInsightsEventLocation;
    /** Optional timestamp of the event. If not provided, the current timestamp will be used. */
    timestamp?: Timestamp;
}
export type SiteInsightsEventPageView = SiteInsightsEventBase & {
    type: 'page_view';
};
export type SiteInsightsEventSearchOpen = SiteInsightsEventBase & {
    type: 'search_open';
};
export type SiteInsightsEventSearchTypeQuery = SiteInsightsEventBase & {
    type: 'search_type_query';
    /** Query of the search. */
    query: string;
};
export type SiteInsightsEventSearchOpenResult = SiteInsightsEventBase & {
    type: 'search_open_result';
    /** Query of the search. */
    query: string;
    result: {
        /** ID of the concerned space. */
        spaceId: string;
        /** ID of the concerned page. */
        pageId: string;
    };
};
export declare enum PageFeedbackRating {
    Bad = "bad",
    Ok = "ok",
    Good = "good"
}
export type SiteInsightsEventPagePostFeedback = SiteInsightsEventBase & {
    type: 'page_post_feedback';
    feedback: {
        rating: PageFeedbackRating;
    };
};
export type SiteInsightsEventPagePostFeedbackComment = SiteInsightsEventBase & {
    type: 'page_post_feedback_comment';
    feedback: {
        rating: PageFeedbackRating;
        /**
         * @minLength 1
         * @maxLength 512
         */
        comment: string;
    };
};
export type SiteInsightsEventAskQuestion = SiteInsightsEventBase & {
    type: 'ask_question';
    /** Question being asked. */
    query: string;
};
export declare enum SiteInsightsLinkPosition {
    Announcement = "announcement",
    Header = "header",
    Footer = "footer",
    Sidebar = "sidebar",
    Content = "content"
}
export type SiteInsightsEventLinkClick = SiteInsightsEventBase & {
    type: 'link_click';
    link: {
        /** A relative reference to content in GitBook. */
        target: ContentRef;
        position: SiteInsightsLinkPosition;
    };
};
export type SiteInsightsEventAPIClientOpen = SiteInsightsEventBase & {
    type: 'api_client_open';
    /** Pointer to an operation in the OpenAPI spec. */
    operation: OpenAPIOperationPointer;
};
export type SiteInsightsEventAPIClientRequest = SiteInsightsEventBase & {
    type: 'api_client_request';
    /** Pointer to an operation in the OpenAPI spec. */
    operation: OpenAPIOperationPointer;
};
export declare enum SiteInsightsTrademarkPlacement {
    Sidebar = "sidebar",
    Ad = "ad",
    Footer = "footer",
    Pdf = "pdf"
}
export type SiteInsightsEventTrademarkClick = SiteInsightsEventBase & {
    type: 'trademark_click';
    placement: SiteInsightsTrademarkPlacement;
};
export declare enum SiteInsightsAdPlacement {
    Aside = "aside"
}
export interface SiteInsightsAd {
    domain: string;
    zoneId: string;
    placement: SiteInsightsAdPlacement;
}
export type SiteInsightsEventAdClick = SiteInsightsEventBase & {
    type: 'ad_click';
    ad: SiteInsightsAd;
};
export type SiteInsightsEventAdDisplay = SiteInsightsEventBase & {
    type: 'ad_display';
    ad: SiteInsightsAd;
};
export type SiteInsightsEvent = SiteInsightsEventPageView | SiteInsightsEventSearchOpen | SiteInsightsEventSearchTypeQuery | SiteInsightsEventSearchOpenResult | SiteInsightsEventPagePostFeedback | SiteInsightsEventPagePostFeedbackComment | SiteInsightsEventAskQuestion | SiteInsightsEventLinkClick | SiteInsightsEventAPIClientOpen | SiteInsightsEventAPIClientRequest | SiteInsightsEventTrademarkClick | SiteInsightsEventAdClick | SiteInsightsEventAdDisplay;
export interface SiteInsightsQueryDateTimeColumn {
    column: 'datetime';
    interval?: 'hour' | 'day' | 'week' | 'month';
}
export type SiteInsightsQueryEventsColumn = SiteInsightsQueryDateTimeColumn | {
    column: 'url';
} | {
    column: 'eventType';
} | {
    column: 'eventsCount';
} | {
    column: 'sessionsCount';
} | {
    column: 'visitorsCount';
} | {
    column: 'siteSection';
} | {
    column: 'siteSpace';
} | {
    column: 'siteShareKey';
} | {
    column: 'page';
} | {
    column: 'visitorGeoCountry';
} | {
    column: 'visitorGeoPoint';
    /**
     * @min 0
     * @max 15
     */
    precision?: number;
} | {
    column: 'visitorDevice';
} | {
    column: 'visitorBrowser';
} | {
    column: 'visitorOS';
} | {
    column: 'visitorBot';
} | {
    column: 'visitorLanguage';
} | {
    column: 'eventLinkTargetValue';
} | {
    column: 'eventLinkTargetKind';
} | {
    column: 'eventLinkTargetDomain';
} | {
    column: 'eventLinkPosition';
} | {
    column: 'eventAPIOperationPath';
} | {
    column: 'eventAPIOperationMethod';
} | {
    column: 'eventSearchQuery';
} | {
    column: 'eventPageFeedbackRating';
} | {
    column: 'eventPageFeedbackComment';
} | {
    column: 'pageFeedbackRating';
} | {
    column: 'referrer';
} | {
    column: 'referrerDomain';
} | {
    column: 'utmSource';
} | {
    column: 'utmMedium';
} | {
    column: 'utmCampaign';
} | {
    column: 'utmTerm';
} | {
    column: 'utmContent';
} | {
    column: 'visitorClaimProperty';
} | {
    column: 'visitorClaim';
    claim: string;
} | {
    column: 'eventAdDomain';
} | {
    column: 'eventAdPlacement';
} | {
    column: 'eventTrademarkPlacement';
};
export declare enum SiteInsightsEventType {
    PageView = "page_view",
    SearchOpen = "search_open",
    SearchTypeQuery = "search_type_query",
    SearchOpenResult = "search_open_result",
    PagePostFeedback = "page_post_feedback",
    PagePostFeedbackComment = "page_post_feedback_comment",
    AskQuestion = "ask_question",
    LinkClick = "link_click",
    ApiClientOpen = "api_client_open",
    ApiClientRequest = "api_client_request",
    AdClick = "ad_click",
    AdDisplay = "ad_display",
    TrademarkClick = "trademark_click"
}
export declare enum SiteInsightsVisitorBrowser {
    Chrome = "chrome",
    Firefox = "firefox",
    Safari = "safari",
    Edge = "edge",
    Ie = "ie",
    Opera = "opera",
    Unknown = "unknown"
}
export declare enum SiteInsightsVisitorDevice {
    Desktop = "desktop",
    Tablet = "tablet",
    Mobile = "mobile",
    Unknown = "unknown"
}
export declare enum SiteInsightsVisitorOS {
    Windows = "windows",
    Macos = "macos",
    Linux = "linux",
    Android = "android",
    Ios = "ios",
    Unknown = "unknown"
}
export declare enum SiteInsightsVisitorBot {
    Unknown = "unknown",
    Googlebot = "googlebot",
    Bingbot = "bingbot",
    Duckduckbot = "duckduckbot",
    Facebookbot = "facebookbot",
    Applebot = "applebot",
    Chatgpt = "chatgpt",
    Anthropic = "anthropic"
}
export type SiteInsightsQueryEventsValues = {
    column: 'datetime';
    values: Timestamp[];
} | {
    column: 'url';
    values: URL[];
} | {
    column: 'eventsCount';
    values: number[];
} | {
    column: 'sessionsCount';
    values: number[];
} | {
    column: 'visitorsCount';
    values: number[];
} | {
    column: 'eventType';
    values: SiteInsightsEventType[];
} | {
    column: 'visitorClaim';
    claim: string;
    values: string[];
} | {
    column: 'visitorClaimProperty';
    values: string[];
} | {
    column: 'visitorBrowser';
    values: SiteInsightsVisitorBrowser[];
} | {
    column: 'visitorDevice';
    values: SiteInsightsVisitorDevice[];
} | {
    column: 'visitorOS';
    values: SiteInsightsVisitorOS[];
} | {
    column: 'visitorBot';
    values: SiteInsightsVisitorBot[];
} | {
    column: 'eventLinkTargetValue';
    values: ContentRef[];
} | {
    column: 'eventLinkTargetKind';
    values: ('url' | 'page' | 'file' | 'anchor' | 'space' | 'collection' | 'user' | 'reusable-content')[];
} | {
    column: 'eventLinkPosition';
    values: SiteInsightsLinkPosition[];
} | {
    column: 'siteSection';
    values: (string | null)[];
} | {
    column: 'siteSpace';
    values: (string | null)[];
} | {
    column: 'siteShareKey';
    values: (string | null)[];
} | {
    column: 'page';
    values: (null | {
        page: string | null;
        space: string;
    })[];
} | {
    column: 'visitorGeoCountry';
    values: (string | null)[];
} | {
    column: 'visitorGeoPoint';
    values: ({
        latitude: number;
        longitude: number;
        h3: string;
    } | null)[];
} | {
    column: 'visitorLanguage';
    values: (string | null)[];
} | {
    column: 'eventLinkTargetDomain';
    values: (string | null)[];
} | {
    column: 'eventAPIOperationPath';
    values: (string | null)[];
} | {
    column: 'eventAPIOperationMethod';
    values: (string | null)[];
} | {
    column: 'eventSearchQuery';
    values: string[];
} | {
    column: 'pageFeedbackRating';
    values: {
        ok: number;
        good: number;
        bad: number;
    }[];
} | {
    column: 'eventPageFeedbackRating';
    values: PageFeedbackRating[];
} | {
    column: 'eventPageFeedbackComment';
    values: string[];
} | {
    column: 'referrer';
    values: string[];
} | {
    column: 'referrerDomain';
    values: string[];
} | {
    column: 'utmSource';
    values: string[];
} | {
    column: 'utmMedium';
    values: string[];
} | {
    column: 'utmCampaign';
    values: string[];
} | {
    column: 'utmTerm';
    values: string[];
} | {
    column: 'utmContent';
    values: string[];
} | {
    column: 'eventAdDomain';
    values: string[];
} | {
    column: 'eventAdPlacement';
    values: SiteInsightsAdPlacement[];
} | {
    column: 'eventTrademarkPlacement';
    values: SiteInsightsTrademarkPlacement[];
};
export declare enum SiteInsightsQueryOperator {
    In = "in",
    NotIn = "notIn",
    GreaterThan = "greaterThan",
    GreaterThanOrEqual = "greaterThanOrEqual",
    LessThan = "lessThan",
    LessThanOrEqual = "lessThanOrEqual"
}
export type SiteInsightsQueryEventsFilter = SiteInsightsQueryEventsValues & {
    operator?: SiteInsightsQueryOperator;
};
export declare enum SiteInsightsQueryRange {
    LastYear = "lastYear",
    Last3Months = "last3Months",
    Last30Days = "last30Days",
    Last7Days = "last7Days",
    Last24Hours = "last24Hours"
}
export interface SiteInsightsQueryEventsAggregation {
    select?: SiteInsightsQueryEventsColumn[];
    where?: SiteInsightsQueryEventsFilter[];
    groupBy?: SiteInsightsQueryEventsColumn[];
    order?: {
        by: SiteInsightsQueryEventsColumn;
        direction: 'asc' | 'desc';
    };
    range: SiteInsightsQueryRange;
    /**
     * @min 1
     * @max 1000
     * @default 1000
     */
    limit?: number;
}
export interface SiteInsightsQueryEventsAggregationResult {
    columns: SiteInsightsQueryEventsValues[];
}
/** A segment of visitors with the same characteristics. */
export interface SiteInsightsVisitorSegment {
    /** The title of the visitor profile. */
    title: string;
    claims: PlainObject;
    /** The number of events for this visitor profile. */
    events: number;
    /** The number of visitors for this visitor profile. */
    visitors: number;
    /** The number of sessions for this visitor profile. */
    sessions: number;
}
export interface SiteAdsStats {
    impressions: number;
    clicks: number;
    revenue: string;
}
/**
 * The source path to redirect from.
 * @maxLength 512
 * @pattern ^\/(?:[A-Za-z0-9\-._~]|%[0-9A-Fa-f]{2})+(?:\/(?:[A-Za-z0-9\-._~]|%[0-9A-Fa-f]{2})+)*$
 */
export type SiteRedirectSourcePath = string;
export interface SiteRedirectDestinationSiteSection {
    kind: 'site-section';
    /** Unique identifier for the site section to redirect to */
    siteSectionId: string;
}
export interface SiteRedirectDestinationSiteSpace {
    kind: 'site-space';
    /** Unique identifier for the site space to redirect to */
    siteSpaceId: string;
}
export interface SiteRedirectDestinationPage {
    kind: 'site-page';
    /** Unique identifier for the site space of the page */
    siteSpaceId: string;
    /** Unique identifier for the page within the site space to redirect to */
    pageId: string;
}
export type SiteRedirectDestination = SiteRedirectDestinationSiteSection | SiteRedirectDestinationSiteSpace | SiteRedirectDestinationPage;
export interface SiteRedirect {
    object: 'site-redirect';
    /** The unique identifier for the redirect. */
    id: string;
    /** The source path to redirect from. */
    source: SiteRedirectSourcePath;
    destination: SiteRedirectDestination;
}
export interface Subdomain {
    object: 'subdomain';
    /**
     * The GitBook subdomain, for example "my-company" in "my-company.gitbook.io"
     * @minLength 3
     * @maxLength 32
     * @pattern ^[a-z0-9][a-z0-9-]{1,30}[a-z0-9]$
     */
    subdomain: string;
    target: OrganizationPointer;
    isActive: boolean;
}
export declare enum CustomHostnameDnsStatus {
    DnsPassed = "dns_passed",
    DnsWrongCname = "dns_wrong_cname",
    DnsNoCname = "dns_no_cname",
    DnsCloudflareProxied = "dns_cloudflare_proxied",
    DnsWrongCaa = "dns_wrong_caa"
}
export declare enum CustomHostnameSslStatus {
    Live = "live",
    SslUnknown = "ssl_unknown",
    SslPending = "ssl_pending",
    SslFailed = "ssl_failed",
    SslRetryExpired = "ssl_retry_expired"
}
export declare enum CustomHostnameErrorStatus {
    InvalidDomain = "invalid_domain",
    InternalError = "internal_error"
}
export type CustomHostnameStatus = CustomHostnameDnsStatus | CustomHostnameSslStatus | CustomHostnameErrorStatus;
export interface CustomHostname {
    object: 'custom-hostname';
    /** Custom hostname for the site, for e.g. docs.mycompany.com */
    hostname: SiteHostname;
    target: OrganizationPointer | SitePointer;
    isActive: boolean;
    status?: CustomHostnameStatus;
    /** URLs associated with the object */
    urls: {
        /**
         * URL of the custom hostname in the API
         * @format uri
         */
        location: string;
    };
}
export interface UnsplashImage {
    kind: 'unsplash_image';
    id: string;
    description: string;
    downloadLocation: string;
    urls: {
        full: string;
        small: string;
    };
    author: {
        name: string;
        url: string;
    };
}
/** JWT tokens to authenticate in Hive for all content. */
export interface HiveAccessToken {
    contents: Record<string, string>;
}
/** The context to send when purging the CDN Cache */
export interface PurgeCDNCacheContext {
    /** The list of tags to purge */
    tags: string[];
}
/** The Cloudflare Hostname status */
export declare enum CloudflareHostnameStatus {
    Pending = "pending",
    Active = "active",
    Blocked = "blocked",
    Moved = "moved",
    Deleted = "deleted"
}
/** The Cloudflare Hostname TLS status */
export declare enum CloudflareHostnameTLSStatus {
    Initializing = "initializing",
    PendingValidation = "pending_validation",
    PendingIssuance = "pending_issuance",
    PendingDeployment = "pending_deployment",
    Active = "active",
    PendingDeletion = "pending_deletion",
    PendingCleanup = "pending_cleanup",
    Deleted = "deleted"
}
/** The Cloudflare Hostname TLS validation method */
export declare enum CloudflareHostnameTLSValidationMethod {
    Http = "http",
    Txt = "txt",
    Email = "email"
}
/** The Cloudflare Hostname TLS certificate */
export interface CloudflareHostnameTLSCertificate {
    issuer?: string;
    expiresOn?: string;
    issuedOn?: string;
}
/** The Cloudflare Hostname TLS validation error */
export interface CloudflareHostnameTLSValidationError {
    message: string;
}
/** The Cloudflare Hostname TLS information */
export interface CloudflareHostnameTLSInfo {
    /** The Cloudflare Hostname TLS status */
    status: CloudflareHostnameTLSStatus;
    /** The Cloudflare Hostname TLS validation method */
    method: CloudflareHostnameTLSValidationMethod;
    certificateAuthority?: string;
    certificates: CloudflareHostnameTLSCertificate[];
    validationErrors: CloudflareHostnameTLSValidationError[];
}
/** Cloudflare Custom Domain's information */
export interface CustomDomainInfo {
    hostname: string;
    /** The Cloudflare Hostname status */
    status: CloudflareHostnameStatus;
    createdAt: string;
    /** The Cloudflare Hostname TLS information */
    ssl?: CloudflareHostnameTLSInfo;
    verificationErrors: string[];
}
/** The GitBook Staff User info. */
export interface StaffUserInfo {
    id: string;
    searchKey: string;
}
/** The User Firebase Auth Info. */
export interface FirebaseUserInfo {
    uid: string;
    displayName?: string;
    email?: string;
    phoneNumber?: string;
    photoUrl?: string;
    providerId?: string;
}
/** The GitBook User info shown in the BackOffice. */
export interface UserBackOfficeInfo {
    id: string;
    authProviders: FirebaseUserInfo[];
    createdAt: string;
    lastSignInAt: string;
    disabled: boolean;
}
/** The context to send when blocking/unblocking */
export interface BlockContext {
    block: boolean;
}
/** The GitBook User impersonation info. */
export interface UserImpersonationInfo {
    authURL: string;
    impersonatorId: string;
}
/** The info returned when impersonating a GitBook User. */
export type UserImpersonation = UserBackOfficeInfo & {
    /** The GitBook User impersonation info. */
    impersonation: UserImpersonationInfo;
};
/** The teams permissions of a user */
export interface UserOrganizationsTeamsPermissions {
    /**
     * "The role of a team member.
     * "owner": Can manage team members.
     * "member": Is a member of the team.
     */
    role: TeamMemberRole;
}
/** The organizations permissions of a user */
export interface UserOrganizationsPermissions {
    /** The role of a member in an organization, null for guests */
    role: MemberRoleOrGuest;
    teams: Record<string, UserOrganizationsTeamsPermissions>;
    disabled?: boolean;
}
/** The collections permissions of a user */
export interface UserCollectionsPermissions {
    organization: string;
    /** The role of a member in an organization, null for guests */
    level: MemberRoleOrGuest;
    collection?: string;
}
/** The spaces permissions of a user */
export interface UserSpacesPermissions {
    organization: string;
    /** The role of a member in an organization, null for guests */
    level: MemberRoleOrGuest;
    collection?: string;
}
/** All the permissions of a user */
export interface Index {
    updatedAt: Timestamp;
    searchKey: string;
    organizations: Record<string, UserOrganizationsPermissions>;
    collections: Record<string, UserCollectionsPermissions>;
    spaces: Record<string, UserSpacesPermissions>;
}
export type BackOfficeSite = Site & {
    /** ID of the organization owning this site */
    organization: string;
};
/** Site Content */
export interface PublishedSiteContent {
    /** ID of the site matching. */
    site: string;
    /** ID of the site-section matching. */
    siteSection?: string;
    /** ID of the site-space matching. */
    siteSpace: string;
    /** ID of the space matching. */
    space: string;
    /** Identifier of the change request being previewed in this URL. */
    changeRequest?: string;
    /** Identifier of the revision being previewed in this URL. */
    revision?: string;
    /** Path of the content relative to the space */
    pathname: string;
    /** Prefix of the path in the URL dedicated to the space */
    basePath: string;
    /** Prefix of the path in the URL dedicated to the site */
    siteBasePath: string;
    /** Short-lived API token to fetch content related to the space in the context of the URL. */
    apiToken: string;
    /** ID of the organization. */
    organization: string;
    /** Share link key of the site in case the site was published with share-links. */
    shareKey?: string;
    /** Whether the resolved site URL is complete and at it's terminal point, meaning no more site path segments can be further expected before any page path segments. */
    complete: boolean;
    /** Context returned only for a authenticated access session to track changes in the visitor session context that affect content rendering (used for cache invalidation). */
    contextId?: string;
    /** The canonical URL of the resolution. */
    canonicalUrl: string;
}
export type PublishedSiteContentLookup = {
    /** Type of target for the redirect */
    target: 'application' | 'content' | 'external';
    redirect: URL;
} | PublishedSiteContent;
/** An object that describes the payload of site visitor info. It can include a jwt token with signed claims and/or a record of its unsigned claims. */
export interface SiteVisitorPayload {
    /** JWT token generated for a authenticated access session. */
    jwtToken?: string;
    unsignedClaims?: PlainObject;
}
/**
 * @minLength 64
 * @maxLength 64
 */
export type SHA256 = string;
export interface SpaceTrackPageView {
    /** Unique identifier of the page. */
    pageId?: string;
    /** Analytics info on the GitBook's content visitor. */
    visitor: {
        /** GitBook's unique identifier of the visitor. */
        anonymousId: string;
        /** The visitors cookies. */
        cookies: Record<string, string>;
        /**
         * IP address of the visitor.
         * If undefined, it'll default to the IP executing the request.
         */
        ip?: string;
        /**
         * User-agent of the visitor.
         * https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userAgent
         */
        userAgent: string;
        /**
         * Language of the visitor.
         * https://developer.mozilla.org/en-US/docs/Web/API/Navigator/language
         */
        language?: string;
    };
    /** The GitBook content's URL visited (including URL params). */
    url: string;
    /** The URL of referrer that linked to the page. */
    referrer: string;
}
export type SiteTrackPageView = {
    /** Unique identifier of the page. */
    pageId?: string;
    /** Analytics info on the GitBook's content visitor. */
    visitor: {
        /** GitBook's unique identifier of the visitor. */
        anonymousId: string;
        /** The visitors cookies. */
        cookies: Record<string, string>;
        /**
         * IP address of the visitor.
         * If undefined, it'll default to the IP executing the request.
         */
        ip?: string;
        /**
         * User-agent of the visitor.
         * https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userAgent
         */
        userAgent: string;
        /**
         * Language of the visitor.
         * https://developer.mozilla.org/en-US/docs/Web/API/Navigator/language
         */
        language?: string;
    };
    /** The GitBook content's URL visited (including URL params). */
    url: string;
    /** The URL of referrer that linked to the page. */
    referrer: string;
} & ({
    /** Unique identifier of the space. */
    spaceId: string;
} | {
    /** The site-space that was viewed */
    siteSpaceId: string;
});
export interface UpdateContentPublishingAuth {
    /**
     * A fallback URL that will be used if authentication fails.
     * @format uri
     */
    fallbackURL?: string;
}
/** Predefined GitBook user identifiers */
export declare enum GitBookUsers {
    GitbookAgent = "gitbook:agent"
}
export type ComputedContentSource = ComputedContentSourceDocument | ComputedContentSourceRevision;
export type InputPageBase = {
    /**
     * Optional unique identifier for the page.
     * It can be used to reference pages in document links.
     * @pattern ^[a-zA-Z0-9]{1,40}$
     */
    id?: string;
    /** @minLength 1 */
    title: string;
} & ({
    /** Emoji of the page. */
    emoji: Emoji;
} | {
    /** Icon of the page. */
    icon?: Icon;
});
export type InputPageDocument = InputPageBase & {
    type: 'document';
    /**
     * @minLength 0
     * @maxLength 300
     */
    description?: string;
    /** Page's slug in its direct parent */
    slug?: string;
    pages?: (InputPageDocument | InputPageLink | InputPageComputed)[];
    computed?: ComputedContentSourceDocument;
};
export type InputPageLink = InputPageBase & {
    type: 'link';
    /** A relative reference to content in GitBook. */
    target: ContentRef;
};
export type InputPageComputed = InputPageBase & {
    type: 'computed';
    computed: ComputedContentSourceRevision;
};
export type InputPageGroup = InputPageBase & {
    type: 'group';
    /** Page's slug in its direct parent */
    slug?: string;
    /** @minLength 1 */
    pages: (InputPageDocument | InputPageLink | InputPageComputed)[];
};
export type InputPage = InputPageDocument | InputPageLink | InputPageComputed | InputPageGroup;
export interface InputFile {
    id?: string;
    name: string;
    contentType: string;
    downloadURL: string;
    size: number;
    /** For images, it contains the dimensions of it. */
    dimensions?: {
        width: number;
        height: number;
    };
}
/** The type of semantic change. */
export declare enum RevisionSemanticChangeType {
    PageCreated = "page_created",
    PageEdited = "page_edited",
    PageDeleted = "page_deleted",
    PageMoved = "page_moved",
    FileCreated = "file_created",
    FileEdited = "file_edited",
    FileDeleted = "file_deleted",
    CustomFieldsEdited = "custom_fields_edited"
}
/**
 * * `running`: The operation is still running
 * * `failure`: The operation failed
 * * `success`: The operation was successful
 */
export declare enum GitSyncOperationState {
    Running = "running",
    Failure = "failure",
    Success = "success"
}
export declare enum GitSyncOperationDirection {
    Export = "export",
    Import = "import"
}
/**
 * Core stages of a Git Sync process. This is not exhaustive, but should cover
 * the important ones.
 * - repo_fetch: Includes fetching the latest repository contents from remote provider.
 * - config_check: Includes checking if the YAML config is valid, etc.
 * - content_process: Includes processing of pages & files to be imported/exported.
 * - finalize: Includes finalizing the sync process like creating the commit on git, or
 * creating a new revision.
 */
export declare enum GitSyncOperationStage {
    RepoFetch = "repo_fetch",
    ConfigCheck = "config_check",
    ContentProcess = "content_process",
    Finalize = "finalize"
}
export interface GitSyncOperation {
    /**
     * * `running`: The operation is still running
     * * `failure`: The operation failed
     * * `success`: The operation was successful
     */
    state: GitSyncOperationState;
    direction: GitSyncOperationDirection;
    /**
     * Core stages of a Git Sync process. This is not exhaustive, but should cover
     * the important ones.
     * - repo_fetch: Includes fetching the latest repository contents from remote provider.
     * - config_check: Includes checking if the YAML config is valid, etc.
     * - content_process: Includes processing of pages & files to be imported/exported.
     * - finalize: Includes finalizing the sync process like creating the commit on git, or
     * creating a new revision.
     */
    stage: GitSyncOperationStage;
    dispatchedTasks: number;
    completedTasks: number;
    /** Date when the operation was started */
    startedAt: Timestamp;
    /** Date when the operation was last updated */
    updatedAt: Timestamp;
    /** Date when the operation was successful (when state is `success`) */
    completedAt?: Timestamp;
    /** Error details, defined if state is `failure`. */
    error?: string;
}
export type IntegrationEnvironmentSpaceInstallation = IntegrationContentInstallationBase & {
    /** The space the integration is installed on. */
    space: string;
};
export type IntegrationEnvironmentSiteInstallation = IntegrationContentInstallationBase & {
    /** The site the integration is installed on. */
    site: string;
};
/** Runtime environment provided during the execution of integration's code. */
export interface IntegrationEnvironment {
    /**
     * Authentication token to use with the HTTP API. Depending on the context, the token might be representing the installation or the integration.
     * @deprecated
     */
    authToken?: string;
    integration: Integration;
    /** Installation of an integration on an account */
    installation?: IntegrationInstallation;
    spaceInstallation?: IntegrationEnvironmentSpaceInstallation;
    siteInstallation?: IntegrationEnvironmentSiteInstallation;
    /** Secrets stored on the integration and passed at runtime. */
    secrets: IntegrationSecrets;
    /**
     * Secret that can be used to verify the authenticity of incoming HTTP requests to the integration.
     * @deprecated
     */
    signingSecret?: string;
    signingSecrets: {
        /** Secret that can be used to verify the authenticity of incoming HTTP requests to the integration. */
        integration: string;
        /** Secret that can be used to verify the authenticity of incoming HTTP requests to the installation. */
        installation?: string;
        /** Secret that can be used to verify the authenticity of incoming HTTP requests to the space installation. */
        spaceInstallation?: string;
        /** Secret that can be used to verify the authenticity of incoming HTTP requests to the site installation. */
        siteInstallation?: string;
    };
    /** URL of the HTTP API */
    apiEndpoint: string;
    apiTokens: {
        /** API authentication token representing the integration. */
        integration: string;
        /** API authentication token representing the current installation. */
        installation?: string;
    };
}
/** Response expected for an event of type `content_compute_document`. */
export interface ContentComputeDocumentEventResponse {
    document: Document;
}
/** Response expected for an event of type `content_compute_pages`. */
export interface ContentComputeRevisionEventResponse {
    pages?: InputPage[];
    files?: InputFile[];
}
export declare enum APIIntegrationScope {
    IntegrationRead = "integration:read",
    IntegrationUpdate = "integration:update",
    IntegrationInstallationRead = "integration:installation:read",
    IntegrationInstallationUpdate = "integration:installation:update"
}
export type APIScope = IntegrationScope | APIIntegrationScope;
/** Common properties for all Content API tokens. */
export interface ContentAPIBaseToken {
    /** ID of the organization that owns the content. A content token is always scoped to spaces from the same organization. */
    organization: string;
    /** List of spaces that the token is allowed to access. */
    spaces: string[];
    /** Attributes or assertions that provide specific details about the visitor for which the token was generated. */
    claims?: Record<string, any>;
    /** Multiplier for the rate limit applied to the token. */
    rateLimitMultiplier?: number;
}
export type SpaceAPIToken = ContentAPIBaseToken & {
    kind: 'space';
    /** ID of the space that the token is allowed to access. */
    space: string;
};
export type CollectionAPIToken = ContentAPIBaseToken & {
    kind: 'collection';
    /** ID of the collection that the token is allowed to access. */
    collection: string;
};
export type SiteAPIToken = ContentAPIBaseToken & {
    kind: 'site';
    /** ID of the site that the token is allowed to access. */
    site: string;
    /** ID of the site-space to be used when using this token for rendering published content. */
    siteSpace: string;
    /** ID of the site-section to be used when using this token for rendering published content. Only defined for section sites. */
    siteSection?: string;
    /** ID of the space to be used when using this token for rendering published content. */
    space: string;
};
/** Content properties stored in a Content API token. */
export type ContentAPITokenPayload = SpaceAPIToken | CollectionAPIToken | SiteAPIToken;
export interface SpaceInfoChannel {
    channel: 'space';
    space: string;
}
/** Channel notified when the main content of a space is changed. */
export interface SpaceContentChannel {
    channel: 'space-content';
    space: string;
}
export interface SpaceGitInfoChannel {
    channel: 'space-git-info';
    space: string;
}
export interface SpacePublishingAuthChannel {
    channel: 'space-publishing-auth';
    space: string;
}
export interface SpacePublishingCustomizationChannel {
    channel: 'space-publishing-customization';
    space: string;
}
export interface SpaceContentRefsChannel {
    channel: 'space-content-refs';
    space: string;
}
export interface SpaceIntegrationsChannel {
    channel: 'space-integrations';
    space: string;
}
export interface UserAPITokensChannel {
    channel: 'user-api-tokens';
    user: string;
}
export interface UserOrganizationsChannel {
    channel: 'user-organizations';
    user: string;
}
export interface UserProfileChannel {
    channel: 'user-profile';
    user: string;
}
export interface ChangeRequestChannel {
    channel: 'space-change-request';
    space: string;
    changeRequest: string;
}
export interface ChangeRequestsChannel {
    channel: 'space-change-requests';
    space: string;
}
export interface ChangeRequestReviewsChannel {
    channel: 'space-change-request-reviews';
    space: string;
    changeRequest: string;
}
export interface ChangeRequestContentRefsChannel {
    channel: 'space-change-request-content-refs';
    space: string;
    changeRequest: string;
}
export interface CollectionChannel {
    channel: 'collection';
    collection: string;
}
export interface CollectionPublishingCustomizationChannel {
    channel: 'collection-publishing-customization';
    collection: string;
}
export interface OrganizationInfoChannel {
    channel: 'organization';
    organization: string;
}
export interface OrganizationInviteLinksChannel {
    channel: 'organization-link-invites';
    organization: string;
}
export interface OrganizationMembersChannel {
    channel: 'organization-members';
    organization: string;
}
export interface OrganizationMemberChannel {
    channel: 'organization-member';
    organization: string;
    user: string;
}
export interface OrganizationSAMLChannel {
    channel: 'organization-saml';
    organization: string;
}
export interface OrganizationTeamsChannel {
    channel: 'organization-teams';
    organization: string;
}
export interface OrganizationTeamChannel {
    channel: 'organization-team';
    organization: string;
    team: string;
}
export interface OrganizationTeamMembersChannel {
    channel: 'organization-team-members';
    organization: string;
    team: string;
}
export interface OrganizationTeamMemberChannel {
    channel: 'organization-team-member';
    organization: string;
    team?: string;
    member: string;
}
/** Subscription channel for changes in spaces in an organization. */
export interface OrganizationSpacesChannel {
    channel: 'organization-spaces';
    organization: string;
}
/** Subscription channel for changes in collections in an organization. */
export interface OrganizationCollectionsChannel {
    channel: 'organization-collections';
    organization: string;
}
export interface OrganizationIntegrationsChannel {
    channel: 'organization-integrations';
    organization: string;
}
export interface OrganizationInstallationsChannel {
    channel: 'organization-installations';
    organization: string;
}
/** Subscription channel for changes in sites in an organization. */
export interface OrganizationSitesChannel {
    channel: 'organization-sites';
    organization: string;
}
/** Channel for messages everytime a space is indexed by the AI in an organization */
export interface OrganizationAIIndexationChannel {
    channel: 'organization-ai-indexation';
    organization: string;
}
/** Subscription channel for changes in OpenAPI specifications in an organization. */
export interface OrganizationOpenAPISpecsChannel {
    channel: 'organization-openapi-specs';
    organization: string;
}
/** Subscription channel for changes in translation settings in an organization. */
export interface OrganizationTranslationSettingsChannel {
    channel: 'organization-translation-settings';
    organization: string;
}
/** Subscription channel for changes in custom fonts in an organization. */
export interface OrganizationCustomFontsChannel {
    channel: 'organization-fonts';
    organization: string;
}
export interface SpaceCommentsChannel {
    channel: 'space-comments';
    space: string;
}
export interface ChangeRequestCommentsChannel {
    channel: 'space-change-request-comments';
    space: string;
    changeRequest: string;
}
export interface CommentInfoChannel {
    channel: 'space-comment';
    space: string;
    comment: string;
}
export interface CommentReplyInfoChannel {
    channel: 'space-comment-reply';
    space: string;
    comment: string;
    commentReply: string;
}
export interface CommentRepliesChannel {
    channel: 'space-comment-replies';
    space: string;
    comment: string;
}
export interface IntegrationChannel {
    channel: 'integration';
    integration: string;
}
export interface IntegrationInstallationChannel {
    channel: 'integration-installation';
    integration: string;
    installation: string;
}
export interface IntegrationSpaceInstallationChannel {
    channel: 'integration-space-installation';
    integration: string;
    installation: string;
    space: string;
}
export interface IntegrationSpaceInstallationsChannel {
    channel: 'integration-space-installations';
    integration: string;
    installation: string;
}
export interface IntegrationSiteInstallationChannel {
    channel: 'integration-site-installation';
    integration: string;
    installation: string;
    site: string;
}
export interface IntegrationSiteInstallationsChannel {
    channel: 'integration-site-installations';
    integration: string;
    installation: string;
}
export interface PublishedContentSiteChannel {
    channel: 'published-content-site';
    site: string;
}
export interface SiteRedirectsChannel {
    channel: 'site-redirects';
    site: string;
}
export interface SiteChannel {
    channel: 'site';
    site: string;
}
export interface SiteCustomizationChannel {
    channel: 'site-customization';
    site: string;
}
export interface SiteIntegrationsChannel {
    channel: 'site-integrations';
    site: string;
}
export interface SiteSpaceChannel {
    channel: 'site-space';
    site: string;
    siteSpace: string;
}
export interface SiteSpaceCustomizationChannel {
    channel: 'site-space-customization';
    site: string;
    siteSpace: string;
}
/** Subscription channel for changes in site structure in an organization. */
export interface SiteStructureChannel {
    channel: 'site-structure';
    site: string;
}
export interface SiteAdaptiveSchemaChannel {
    channel: 'site-adaptive-schema';
    site: string;
}
export interface SitePublishingAuthChannel {
    channel: 'site-publishing-auth';
    site: string;
}
/** Subscription channel for changes in share links in a site */
export interface SiteShareLinksChannel {
    channel: 'site-share-links';
    site: string;
}
export interface SiteShareLinkChannel {
    channel: 'site-share-link';
    site: string;
    siteShareLink: string;
}
export interface SiteSectionChannel {
    channel: 'site-section';
    site: string;
    siteSection: string;
}
export interface CustomHostnameChannel {
    channel: 'custom-hostname';
    customHostname: string;
}
export interface GitSyncSettingsChannel {
    channel: 'space-gitsync-settings';
    space: string;
}
export interface GitSyncOperationChannel {
    channel: 'space-gitsync-operation';
    space: string;
}
/** Subscription channel for changes in OpenAPI specification. */
export interface OpenAPISpecChannel {
    channel: 'openapi-spec';
    openAPISpec: string;
}
export interface SubdomainChannel {
    channel: 'subdomain';
    subdomain: string;
}
export interface TranslationSettingsChannel {
    channel: 'translation-settings';
    translation: string;
}
/** Subscription channel for an agent task. */
export interface AgentTaskChannel {
    channel: 'agent-task';
    /** The ID of the organization. */
    organization: string;
    /** The ID of the agent task. */
    agentTask: string;
}
/** Subscription channel for agent tasks. */
export interface AgentTasksChannel {
    channel: 'agent-tasks';
    /** The ID of the organization. */
    organization: string;
}
/** Channel to subscribe to for realtime updates. */
export type SubscriptionChannel = SpaceInfoChannel | SpaceContentChannel | SpaceGitInfoChannel | SpacePublishingAuthChannel | SpacePublishingCustomizationChannel | SpaceContentRefsChannel | SpaceIntegrationsChannel | UserAPITokensChannel | UserOrganizationsChannel | UserProfileChannel | ChangeRequestChannel | ChangeRequestsChannel | ChangeRequestReviewsChannel | ChangeRequestContentRefsChannel | CollectionChannel | CollectionPublishingCustomizationChannel | OrganizationInfoChannel | OrganizationInviteLinksChannel | OrganizationMembersChannel | OrganizationMemberChannel | OrganizationSAMLChannel | OrganizationTeamsChannel | OrganizationTeamChannel | OrganizationTeamMembersChannel | OrganizationTeamMemberChannel | OrganizationSpacesChannel | OrganizationCollectionsChannel | OrganizationIntegrationsChannel | OrganizationInstallationsChannel | OrganizationSitesChannel | OrganizationAIIndexationChannel | OrganizationOpenAPISpecsChannel | OrganizationTranslationSettingsChannel | OrganizationCustomFontsChannel | SpaceCommentsChannel | ChangeRequestCommentsChannel | CommentInfoChannel | CommentReplyInfoChannel | CommentRepliesChannel | IntegrationChannel | IntegrationInstallationChannel | IntegrationSpaceInstallationChannel | IntegrationSpaceInstallationsChannel | IntegrationSiteInstallationChannel | IntegrationSiteInstallationsChannel | PublishedContentSiteChannel | SiteRedirectsChannel | SiteChannel | SiteCustomizationChannel | SiteIntegrationsChannel | SiteSpaceChannel | SiteSpaceCustomizationChannel | SiteStructureChannel | SiteAdaptiveSchemaChannel | SitePublishingAuthChannel | SiteShareLinksChannel | SiteShareLinkChannel | SiteSectionChannel | CustomHostnameChannel | GitSyncSettingsChannel | GitSyncOperationChannel | OpenAPISpecChannel | SubdomainChannel | TranslationSettingsChannel | AgentTaskChannel | AgentTasksChannel;
export interface GitSyncOperationChannelData {
    channel: 'space-gitsync-operation';
    data: GitSyncOperation;
}
export interface SpaceContentRefsChannelData {
    channel: 'space-content-refs';
    /** Data passed on the channel messages for content refs indexation. */
    data: {
        /** ID of the latest indexed revision */
        revision: string;
        updatedAt: number;
    };
}
export interface ChangeRequestContentRefsChannelData {
    channel: 'space-change-request-content-refs';
    /** Data passed on the channel messages for content refs indexation. */
    data: {
        /** ID of the latest indexed revision */
        revision: string;
        updatedAt: number;
    };
}
export interface OrganizationAIIndexationChannelData {
    channel: 'organization-ai-indexation';
    data: {
        /** The space that was indexed */
        space: string;
    };
}
export interface APIChannelMutationData {
    channel: '*';
    /** Data passed on the channels associated to API endpoints. */
    data: {
        /** ID of the API execution that triggered the mutation. */
        executionId: string;
    };
}
/** Data passed through a realtime channel */
export type SubscriptionChannelData = GitSyncOperationChannelData | SpaceContentRefsChannelData | ChangeRequestContentRefsChannelData | OrganizationAIIndexationChannelData | APIChannelMutationData;
/** The status of ads on the site */
export declare enum SiteAdsStatus {
    Pending = "pending",
    InReview = "in-review",
    Live = "live",
    Rejected = "rejected",
    Disabled = "disabled"
}
export interface Seat {
    object: 'seat';
    /** The unique ID of the organization */
    organization: string;
    /** The unique ID of the organization member */
    member: string;
    /** @format date-time */
    createdAt: string;
    /** @format date-time */
    updatedAt: string;
}
/** A step in a message from the AI agent. */
export interface AIMessageStep {
    content: JSONDocument;
    reasoning?: JSONDocument;
    toolCalls?: AIToolCall[];
}
export interface AIMessage {
    id: string;
    role: AIMessageRole;
    steps: AIMessageStep[];
}
/** Request to reset the chat. */
export interface AgentRequestReset {
    type: 'reset';
}
/** Request to post a message to the agent. */
export interface AgentRequestPostMessage {
    type: 'post_message';
    /** Input version of an AI message. */
    message: AIMessageInput;
}
/** Payload to send to the agent. */
export type AgentRequest = AgentRequestReset | AgentRequestPostMessage;
/** Payload emitted by the agent to reset the messages. */
export interface AgentStreamMessages {
    type: 'messages';
    operation: 'append' | 'replace';
    messages: AIMessage[];
}
/** Payload emitted by the agent with a partial message. */
export interface AgentStreamMessageResponse {
    type: 'message_response';
    response: AIStreamResponse;
}
export declare enum AgentStatus {
    Idle = "idle",
    Processing = "processing",
    Errored = "errored"
}
export interface AgentState {
    status: AgentStatus;
    /** A list of response suggestions for the user to select from. */
    suggestions: string[];
}
/** Payload emitted by the agent with its current state. */
export interface AgentStreamState {
    type: 'state';
    state: AgentState;
}
export type AgentStream = AgentStreamMessages | AgentStreamMessageResponse | AgentStreamState;
export type RequestSpaceTrackPageView = SpaceTrackPageView;
export type RequestSiteTrackPageView = SiteTrackPageView;
export type RequestPublishIntegration = PublishIntegration;
export type RequestUpdateIntegrationInstallation = UpdateIntegrationInstallation;
export type RequestUpdateIntegrationSpaceInstallation = UpdateIntegrationSpaceInstallation;
export type RequestUpdateIntegrationSiteInstallation = UpdateIntegrationSiteInstallation;
export type RequestUpgradeOrganizationBilling = UpgradeOrganizationBilling;
export type RequestInviteUsersToOrganization = InviteUsersToOrganization;
export type RequestImportGitRepository = ImportGitRepository;
export type RequestExportToGitRepository = ExportToGitRepository;
export type RequestImportContent = ImportContent;
export type RequestCreateSpace = CreateSpace;
export type RequestRenderIntegrationUI = RenderIntegrationUI;
export type RequestUpdateContentPublishingAuth = UpdateContentPublishingAuth;
export type RequestCreateOrganization = CreateOrganization;
export type RequestUpdateSpaceGitInfo = UpdateSpaceGitInfo;
export type RequestPurgeCDNCacheContext = PurgeCDNCacheContext;
export type SpaceVisitorAuth = VisitorAuth;
export type SpaceVisitorAuthCustomBackend = VisitorAuthCustomBackend;
export type SpaceVisitorAuthIntegrationBackend = VisitorAuthIntegrationBackend;
export type UserPermissions = Index;
export type SiteRedirectDestinationSpace = SiteRedirectDestinationSiteSpace;
export type OpenAPISpecSourceURL = URL;
import { EventIterator } from 'event-iterator';
export type QueryParamsType = Record<string | number, any>;
export type ResponseFormat = keyof Omit<Body, 'body' | 'bodyUsed'>;
export interface FullRequestParams extends Omit<RequestInit, 'body'> {
    /** set parameter to `true` for call `securityWorker` for this request */
    secure?: boolean;
    /** request path */
    path: string;
    /** content type of request body */
    type?: ContentType;
    /** query params */
    query?: QueryParamsType;
    /** format of response (i.e. response.json() -> format: "json") */
    format?: ResponseFormat;
    /** request body */
    body?: unknown;
    /** base url */
    baseUrl?: string;
    /** request cancellation token */
    cancelToken?: CancelToken;
}
export type RequestParams = Omit<FullRequestParams, 'body' | 'method' | 'query' | 'path'>;
export interface ApiConfig<SecurityDataType = unknown> {
    baseUrl?: string;
    baseApiParams?: Omit<RequestParams, 'baseUrl' | 'cancelToken' | 'signal'>;
    securityWorker?: (securityData: SecurityDataType | null) => Promise<RequestParams | void> | RequestParams | void;
    customFetch?: typeof fetch;
}
export interface HttpResponse<D extends unknown, E extends unknown = unknown> extends Response {
    data: D;
    error: E;
}
type CancelToken = Symbol | string | number;
export declare enum ContentType {
    Json = "application/json",
    FormData = "multipart/form-data",
    UrlEncoded = "application/x-www-form-urlencoded",
    Text = "text/plain"
}
export declare class HttpClient<SecurityDataType = unknown> {
    baseUrl: string;
    private securityData;
    private securityWorker?;
    private abortControllers;
    private customFetch;
    private baseApiParams;
    constructor(apiConfig?: ApiConfig<SecurityDataType>);
    setSecurityData: (data: SecurityDataType | null) => void;
    protected encodeQueryParam(key: string, value: any): string;
    protected addQueryParam(query: QueryParamsType, key: string): string;
    protected addArrayQueryParam(query: QueryParamsType, key: string): any;
    protected toQueryString(rawQuery?: QueryParamsType): string;
    protected addQueryParams(rawQuery?: QueryParamsType): string;
    private contentFormatters;
    protected mergeRequestParams(params1: RequestParams, params2?: RequestParams): RequestParams;
    protected createAbortSignal: (cancelToken: CancelToken) => AbortSignal | undefined;
    abortRequest: (cancelToken: CancelToken) => void;
    request: <T = any, E = any>({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }: FullRequestParams) => Promise<HttpResponse<T, E>>;
    streamRequest: <T, E = any>({ body, path, type, baseUrl, cancelToken, secure, ...params }: FullRequestParams) => EventIterator<T>;
}
/**
 * @title GitBook API
 * @version 0.0.1-beta
 * @termsOfService https://policies.gitbook.com
 * @baseUrl {host}/v1
 * @contact API Support <support@gitbook.com> (https://gitbook.com/support)
 *
 * The GitBook API
 */
export declare class Api<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
    /**
     * @description Access the release version and build date of the GitBook codebase.
     *
     * @tags system
     * @name GetApiInformation
     * @summary Get API information
     * @request GET:/
     * @secure
     */
    getApiInformation: (params?: RequestParams) => Promise<HttpResponse<ApiInformation, any>>;
    user: {
        /**
         * @description Returns details about the user associated with the authentication provided in the request's authorization header.
         *
         * @tags users
         * @name GetAuthenticatedUser
         * @summary Get profile of authenticated user
         * @request GET:/user
         * @secure
         */
        getAuthenticatedUser: (params?: RequestParams) => Promise<HttpResponse<User, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
    };
    users: {
        /**
         * @description Provides publicly available information about someone with a GitBook account.
         *
         * @tags users, critical
         * @name GetUserById
         * @summary Get a user by its ID
         * @request GET:/users/{userId}
         * @secure
         */
        getUserById: (userId: string, params?: RequestParams) => Promise<HttpResponse<User, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * @description Update a GitBook account's details.
         *
         * @tags users, critical
         * @name UpdateUserById
         * @summary Update a user by its ID
         * @request PATCH:/users/{userId}
         * @secure
         */
        updateUserById: (userId: string, data: {
            /**
             * Full name for the user
             * @minLength 1
             * @maxLength 64
             */
            displayName?: string;
            photoURL?: URL;
        }, params?: RequestParams) => Promise<HttpResponse<User, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
    };
    spaces: {
        /**
         * No description
         *
         * @tags spaces, critical
         * @name GetSpaceById
         * @summary Get a space by its ID
         * @request GET:/spaces/{spaceId}
         * @secure
         */
        getSpaceById: (spaceId: string, query?: {
            /** For sites published via share-links, the share key is useful to resolve published URLs. */
            shareKey?: string;
        }, params?: RequestParams) => Promise<HttpResponse<Space, any>>;
        /**
         * No description
         *
         * @tags spaces
         * @name UpdateSpaceById
         * @summary Update a space
         * @request PATCH:/spaces/{spaceId}
         * @secure
         */
        updateSpaceById: (spaceId: string, data: {
            /**
             * Determines how a Space can be edited.
             * * `live`: Users can directly edit the space
             * * `locked`: All edits are locked for this space.
             */
            editMode?: SpaceEditMode;
            /** Title of the space */
            title?: SpaceTitle;
            /** Default level for a piece of content */
            defaultLevel?: DefaultLevel;
        } & ({
            /** Unicode codepoint or character of the emoji */
            emoji: Emoji;
        } | {
            icon: URL;
        } | {
            emoji?: null;
            icon?: null;
        }), params?: RequestParams) => Promise<HttpResponse<Space, any>>;
        /**
         * @description Deleted spaces will be permanently removed after 7 days.
         *
         * @tags spaces
         * @name DeleteSpaceById
         * @summary Delete a space
         * @request DELETE:/spaces/{spaceId}
         * @secure
         */
        deleteSpaceById: (spaceId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags spaces
         * @name DuplicateSpace
         * @summary Duplicate a space
         * @request POST:/spaces/{spaceId}/duplicate
         * @secure
         */
        duplicateSpace: (spaceId: string, params?: RequestParams) => Promise<HttpResponse<Space, any>>;
        /**
         * @description Only spaces deleted in the last 7 days can be restored.
         *
         * @tags spaces
         * @name RestoreSpace
         * @summary Restore a deleted space
         * @request POST:/spaces/{spaceId}/restore
         * @secure
         */
        restoreSpace: (spaceId: string, params?: RequestParams) => Promise<HttpResponse<Space, any>>;
        /**
         * No description
         *
         * @tags spaces
         * @name MoveSpace
         * @summary Move a space to a new position
         * @request POST:/spaces/{spaceId}/move
         * @secure
         */
        moveSpace: (spaceId: string, data: {
            /** The unique id of the parent collection */
            parent?: string | null;
            /** Where to move the space. By default, it will be moved at the end. */
            position?: ContentPosition;
        }, params?: RequestParams) => Promise<HttpResponse<Space, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 409;
                message: string;
            };
        }>>;
        /**
         * @description Transfer a space to another organization, collection or both.
         *
         * @tags spaces
         * @name TransferSpace
         * @summary Transfer a space
         * @request POST:/spaces/{spaceId}/transfer
         * @secure
         */
        transferSpace: (spaceId: string, data: {
            /** The unique id of the target organization */
            organization: string;
        }, params?: RequestParams) => Promise<HttpResponse<Space, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 409;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 412;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-embeds
         * @name GetEmbedByUrlInSpace
         * @summary Resolve a URL to an embed in a given space
         * @request GET:/spaces/{spaceId}/embed
         * @secure
         */
        getEmbedByUrlInSpace: (spaceId: string, query: {
            /** URL to resolve */
            url: string;
        }, params?: RequestParams) => Promise<HttpResponse<Embed, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name SearchSpaceContent
         * @summary Search content in a space
         * @request GET:/spaces/{spaceId}/search
         * @secure
         */
        searchSpaceContent: (spaceId: string, query: {
            /** @maxLength 512 */
            query: string;
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SearchPageResult[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-git
         * @name ImportGitRepository
         * @summary Import a Git repository
         * @request POST:/spaces/{spaceId}/git/import
         * @secure
         */
        importGitRepository: (spaceId: string, data: ImportGitRepository, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags space-git
         * @name ExportToGitRepository
         * @summary Export the to a Git repository
         * @request POST:/spaces/{spaceId}/git/export
         * @secure
         */
        exportToGitRepository: (spaceId: string, data: ExportToGitRepository, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * @description Get metadata about the Git Sync provider currently set up on the space.
         *
         * @tags space-git
         * @name GetSpaceGitInfo
         * @summary Get space Git info
         * @request GET:/spaces/{spaceId}/git/info
         * @secure
         */
        getSpaceGitInfo: (spaceId: string, params?: RequestParams) => Promise<HttpResponse<GitSyncState, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-users, space-teams
         * @name InviteToSpace
         * @summary Invite a user or a team to a space
         * @request POST:/spaces/{spaceId}/permissions
         * @secure
         */
        inviteToSpace: (spaceId: string, data: InviteUsersAndTeams, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-teams
         * @name UpdateTeamPermissionInSpace
         * @summary Update a space team permission
         * @request PATCH:/spaces/{spaceId}/permissions/teams/{teamId}
         * @secure
         */
        updateTeamPermissionInSpace: (spaceId: string, teamId: string, data: {
            /** The role of a member in an organization, null for guests */
            role?: MemberRoleOrGuest;
        }, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-teams
         * @name RemoveTeamFromSpace
         * @summary Remove a space team
         * @request DELETE:/spaces/{spaceId}/permissions/teams/{teamId}
         * @secure
         */
        removeTeamFromSpace: (spaceId: string, teamId: string, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-users
         * @name ListUserPermissionsInSpace
         * @summary List space user permissions
         * @request GET:/spaces/{spaceId}/permissions/users
         * @secure
         */
        listUserPermissionsInSpace: (spaceId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: UserContentPermission[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-users
         * @name UpdateUserPermissionInSpace
         * @summary Update space user permissions
         * @request PATCH:/spaces/{spaceId}/permissions/users/{userId}
         * @secure
         */
        updateUserPermissionInSpace: (spaceId: string, userId: string, data: {
            /** The role of a member in an organization, null for guests */
            role?: MemberRoleOrGuest;
        }, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-users
         * @name RemoveUserFromSpace
         * @summary Remove a space user
         * @request DELETE:/spaces/{spaceId}/permissions/users/{userId}
         * @secure
         */
        removeUserFromSpace: (spaceId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-teams
         * @name ListTeamPermissionsInSpace
         * @summary List space team persmissions
         * @request GET:/spaces/{spaceId}/permissions/teams
         * @secure
         */
        listTeamPermissionsInSpace: (spaceId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: {
                /**
                 * "The role of a member in an organization.
                 * "admin": Can administrate the content: create, delete spaces, ...
                 * "create": Can create content.
                 * "review": Can review content.
                 * "edit": Can edit the content (live or change requests).
                 * "comment": Can access the content and its discussions.
                 * "read": Can access the content, but cannot update it in any way.
                 */
                permission: MemberRole;
                team: OrganizationTeam;
            }[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetCurrentRevision
         * @summary Get a space current revision
         * @request GET:/spaces/{spaceId}/content
         * @secure
         */
        getCurrentRevision: (spaceId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<Revision, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name ImportContent
         * @summary Import content in a space
         * @request POST:/spaces/{spaceId}/content/import
         * @secure
         */
        importContent: (spaceId: string, data: ImportContent, params?: RequestParams) => Promise<HttpResponse<ImportContentResult, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name ListPages
         * @summary List all space pages
         * @request GET:/spaces/{spaceId}/content/pages
         * @secure
         */
        listPages: (spaceId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<{
            pages: RevisionPage[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name ListFiles
         * @summary List all space files
         * @request GET:/spaces/{spaceId}/content/files
         * @secure
         */
        listFiles: (spaceId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: RevisionFile[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetFileById
         * @summary Get a space file by its ID
         * @request GET:/spaces/{spaceId}/content/files/{fileId}
         * @secure
         */
        getFileById: (spaceId: string, fileId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionFile, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name ListSpaceFileBacklinks
         * @summary List all space file backlink locations
         * @request GET:/spaces/{spaceId}/content/files/{fileId}/backlinks
         * @secure
         */
        listSpaceFileBacklinks: (spaceId: string, fileId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: ContentLocation[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetPageById
         * @summary Get a space page by its ID
         * @request GET:/spaces/{spaceId}/content/page/{pageId}
         * @secure
         */
        getPageById: (spaceId: string, pageId: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
            /**
             * If `true` is passed, the document will be evaluated
             * @default false
             */
            evaluated?: boolean;
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPage, any>>;
        /**
         * No description
         *
         * @tags space-content, links, critical
         * @name ListPageLinksInSpace
         * @summary List all space page links
         * @request GET:/spaces/{spaceId}/content/page/{pageId}/links
         * @secure
         */
        listPageLinksInSpace: (spaceId: string, pageId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * Text to display to represent the reference. Possible values include:
             * - `ok` - No problems detected for this content reference.
             * - `broken` - The target does not exist in the revision.
             * - `in-app` - The target is a URL link pointing to an internal location in the app.
             */
            status?: ContentReferenceStatus;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            stats: ContentReferencesStats;
            items: ContentReferenceUsage[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name ListSpacePageBacklinks
         * @summary List all space page backlink locations
         * @request GET:/spaces/{spaceId}/content/page/{pageId}/backlinks
         * @secure
         */
        listSpacePageBacklinks: (spaceId: string, pageId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: ContentLocation[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name ImportContentInPageById
         * @summary Import content into a space page
         * @request POST:/spaces/{spaceId}/content/page/{pageId}/import
         * @secure
         */
        importContentInPageById: (spaceId: string, pageId: string, data: ImportContent, params?: RequestParams) => Promise<HttpResponse<ImportContentResult, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetPageByPath
         * @summary Get a space page by its path
         * @request GET:/spaces/{spaceId}/content/path/{pagePath}
         * @secure
         */
        getPageByPath: (spaceId: string, pagePath: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
            /**
             * If `true` is passed, the document will be evaluated
             * @default false
             */
            evaluated?: boolean;
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPageDocument | RevisionPageGroup, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetReusableContentById
         * @summary Get a space reusable content by its ID
         * @request GET:/spaces/{spaceId}/content/reusable-contents/{reusableContentId}
         * @secure
         */
        getReusableContentById: (spaceId: string, reusableContentId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionReusableContent, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetComputedDocument
         * @summary Get a space computed document
         * @request POST:/spaces/{spaceId}/content/computed/document
         * @secure
         */
        getComputedDocument: (spaceId: string, data: {
            source: ComputedContentSourceDocument;
            /** Seed to use for the generation of IDs. */
            seed: string;
        }, query?: {
            /** Version of the schema used for the document. */
            schema?: "current" | "next";
        }, params?: RequestParams) => Promise<HttpResponse<JSONDocument, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetComputedRevision
         * @summary Get a space computed revision
         * @request POST:/spaces/{spaceId}/content/computed/revision
         * @secure
         */
        getComputedRevision: (spaceId: string, data: {
            source: ComputedContentSourceRevision;
            /** Seed to use for the generation of IDs. */
            seed: string;
        }, params?: RequestParams) => Promise<HttpResponse<{
            pages: RevisionPage[];
            files: RevisionFile[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetDocumentById
         * @summary Get a space document by its ID
         * @request GET:/spaces/{spaceId}/documents/{documentId}
         * @secure
         */
        getDocumentById: (spaceId: string, documentId: string, query?: {
            /** Version of the schema used for the document. */
            schema?: "current" | "next";
        }, params?: RequestParams) => Promise<HttpResponse<JSONDocument, any>>;
        /**
         * No description
         *
         * @tags change-requests
         * @name CreateChangeRequest
         * @summary Create a change request
         * @request POST:/spaces/{spaceId}/change-requests
         * @secure
         */
        createChangeRequest: (spaceId: string, data: {
            /** Subject of the change-request */
            subject?: string;
            /** ID of the agent task to implement */
            agentTaskId?: string;
        }, params?: RequestParams) => Promise<HttpResponse<ChangeRequest, any>>;
        /**
         * No description
         *
         * @tags change-requests
         * @name ListChangeRequestsForSpace
         * @summary List all change requests
         * @request GET:/spaces/{spaceId}/change-requests
         * @secure
         */
        listChangeRequestsForSpace: (spaceId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * If defined, only change requests matching this status will be returned.
             * @default "open"
             */
            status?: ChangeRequestStatus;
            /** If defined, only change requests with contributions from this user will be returned. */
            contributor?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: ChangeRequest[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-requests
         * @name GetChangeRequestById
         * @summary Get a change request by its ID
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}
         * @secure
         */
        getChangeRequestById: (spaceId: string, changeRequestId: string, params?: RequestParams) => Promise<HttpResponse<ChangeRequest, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags change-requests
         * @name UpdateChangeRequestById
         * @summary Update a change request
         * @request PATCH:/spaces/{spaceId}/change-requests/{changeRequestId}
         * @secure
         */
        updateChangeRequestById: (spaceId: string, changeRequestId: string, data: {
            /** Subject of the change request */
            subject?: ChangeRequestSubject;
            status?: "draft" | "open" | "archived";
        }, params?: RequestParams) => Promise<HttpResponse<ChangeRequest, any>>;
        /**
         * No description
         *
         * @tags change-requests
         * @name MergeChangeRequest
         * @summary Merge a change request
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/merge
         * @secure
         */
        mergeChangeRequest: (spaceId: string, changeRequestId: string, params?: RequestParams) => Promise<HttpResponse<{
            /** ID of the resulting revision */
            revision: string;
            result: "merge" | "conflicts";
        }, any>>;
        /**
         * No description
         *
         * @tags change-requests
         * @name UpdateChangeRequest
         * @summary Pull primary content into the change request
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/update
         * @secure
         */
        updateChangeRequest: (spaceId: string, changeRequestId: string, params?: RequestParams) => Promise<HttpResponse<{
            /** ID of the resulting revision */
            revision: string;
            result: "update" | "conflicts";
        }, any>>;
        /**
         * No description
         *
         * @tags change-requests-reviews
         * @name GetReviewsByChangeRequestId
         * @summary List all change request reviews
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/reviews
         * @secure
         */
        getReviewsByChangeRequestId: (spaceId: string, changeRequestId: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: ChangeRequestReview[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags change-requests-reviews
         * @name SubmitChangeRequestReview
         * @summary Submit a change request review
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/reviews
         * @secure
         */
        submitChangeRequestReview: (spaceId: string, changeRequestId: string, data: {
            /** The status of the submitted review. */
            status: ChangeRequestReviewStatus;
            /** Optionally, provide a comment along with the review. */
            comment?: Document;
        }, params?: RequestParams) => Promise<HttpResponse<ChangeRequestReview, any>>;
        /**
         * No description
         *
         * @tags change-request-reviewers
         * @name GetRequestedReviewersByChangeRequestId
         * @summary Get all change request reviewers
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/requested-reviewers
         * @secure
         */
        getRequestedReviewersByChangeRequestId: (spaceId: string, changeRequestId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: ChangeRequestRequestedReviewer[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-request-reviewers
         * @name RequestReviewersForChangeRequest
         * @summary Request change request reviewers
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/requested-reviewers
         * @secure
         */
        requestReviewersForChangeRequest: (spaceId: string, changeRequestId: string, data: {
            /** An array of user ids that will be requested. */
            users: string[];
            /** Optionally, update the subject of the change request when requesting reviewers. */
            subject?: string;
        }, params?: RequestParams) => Promise<HttpResponse<{
            /** The user requests that were sent. */
            users?: ChangeRequestRequestedReviewer[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-request-reviewers
         * @name RemoveRequestedReviewerFromChangeRequest
         * @summary Remove a reviewer from a change request
         * @request DELETE:/spaces/{spaceId}/change-requests/{changeRequestId}/requested-reviewers/{userId}
         * @secure
         */
        removeRequestedReviewerFromChangeRequest: (spaceId: string, changeRequestId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags change-requests-links, links, critical
         * @name ListChangeRequestLinks
         * @summary List all change request links
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/links
         * @secure
         */
        listChangeRequestLinks: (spaceId: string, changeRequestId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * Text to display to represent the reference. Possible values include:
             * - `ok` - No problems detected for this content reference.
             * - `broken` - The target does not exist in the revision.
             * - `in-app` - The target is a URL link pointing to an internal location in the app.
             */
            status?: ContentReferenceStatus;
            brokenContext?: "change-request" | "space";
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            stats: ContentReferencesStats;
            items: ContentReferenceUsage[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags change-request-comments
         * @name ListCommentsInChangeRequest
         * @summary List all change request comments
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/comments
         * @secure
         */
        listCommentsInChangeRequest: (spaceId: string, changeRequestId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * An order for the items in the list
             * @default "desc"
             */
            order?: "asc" | "desc";
            /** Output format for the content. */
            format?: "document" | "markdown";
            /**
             * When provided, only comments with the given status are returned. Defaults to "all".
             * @default "all"
             */
            status?: "all" | "open" | "resolved";
            /** The target page of the comment */
            targetPage?: string;
            /** User IDs to filter queried comments on */
            authors?: string[];
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Comment[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-request-comments
         * @name PostCommentInChangeRequest
         * @summary Create a change request comment
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/comments
         * @secure
         */
        postCommentInChangeRequest: (spaceId: string, changeRequestId: string, data: PostCommentSchema, params?: RequestParams) => Promise<HttpResponse<Comment, any>>;
        /**
         * No description
         *
         * @tags change-request-comments
         * @name GetCommentInChangeRequest
         * @summary Get a change request comment
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}
         * @secure
         */
        getCommentInChangeRequest: (spaceId: string, changeRequestId: string, commentId: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
        }, params?: RequestParams) => Promise<HttpResponse<Comment, any>>;
        /**
         * No description
         *
         * @tags change-request-comments
         * @name DeleteCommentInChangeRequest
         * @summary Delete a change request comment
         * @request DELETE:/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}
         * @secure
         */
        deleteCommentInChangeRequest: (spaceId: string, changeRequestId: string, commentId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags change-request-comments
         * @name UpdateCommentInChangeRequest
         * @summary Update a change request comment
         * @request PUT:/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}
         * @secure
         */
        updateCommentInChangeRequest: (spaceId: string, changeRequestId: string, commentId: string, data: UpdateCommentSchema, params?: RequestParams) => Promise<HttpResponse<Comment, any>>;
        /**
         * No description
         *
         * @tags change-request-comments
         * @name ListCommentRepliesInChangeRequest
         * @summary List all change request comment replies
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}/replies
         * @secure
         */
        listCommentRepliesInChangeRequest: (spaceId: string, changeRequestId: string, commentId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** Output format for the content. */
            format?: "document" | "markdown";
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: CommentReply[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-request-comments
         * @name PostCommentReplyInChangeRequest
         * @summary Create a change request comment reply
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}/replies
         * @secure
         */
        postCommentReplyInChangeRequest: (spaceId: string, changeRequestId: string, commentId: string, data: PostCommentReplySchema, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
        }, params?: RequestParams) => Promise<HttpResponse<CommentReply, any>>;
        /**
         * No description
         *
         * @tags change-request-comments
         * @name GetCommentReplyInChangeRequest
         * @summary Get a change request comment reply
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}/replies/{commentReplyId}
         * @secure
         */
        getCommentReplyInChangeRequest: (spaceId: string, changeRequestId: string, commentId: string, commentReplyId: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
        }, params?: RequestParams) => Promise<HttpResponse<CommentReply, any>>;
        /**
         * No description
         *
         * @tags change-request-comments
         * @name UpdateCommentReplyInChangeRequest
         * @summary Update a change request comment reply
         * @request PUT:/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}/replies/{commentReplyId}
         * @secure
         */
        updateCommentReplyInChangeRequest: (spaceId: string, changeRequestId: string, commentId: string, commentReplyId: string, data: UpdateCommentSchema, params?: RequestParams) => Promise<HttpResponse<CommentReply, any>>;
        /**
         * No description
         *
         * @tags change-request-comments
         * @name DeleteCommentReplyInChangeRequest
         * @summary Delete a change request comment reply
         * @request DELETE:/spaces/{spaceId}/change-requests/{changeRequestId}/comments/{commentId}/replies/{commentReplyId}
         * @secure
         */
        deleteCommentReplyInChangeRequest: (spaceId: string, changeRequestId: string, commentId: string, commentReplyId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags change-request-contributors
         * @name GetContributorsByChangeRequestId
         * @summary Get all contribors of a change request
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/contributors
         * @secure
         */
        getContributorsByChangeRequestId: (spaceId: string, changeRequestId: string, params?: RequestParams) => Promise<HttpResponse<List & {
            items: UserContributor[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name GetRevisionOfChangeRequestById
         * @summary Get a change request the latest content revision
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content
         * @secure
         */
        getRevisionOfChangeRequestById: (spaceId: string, changeRequestId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<Revision, any>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name ImportContentInChangeRequest
         * @summary Import content in a change request
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/content/import
         * @secure
         */
        importContentInChangeRequest: (spaceId: string, changeRequestId: string, data: ImportContent, params?: RequestParams) => Promise<HttpResponse<ImportContentResult, any>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name ListPagesInChangeRequest
         * @summary List all change request pages
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/pages
         * @secure
         */
        listPagesInChangeRequest: (spaceId: string, changeRequestId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<{
            pages: RevisionPage[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name ListFilesInChangeRequestById
         * @summary List all change request files
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/files
         * @secure
         */
        listFilesInChangeRequestById: (spaceId: string, changeRequestId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: RevisionFile[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name GetFileInChangeRequestById
         * @summary Get a change request file by its ID
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/files/{fileId}
         * @secure
         */
        getFileInChangeRequestById: (spaceId: string, changeRequestId: string, fileId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionFile, any>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name ListChangeRequestFileBacklinks
         * @summary List all backlink locations of a change request file
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/files/{fileId}/backlinks
         * @secure
         */
        listChangeRequestFileBacklinks: (spaceId: string, changeRequestId: string, fileId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: ContentLocation[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name GetPageInChangeRequestById
         * @summary Get a change request page by its ID
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/page/{pageId}
         * @secure
         */
        getPageInChangeRequestById: (spaceId: string, changeRequestId: string, pageId: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
            /**
             * If `true` is passed, the document will be evaluated
             * @default false
             */
            evaluated?: boolean;
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPage, any>>;
        /**
         * No description
         *
         * @tags change-request-content, critical
         * @name ListPageLinksInChangeRequest
         * @summary List all change request links
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/page/{pageId}/links
         * @secure
         */
        listPageLinksInChangeRequest: (spaceId: string, changeRequestId: string, pageId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            stats: ContentReferencesStats;
            items: ContentReferenceUsage[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name ListChangeRequestPageBacklinks
         * @summary List all backlink locations of a change request page
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/page/{pageId}/backlinks
         * @secure
         */
        listChangeRequestPageBacklinks: (spaceId: string, changeRequestId: string, pageId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: ContentLocation[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name ImportContentInChangeRequestPageById
         * @summary Import content into a change request page
         * @request POST:/spaces/{spaceId}/change-requests/{changeRequestId}/content/page/{pageId}/import
         * @secure
         */
        importContentInChangeRequestPageById: (spaceId: string, changeRequestId: string, pageId: string, data: ImportContent, params?: RequestParams) => Promise<HttpResponse<ImportContentResult, any>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name GetPageInChangeRequestByPath
         * @summary Get a change request page by its path
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/path/{pagePath}
         * @secure
         */
        getPageInChangeRequestByPath: (spaceId: string, changeRequestId: string, pagePath: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
            /**
             * If `true` is passed, the document will be evaluated
             * @default false
             */
            evaluated?: boolean;
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPageDocument | RevisionPageGroup, any>>;
        /**
         * No description
         *
         * @tags change-request-content
         * @name GetReusableContentInChangeRequestById
         * @summary Get a change request reusable content by its ID
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/content/reusable-contents/{reusableContentId}
         * @secure
         */
        getReusableContentInChangeRequestById: (spaceId: string, changeRequestId: string, reusableContentId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionReusableContent, any>>;
        /**
         * No description
         *
         * @tags change-requests
         * @name GetChangeRequestPdf
         * @summary Get a URL of the content of a change request as PDF
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/pdf
         * @secure
         */
        getChangeRequestPdf: (spaceId: string, changeRequestId: string, query?: {
            /** Generate a PDF only for the provided page. */
            only?: boolean;
            /** ID of a specific page to generate a PDF for. */
            page?: string;
        }, params?: RequestParams) => Promise<HttpResponse<{
            /** Temporary URL to print the content. The URL will work for 1h. */
            url: URL;
        }, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetRevisionById
         * @summary Get a space revision
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}
         * @secure
         */
        getRevisionById: (spaceId: string, revisionId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<Revision, any>>;
        /**
         * @description Return the semantic changes between a revision and its parent.
         *
         * @tags space-content
         * @name GetRevisionSemanticChanges
         * @summary Get space revision semantic changes
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/changes
         * @secure
         */
        getRevisionSemanticChanges: (spaceId: string, revisionId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
            /**
             * Limit the number of changes returned
             * @default 10
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionSemanticChanges, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name ListPagesInRevisionById
         * @summary List all pages in a space revision
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/pages
         * @secure
         */
        listPagesInRevisionById: (spaceId: string, revisionId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<{
            pages: RevisionPage[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name ListFilesInRevisionById
         * @summary List all space revision files
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/files
         * @secure
         */
        listFilesInRevisionById: (spaceId: string, revisionId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: RevisionFile[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetFileInRevisionById
         * @summary Get a space revision file by its ID
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/files/{fileId}
         * @secure
         */
        getFileInRevisionById: (spaceId: string, revisionId: string, fileId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionFile, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetPageInRevisionById
         * @summary Get a space revision page by its ID
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/page/{pageId}
         * @secure
         */
        getPageInRevisionById: (spaceId: string, revisionId: string, pageId: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
            /**
             * If `true` is passed, the document will be evaluated
             * @default false
             */
            evaluated?: boolean;
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPage, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetPageDocumentInRevisionById
         * @summary Get the document of a page in a revision
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/page/{pageId}/document
         * @secure
         */
        getPageDocumentInRevisionById: (spaceId: string, revisionId: string, pageId: string, query?: {
            /**
             * If `true` is passed, the document will be evaluated
             * @default false
             */
            evaluated?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<JSONDocument, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetPageInRevisionByPath
         * @summary Get a space revision page by its path
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/path/{pagePath}
         * @secure
         */
        getPageInRevisionByPath: (spaceId: string, revisionId: string, pagePath: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
            /**
             * If `true` is passed, the document will be evaluated
             * @default false
             */
            evaluated?: boolean;
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionPageDocument | RevisionPageGroup, any>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetReusableContentInRevisionById
         * @summary Get a space revision reusable content by its ID
         * @request GET:/spaces/{spaceId}/revisions/{revisionId}/reusable-contents/{reusableContentId}
         * @secure
         */
        getReusableContentInRevisionById: (spaceId: string, revisionId: string, reusableContentId: string, query?: {
            /**
             * If `false` is passed, "git" mutable metadata will not returned. Passing `false` can optimize performances of the lookup.
             * @default true
             */
            metadata?: boolean;
            /**
             * If `false` is passed, content will not be computed
             * @default true
             */
            computed?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<RevisionReusableContent, any>>;
        /**
         * No description
         *
         * @tags space-comments, critical
         * @name ListCommentsInSpace
         * @summary List all space comments
         * @request GET:/spaces/{spaceId}/comments
         * @secure
         */
        listCommentsInSpace: (spaceId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * An order for the items in the list
             * @default "desc"
             */
            order?: "asc" | "desc";
            /**
             * When provided, only comments with the given status are returned. Defaults to "all".
             * @default "all"
             */
            status?: "all" | "open" | "resolved";
            /** Output format for the content. */
            format?: "document" | "markdown";
            /** The target page of the comment */
            targetPage?: string;
            /** User IDs to filter queried comments on */
            authors?: string[];
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Comment[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-comments
         * @name PostCommentInSpace
         * @summary Create a space comment
         * @request POST:/spaces/{spaceId}/comments
         * @secure
         */
        postCommentInSpace: (spaceId: string, data: PostCommentSchema, params?: RequestParams) => Promise<HttpResponse<Comment, any>>;
        /**
         * No description
         *
         * @tags space-comments
         * @name GetCommentInSpace
         * @summary Get a space comment
         * @request GET:/spaces/{spaceId}/comments/{commentId}
         * @secure
         */
        getCommentInSpace: (spaceId: string, commentId: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
        }, params?: RequestParams) => Promise<HttpResponse<Comment, any>>;
        /**
         * No description
         *
         * @tags space-comments
         * @name DeleteCommentInSpace
         * @summary Delete a space comment
         * @request DELETE:/spaces/{spaceId}/comments/{commentId}
         * @secure
         */
        deleteCommentInSpace: (spaceId: string, commentId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags space-comments
         * @name UpdateCommentInSpace
         * @summary Update a space comment
         * @request PUT:/spaces/{spaceId}/comments/{commentId}
         * @secure
         */
        updateCommentInSpace: (spaceId: string, commentId: string, data: UpdateCommentSchema, params?: RequestParams) => Promise<HttpResponse<Comment, any>>;
        /**
         * No description
         *
         * @tags space-comment
         * @name ListCommentRepliesInSpace
         * @summary List all space comment replies
         * @request GET:/spaces/{spaceId}/comments/{commentId}/replies
         * @secure
         */
        listCommentRepliesInSpace: (spaceId: string, commentId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** Output format for the content. */
            format?: "document" | "markdown";
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: CommentReply[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-comments
         * @name PostCommentReplyInSpace
         * @summary Create a space comment reply
         * @request POST:/spaces/{spaceId}/comments/{commentId}/replies
         * @secure
         */
        postCommentReplyInSpace: (spaceId: string, commentId: string, data: PostCommentReplySchema, params?: RequestParams) => Promise<HttpResponse<CommentReply, any>>;
        /**
         * No description
         *
         * @tags space-comments
         * @name GetCommentReplyInSpace
         * @summary Get a space comment reply
         * @request GET:/spaces/{spaceId}/comments/{commentId}/replies/{commentReplyId}
         * @secure
         */
        getCommentReplyInSpace: (spaceId: string, commentId: string, commentReplyId: string, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
        }, params?: RequestParams) => Promise<HttpResponse<CommentReply, any>>;
        /**
         * No description
         *
         * @tags space-comments
         * @name UpdateCommentReplyInSpace
         * @summary Update a space comment reply
         * @request PUT:/spaces/{spaceId}/comments/{commentId}/replies/{commentReplyId}
         * @secure
         */
        updateCommentReplyInSpace: (spaceId: string, commentId: string, commentReplyId: string, data: UpdateCommentReplySchema, params?: RequestParams) => Promise<HttpResponse<CommentReply, any>>;
        /**
         * No description
         *
         * @tags space-comments
         * @name DeleteCommentReplyInSpace
         * @summary Delete a space comment reply
         * @request DELETE:/spaces/{spaceId}/comments/{commentId}/replies/{commentReplyId}
         * @secure
         */
        deleteCommentReplyInSpace: (spaceId: string, commentId: string, commentReplyId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags space-comments, critical
         * @name ListCommentersInSpace
         * @summary List all users who commented in a space
         * @request GET:/spaces/{spaceId}/commenters
         * @secure
         */
        listCommentersInSpace: (spaceId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OrganizationMember[];
        }, any>>;
        /**
         * No description
         *
         * @tags change-request-comments, critical
         * @name ListCommentersInChangeRequest
         * @summary List all users who commented in a CR
         * @request GET:/spaces/{spaceId}/change-requests/{changeRequestId}/commenters
         * @secure
         */
        listCommentersInChangeRequest: (spaceId: string, changeRequestId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OrganizationMember[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-users
         * @name ListPermissionsAggregateInSpace
         * @summary List all space users permissions
         * @request GET:/spaces/{spaceId}/permissions/aggregate
         * @secure
         */
        listPermissionsAggregateInSpace: (spaceId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** If defined, only members with this role will be returned. */
            role?: MemberRole;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: UserContentPermission[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-integrations
         * @name ListSpaceIntegrations
         * @summary List integrations enabled in a space
         * @request GET:/spaces/{spaceId}/integrations
         * @secure
         */
        listSpaceIntegrations: (spaceId: string, query?: {
            /** A search string to filter integrations by name */
            search?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Integration[];
        }, any>>;
        /**
         * No description
         *
         * @tags space-integrations
         * @name ListSpaceIntegrationsBlocks
         * @summary List all space integrations blocks
         * @request GET:/spaces/{spaceId}/integration-blocks
         * @secure
         */
        listSpaceIntegrationsBlocks: (spaceId: string, params?: RequestParams) => Promise<HttpResponse<SpaceIntegrationBlocks, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-integrations
         * @name ListSpaceIntegrationScripts
         * @summary List all the scripts to embed in published content for a space
         * @request GET:/spaces/{spaceId}/integration-scripts
         * @secure
         */
        listSpaceIntegrationScripts: (spaceId: string, params?: RequestParams) => Promise<HttpResponse<SpaceIntegrationScript[], {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags space-content
         * @name GetSpacePdf
         * @summary Get a URL of the content of a space as PDF
         * @request GET:/spaces/{spaceId}/pdf
         * @secure
         */
        getSpacePdf: (spaceId: string, query?: {
            /** Generate a PDF only for the provided page. */
            only?: boolean;
            /** ID of a specific page to generate a PDF for. */
            page?: string;
        }, params?: RequestParams) => Promise<HttpResponse<{
            /** Temporary URL to print the content. The URL will work for 1h. */
            url: URL;
        }, any>>;
        /**
         * No description
         *
         * @tags spaces, links, critical
         * @name ListSpaceLinks
         * @summary Get all links in a space including their status and location where they appear.
         * @request GET:/spaces/{spaceId}/links
         * @secure
         */
        listSpaceLinks: (spaceId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * Text to display to represent the reference. Possible values include:
             * - `ok` - No problems detected for this content reference.
             * - `broken` - The target does not exist in the revision.
             * - `in-app` - The target is a URL link pointing to an internal location in the app.
             */
            status?: ContentReferenceStatus;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            stats: ContentReferencesStats;
            items: ContentReferenceUsage[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
    };
    collections: {
        /**
         * No description
         *
         * @tags collections
         * @name GetCollectionById
         * @summary Get a collection by its ID
         * @request GET:/collections/{collectionId}
         * @secure
         */
        getCollectionById: (collectionId: string, params?: RequestParams) => Promise<HttpResponse<Collection, any>>;
        /**
         * No description
         *
         * @tags collections
         * @name UpdateCollectionById
         * @summary Update a collection
         * @request PATCH:/collections/{collectionId}
         * @secure
         */
        updateCollectionById: (collectionId: string, data: {
            /** Title of the collection */
            title?: CollectionTitle;
            /** Description of the collection */
            description?: CollectionDescription;
            /** Default level for a piece of content */
            defaultLevel?: DefaultLevel;
        }, params?: RequestParams) => Promise<HttpResponse<Collection, any>>;
        /**
         * No description
         *
         * @tags collections
         * @name DeleteCollectionById
         * @summary Delete a collection
         * @request DELETE:/collections/{collectionId}
         * @secure
         */
        deleteCollectionById: (collectionId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags collections
         * @name ListSpacesInCollectionById
         * @summary List all collection spaces
         * @request GET:/collections/{collectionId}/spaces
         * @secure
         */
        listSpacesInCollectionById: (collectionId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Space[];
        }, any>>;
        /**
         * No description
         *
         * @tags collections
         * @name MoveCollection
         * @summary Move a collection to a new position.
         * @request POST:/collections/{collectionId}/move
         * @secure
         */
        moveCollection: (collectionId: string, data: {
            /** The unique id of the parent collection */
            parent?: string | null;
            /** Where to move the collection. By default, it will be moved at the end. */
            position?: ContentPosition;
        }, params?: RequestParams) => Promise<HttpResponse<Collection, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 409;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags collections
         * @name TransferCollection
         * @summary Transfer a collection
         * @request POST:/collections/{collectionId}/transfer
         * @secure
         */
        transferCollection: (collectionId: string, data: {
            /** The unique id of the target organization */
            organization: string;
        }, params?: RequestParams) => Promise<HttpResponse<Collection, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 409;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 412;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags collection-users
         * @name InviteToCollection
         * @summary Invite to a collection
         * @request POST:/collections/{collectionId}/permissions
         * @secure
         */
        inviteToCollection: (collectionId: string, data: InviteUsersAndTeams, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags collection-teams
         * @name ListTeamPermissionsInCollection
         * @summary List a collection team permissions
         * @request GET:/collections/{collectionId}/permissions/teams
         * @secure
         */
        listTeamPermissionsInCollection: (collectionId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: {
                /**
                 * "The role of a member in an organization.
                 * "admin": Can administrate the content: create, delete spaces, ...
                 * "create": Can create content.
                 * "review": Can review content.
                 * "edit": Can edit the content (live or change requests).
                 * "comment": Can access the content and its discussions.
                 * "read": Can access the content, but cannot update it in any way.
                 */
                permission: MemberRole;
                team: OrganizationTeam;
            }[];
        }, any>>;
        /**
         * No description
         *
         * @tags collection-teams
         * @name UpdateTeamPermissionInCollection
         * @summary Update a collection team permission
         * @request PATCH:/collections/{collectionId}/permissions/teams/{teamId}
         * @secure
         */
        updateTeamPermissionInCollection: (collectionId: string, teamId: string, data: {
            /** The role of a member in an organization, null for guests */
            role?: MemberRoleOrGuest;
        }, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags collection-teams
         * @name RemoveTeamFromCollection
         * @summary Remove a team from a collection
         * @request DELETE:/collections/{collectionId}/permissions/teams/{teamId}
         * @secure
         */
        removeTeamFromCollection: (collectionId: string, teamId: string, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags collection-users
         * @name ListUserPermissionsInCollection
         * @summary List collection user permissions
         * @request GET:/collections/{collectionId}/permissions/users
         * @secure
         */
        listUserPermissionsInCollection: (collectionId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: UserContentPermission[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags collection-users
         * @name UpdateUserPermissionInCollection
         * @summary Update a collection user permission
         * @request PATCH:/collections/{collectionId}/permissions/users/{userId}
         * @secure
         */
        updateUserPermissionInCollection: (collectionId: string, userId: string, data: {
            /** The role of a member in an organization, null for guests */
            role?: MemberRoleOrGuest;
        }, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags collection-users
         * @name RemoveUserFromCollection
         * @summary Remove a user from a collection
         * @request DELETE:/collections/{collectionId}/permissions/users/{userId}
         * @secure
         */
        removeUserFromCollection: (collectionId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags collection-users
         * @name ListPermissionsAggregateInCollection
         * @summary List all collections users permissions
         * @request GET:/collections/{collectionId}/permissions/aggregate
         * @secure
         */
        listPermissionsAggregateInCollection: (collectionId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** If defined, only members with this role will be returned. */
            role?: MemberRole;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: UserContentPermission[];
        }, any>>;
    };
    integrations: {
        /**
         * No description
         *
         * @tags integrations
         * @name ListIntegrations
         * @summary List all public integrations
         * @request GET:/integrations
         * @secure
         */
        listIntegrations: (query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** A search string to filter integrations by name */
            search?: string;
            /** Filter the integrations by category */
            category?: IntegrationCategory;
            /**
             * Filter the integrations by block's domains
             * @maxLength 100
             * @pattern ^[a-zA-Z0-9-_.]+$
             */
            blockDomain?: string;
            /** If true, returns only integrations with blocks. If false, returns only integrations without blocks. */
            blocks?: boolean;
            /** If true, returns only integrations with contentSources. If false, returns only integrations without contentSources. */
            contentSources?: boolean;
            /** If defined, only list integrations owned by the given organization. */
            owner?: string;
            /** Filter the integrations by scope */
            scope?: IntegrationScope;
            /** Filter the integrations by target */
            target?: IntegrationTarget;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Integration[];
        }, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name GetIntegrationByName
         * @summary Get an integration by its name
         * @request GET:/integrations/{integrationName}
         * @secure
         */
        getIntegrationByName: (integrationName: string, params?: RequestParams) => Promise<HttpResponse<Integration, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name PublishIntegration
         * @summary Publish an integration
         * @request POST:/integrations/{integrationName}
         * @secure
         */
        publishIntegration: (integrationName: string, data: PublishIntegration, params?: RequestParams) => Promise<HttpResponse<Integration, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name UnpublishIntegration
         * @summary Unpublish an integration
         * @request DELETE:/integrations/{integrationName}
         * @secure
         */
        unpublishIntegration: (integrationName: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name ListIntegrationInstallations
         * @summary List all integration installations
         * @request GET:/integrations/{integrationName}/installations
         * @secure
         */
        listIntegrationInstallations: (integrationName: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** External Id to filter by */
            externalId?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: IntegrationInstallation[];
        }, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name InstallIntegration
         * @summary Install an integration
         * @request POST:/integrations/{integrationName}/installations
         * @secure
         */
        installIntegration: (integrationName: string, data: OrganizationTarget, params?: RequestParams) => Promise<HttpResponse<IntegrationInstallation, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name ListIntegrationEvents
         * @summary List all integration events
         * @request GET:/integrations/{integrationName}/events
         * @secure
         */
        listIntegrationEvents: (integrationName: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: IntegrationEvent[];
        }, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name GetIntegrationEvent
         * @summary Get an integration event by its ID
         * @request GET:/integrations/{integrationName}/events/{eventId}
         * @secure
         */
        getIntegrationEvent: (integrationName: string, eventId: string, params?: RequestParams) => Promise<HttpResponse<{
            event: IntegrationEvent;
            trace?: IntegrationEventTrace;
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name ListIntegrationSpaceInstallations
         * @summary List all integration space installations
         * @request GET:/integrations/{integrationName}/spaces
         * @secure
         */
        listIntegrationSpaceInstallations: (integrationName: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** External Id to filter by */
            externalId?: string;
            /**
             * If true, returns the space object in each items. If false, returns the space ID in each items.
             * @default false
             */
            extended?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: IntegrationSpaceInstallation[];
        }, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name ListIntegrationSiteInstallations
         * @summary List all integration site installations
         * @request GET:/integrations/{integrationName}/sites
         * @secure
         */
        listIntegrationSiteInstallations: (integrationName: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** External ID to filter by */
            externalId?: string;
            /**
             * If true, returns the site object in each items. If false, returns the site ID in each items.
             * @default false
             */
            extended?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: IntegrationSiteInstallation[];
        }, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name SetIntegrationDevelopmentMode
         * @summary Enable integration dev mode
         * @request PUT:/integrations/{integrationName}/dev
         * @secure
         */
        setIntegrationDevelopmentMode: (integrationName: string, data: {
            /**
             * URL of the tunnel to dispatch integration events to
             * @minLength 1
             * @maxLength 256
             */
            tunnelUrl: string;
            /**
             * If set to true, all requests will be forwarded to the tunnel, not just from the owning organization.
             * @default false
             */
            all?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name DisableIntegrationDevelopmentMode
         * @summary Disable integration dev mode
         * @request DELETE:/integrations/{integrationName}/dev
         * @secure
         */
        disableIntegrationDevelopmentMode: (integrationName: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name RenderIntegrationUiWithGet
         * @summary Render an integration UI with GET method
         * @request GET:/integrations/{integrationName}/render
         * @secure
         */
        renderIntegrationUiWithGet: (integrationName: string, query: {
            /** LZ-string compressed JSON request */
            request: string;
        }, params?: RequestParams) => Promise<HttpResponse<ContentKitRenderOutput, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name RenderIntegrationUiWithPost
         * @summary Render an integration UI with POST method
         * @request POST:/integrations/{integrationName}/render
         * @secure
         */
        renderIntegrationUiWithPost: (integrationName: string, data: RenderIntegrationUI, params?: RequestParams) => Promise<HttpResponse<ContentKitRenderOutput, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name QueueIntegrationTask
         * @summary Queue an integration task
         * @request POST:/integrations/{integrationName}/tasks
         * @secure
         */
        queueIntegrationTask: (integrationName: string, data: {
            /** Payload for the integration task */
            task: object;
            /**
             * Number of seconds to wait before executing the task, defaults to 0
             * @min 0
             * @max 86400
             */
            schedule?: number;
        }, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name GetIntegrationInstallationById
         * @summary Get an integration installation by its ID
         * @request GET:/integrations/{integrationName}/installations/{installationId}
         * @secure
         */
        getIntegrationInstallationById: (integrationName: string, installationId: string, params?: RequestParams) => Promise<HttpResponse<IntegrationInstallation, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name UpdateIntegrationInstallation
         * @summary Update an integration installation
         * @request PATCH:/integrations/{integrationName}/installations/{installationId}
         * @secure
         */
        updateIntegrationInstallation: (integrationName: string, installationId: string, data: UpdateIntegrationInstallation, params?: RequestParams) => Promise<HttpResponse<IntegrationInstallation, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name UninstallIntegration
         * @summary Uninstall an integration
         * @request DELETE:/integrations/{integrationName}/installations/{installationId}
         * @secure
         */
        uninstallIntegration: (integrationName: string, installationId: string, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * @description Creates a temporary API token of an integration's installation that has access to the installation and it's scopes. You must be authenticated as the integration to obtain this token.
         *
         * @tags integrations
         * @name CreateIntegrationInstallationToken
         * @summary Create an integration installation API token
         * @request POST:/integrations/{integrationName}/installations/{installationId}/tokens
         * @secure
         */
        createIntegrationInstallationToken: (integrationName: string, installationId: string, params?: RequestParams) => Promise<HttpResponse<APITemporaryToken, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name ListIntegrationInstallationSpaces
         * @summary List all space integration installations
         * @request GET:/integrations/{integrationName}/installations/{installationId}/spaces
         * @secure
         */
        listIntegrationInstallationSpaces: (integrationName: string, installationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * If true, returns the space object in each items. If false, returns the space ID in each items.
             * @default false
             */
            extended?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: IntegrationSpaceInstallation[];
        }, any>>;
        /**
         * No description
         *
         * @name InstallIntegrationOnSpace
         * @summary Install an integration on a space
         * @request POST:/integrations/{integrationName}/installations/{installationId}/spaces
         * @secure
         */
        installIntegrationOnSpace: (integrationName: string, installationId: string, data: {
            /** ID of the space to install the integration on */
            space: string;
        }, query?: {
            /**
             * If true, returns the space object in each items. If false, returns the space ID in each items.
             * @default false
             */
            extended?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<IntegrationSpaceInstallation, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name GetIntegrationSpaceInstallation
         * @summary Get an integration space installation
         * @request GET:/integrations/{integrationName}/installations/{installationId}/spaces/{spaceId}
         * @secure
         */
        getIntegrationSpaceInstallation: (integrationName: string, installationId: string, spaceId: string, query?: {
            /**
             * If true, returns the space object in each items. If false, returns the space ID in each items.
             * @default false
             */
            extended?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<IntegrationSpaceInstallation, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name UpdateIntegrationSpaceInstallation
         * @summary Update an integration space installation
         * @request PATCH:/integrations/{integrationName}/installations/{installationId}/spaces/{spaceId}
         * @secure
         */
        updateIntegrationSpaceInstallation: (integrationName: string, installationId: string, spaceId: string, data: UpdateIntegrationSpaceInstallation, query?: {
            /**
             * If true, returns the space object in each items. If false, returns the space ID in each items.
             * @default false
             */
            extended?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<IntegrationSpaceInstallation, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name UninstallIntegrationFromSpace
         * @summary Uninstall an integration from a space
         * @request DELETE:/integrations/{integrationName}/installations/{installationId}/spaces/{spaceId}
         * @secure
         */
        uninstallIntegrationFromSpace: (integrationName: string, installationId: string, spaceId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name ListIntegrationInstallationSites
         * @summary List all site integration installations
         * @request GET:/integrations/{integrationName}/installations/{installationId}/sites
         * @secure
         */
        listIntegrationInstallationSites: (integrationName: string, installationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * If true, returns the site object in each items. If false, returns the site ID in each items.
             * @default false
             */
            extended?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: IntegrationSiteInstallation[];
        }, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name InstallIntegrationOnSite
         * @summary Install an integration on a site
         * @request POST:/integrations/{integrationName}/installations/{installationId}/sites
         * @secure
         */
        installIntegrationOnSite: (integrationName: string, installationId: string, data: {
            /** ID of the site to install the integration on */
            siteId: string;
        }, query?: {
            /**
             * If true, returns the site object in each items. If false, returns the site ID in each items.
             * @default false
             */
            extended?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<IntegrationSiteInstallation, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name GetIntegrationSiteInstallation
         * @summary Get an integration site installation
         * @request GET:/integrations/{integrationName}/installations/{installationId}/sites/{siteId}
         * @secure
         */
        getIntegrationSiteInstallation: (integrationName: string, installationId: string, siteId: string, query?: {
            /**
             * If true, returns the site object in each items. If false, returns the site ID in each items.
             * @default false
             */
            extended?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<IntegrationSiteInstallation, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name UpdateIntegrationSiteInstallation
         * @summary Update an integration site installation
         * @request PATCH:/integrations/{integrationName}/installations/{installationId}/sites/{siteId}
         * @secure
         */
        updateIntegrationSiteInstallation: (integrationName: string, installationId: string, siteId: string, data: UpdateIntegrationSiteInstallation, query?: {
            /**
             * If true, returns the site object in each items. If false, returns the site ID in each items.
             * @default false
             */
            extended?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<IntegrationSiteInstallation, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name UninstallIntegrationFromSite
         * @summary Uninstall an integration from a site
         * @request DELETE:/integrations/{integrationName}/installations/{installationId}/sites/{siteId}
         * @secure
         */
        uninstallIntegrationFromSite: (integrationName: string, installationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
    };
    orgs: {
        /**
         * No description
         *
         * @tags organizations, critical
         * @name ListOrganizationsForAuthenticatedUser
         * @summary Get the list of organizations for the currently authenticated user
         * @request GET:/orgs
         * @secure
         */
        listOrganizationsForAuthenticatedUser: (query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Organization[];
        }, any>>;
        /**
         * No description
         *
         * @tags organizations, critical
         * @name GetOrganizationById
         * @summary Get an organization by its ID
         * @request GET:/orgs/{organizationId}
         * @secure
         */
        getOrganizationById: (organizationId: string, params?: RequestParams) => Promise<HttpResponse<Organization, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags organizations
         * @name UpdateOrganizationById
         * @summary Update an organization
         * @request PATCH:/orgs/{organizationId}
         * @secure
         */
        updateOrganizationById: (organizationId: string, data: {
            /** Name of the organization */
            title?: OrganizationTitle;
            emailDomains?: OrganizationEmailDomains;
            /** Default hostname for the organization's public content, e.g. <org-hostname>.gitbook.io */
            hostname?: OrganizationHostname;
            /** The role of a member in an organization, null for guests */
            defaultRole?: MemberRoleOrGuest;
            defaultContent?: OrganizationDefaultContent | null;
            logo?: URL | null;
            sso?: boolean;
            ai?: boolean;
            inviteLinks?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<Organization, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags organization-members
         * @name ListMembersInOrganizationById
         * @summary List all organization members
         * @request GET:/orgs/{organizationId}/members
         * @secure
         */
        listMembersInOrganizationById: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * An order for the items in the list
             * @default "desc"
             */
            order?: "asc" | "desc";
            /** The Role to filter the member list by */
            role?: MemberRole | "guest";
            /** A query to filter the member list (displayName and email) */
            search?: string;
            /**
             * The property to sort the results by. When sorting by lastSeenAt, only active members will be listed.
             * @default "joinedAt"
             */
            sort?: "joinedAt" | "lastSeenAt";
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OrganizationMember[];
        }, any>>;
        /**
         * No description
         *
         * @tags organization-members, critical
         * @name GetMemberInOrganizationById
         * @summary Get an organization member by its ID
         * @request GET:/orgs/{organizationId}/members/{userId}
         * @secure
         */
        getMemberInOrganizationById: (organizationId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<OrganizationMember, any>>;
        /**
         * No description
         *
         * @tags organization-members
         * @name UpdateMemberInOrganizationById
         * @summary Update an organization member
         * @request PATCH:/orgs/{organizationId}/members/{userId}
         * @secure
         */
        updateMemberInOrganizationById: (organizationId: string, userId: string, data: {
            /** The role of a member in an organization, null for guests */
            role?: MemberRoleOrGuest;
        }, params?: RequestParams) => Promise<HttpResponse<OrganizationMember, any>>;
        /**
         * No description
         *
         * @tags organization-members
         * @name RemoveMemberFromOrganizationById
         * @summary Delete an organization member
         * @request DELETE:/orgs/{organizationId}/members/{userId}
         * @secure
         */
        removeMemberFromOrganizationById: (organizationId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags organization-members
         * @name UpdateOrganizationMemberLastSeenAt
         * @summary Update an organization member last seen at
         * @request POST:/orgs/{organizationId}/ping
         * @secure
         */
        updateOrganizationMemberLastSeenAt: (organizationId: string, params?: RequestParams) => Promise<HttpResponse<{
            /** A JTW token containing the claims to attach to this user. */
            gitbookVisitorClaims?: string;
        }, any>>;
        /**
         * No description
         *
         * @tags organization-members
         * @name SetUserAsSsoMemberForOrganization
         * @summary Set a user as an SSO member of an organization
         * @request POST:/orgs/{organizationId}/members/{userId}/sso
         * @secure
         */
        setUserAsSsoMemberForOrganization: (organizationId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<OrganizationMember, any>>;
        /**
         * No description
         *
         * @tags organization-members
         * @name ListSpacesForOrganizationMember
         * @summary List an organization member space permissions
         * @request GET:/orgs/{organizationId}/members/{userId}/spaces
         * @secure
         */
        listSpacesForOrganizationMember: (organizationId: string, userId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * An order for the items in the list
             * @default "desc"
             */
            order?: "asc" | "desc";
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: MemberContentPermission[];
        }, any>>;
        /**
         * No description
         *
         * @tags organization-members
         * @name ListTeamsForOrganizationMember
         * @summary List all organization member teams
         * @request GET:/orgs/{organizationId}/members/{userId}/teams
         * @secure
         */
        listTeamsForOrganizationMember: (organizationId: string, userId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** If provided, only teams whose name contains the given parameter will be returned. Case insensitive. */
            title?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: {
                team: OrganizationTeam;
                member: TeamMember;
            }[];
        }, any>>;
        /**
         * No description
         *
         * @tags teams
         * @name ListTeamsInOrganizationById
         * @summary List all teams
         * @request GET:/orgs/{organizationId}/teams
         * @secure
         */
        listTeamsInOrganizationById: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** The unique identifier of a member of the organization. Only teams they can manage will be returned. */
            owner?: string;
            /** If provided, only teams whose name contains the given parameter will be returned. Case insensitive. */
            title?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OrganizationTeam[];
        }, any>>;
        /**
         * No description
         *
         * @tags teams
         * @name CreateOrganizationTeam
         * @summary Create a team
         * @request PUT:/orgs/{organizationId}/teams
         * @secure
         */
        createOrganizationTeam: (organizationId: string, data: {
            /** Title of the team */
            title: OrganizationTeamTitle;
            /** A list of organization member identifiers */
            members?: string[];
        }, params?: RequestParams) => Promise<HttpResponse<OrganizationTeam, any>>;
        /**
         * No description
         *
         * @tags teams
         * @name GetTeamInOrganizationById
         * @summary Get a team
         * @request GET:/orgs/{organizationId}/teams/{teamId}
         * @secure
         */
        getTeamInOrganizationById: (organizationId: string, teamId: string, params?: RequestParams) => Promise<HttpResponse<OrganizationTeam, any>>;
        /**
         * No description
         *
         * @tags teams
         * @name UpdateTeamInOrganizationById
         * @summary Update a team
         * @request PATCH:/orgs/{organizationId}/teams/{teamId}
         * @secure
         */
        updateTeamInOrganizationById: (organizationId: string, teamId: string, data: {
            /** Title of the team */
            title: OrganizationTeamTitle;
        }, params?: RequestParams) => Promise<HttpResponse<OrganizationTeam, any>>;
        /**
         * No description
         *
         * @tags teams
         * @name RemoveTeamFromOrganizationById
         * @summary Delete a team
         * @request DELETE:/orgs/{organizationId}/teams/{teamId}
         * @secure
         */
        removeTeamFromOrganizationById: (organizationId: string, teamId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * @description Updates members of an organization team, either adding or removing them. If a the same user is included as both an add and a remove, they will be removed from the team.
         *
         * @tags team-members
         * @name UpdateMembersInOrganizationTeam
         * @summary Updates members of a team
         * @request PUT:/orgs/{organizationId}/teams/{teamId}/members
         * @secure
         */
        updateMembersInOrganizationTeam: (organizationId: string, teamId: string, data: UpdateMembersInOrganizationTeam, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * @description Lists members, and their roles, for the specified organization team.
         *
         * @tags team-members
         * @name ListTeamMembersInOrganizationById
         * @summary List all team members
         * @request GET:/orgs/{organizationId}/teams/{teamId}/members
         * @secure
         */
        listTeamMembersInOrganizationById: (organizationId: string, teamId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OrganizationTeamMember[];
        }, any>>;
        /**
         * @description Add or updates member in the specified organization team.
         *
         * @tags team-members
         * @name AddMemberToOrganizationTeamById
         * @summary Add a team member
         * @request PUT:/orgs/{organizationId}/teams/{teamId}/members/{userId}
         * @secure
         */
        addMemberToOrganizationTeamById: (organizationId: string, teamId: string, userId: string, data: {
            /**
             * "The role of a team member.
             * "owner": Can manage team members.
             * "member": Is a member of the team.
             */
            role?: TeamMemberRole;
        }, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * @description Deletes member from the specified organization team.
         *
         * @tags team-members
         * @name DeleteMemberFromOrganizationTeamById
         * @summary Delete a team member
         * @request DELETE:/orgs/{organizationId}/teams/{teamId}/members/{userId}
         * @secure
         */
        deleteMemberFromOrganizationTeamById: (organizationId: string, teamId: string, userId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags organization-invites
         * @name InviteUsersToOrganization
         * @summary Invite users in an organization
         * @request POST:/orgs/{organizationId}/invites
         * @secure
         */
        inviteUsersToOrganization: (organizationId: string, data: InviteUsersToOrganization, params?: RequestParams) => Promise<HttpResponse<{
            users: string[];
            /** The number of users who were added to the organization */
            invited: number;
            failedSSOEmails?: string[];
        }, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags organization-invites
         * @name JoinOrganizationWithInvite
         * @summary Join an organization with an invite
         * @request POST:/orgs/{organizationId}/invites/{inviteId}
         * @secure
         */
        joinOrganizationWithInvite: (organizationId: string, inviteId: string, params?: RequestParams) => Promise<HttpResponse<object, any>>;
        /**
         * No description
         *
         * @tags organization-invites
         * @name ListOrganizationInviteLinks
         * @summary List organization invites
         * @request GET:/orgs/{organizationId}/link-invites
         * @secure
         */
        listOrganizationInviteLinks: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: InviteLinkToOrganization[];
        }, any>>;
        /**
         * No description
         *
         * @tags organization-invites
         * @name CreateOrganizationInvite
         * @summary Create an organization invite
         * @request POST:/orgs/{organizationId}/link-invites
         * @secure
         */
        createOrganizationInvite: (organizationId: string, data: CreateOrganizationInvite, params?: RequestParams) => Promise<HttpResponse<OrganizationInviteLink, any>>;
        /**
         * No description
         *
         * @tags organization-invites
         * @name GetOrganizationInviteLink
         * @summary Get an organization by its ID
         * @request GET:/orgs/{organizationId}/link-invites/{inviteId}
         * @secure
         */
        getOrganizationInviteLink: (organizationId: string, inviteId: string, params?: RequestParams) => Promise<HttpResponse<OrganizationInviteLink, any>>;
        /**
         * No description
         *
         * @tags organization-invites
         * @name UpdateOrganizationInviteById
         * @summary Update an organization invite
         * @request PATCH:/orgs/{organizationId}/link-invites/{inviteId}
         * @secure
         */
        updateOrganizationInviteById: (organizationId: string, inviteId: string, data: {
            /** The role of a member in an organization, null for guests */
            role: MemberRoleOrGuest;
        } | {
            /** The role of a member in an organization, null for guests */
            level: MemberRoleOrGuest;
        }, params?: RequestParams) => Promise<HttpResponse<OrganizationInviteLink, any>>;
        /**
         * No description
         *
         * @tags organizations
         * @name DeleteOrganizationInviteById
         * @summary Deletes an organization invite.
         * @request DELETE:/orgs/{organizationId}/link-invites/{inviteId}
         * @secure
         */
        deleteOrganizationInviteById: (organizationId: string, inviteId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags organizations
         * @name SearchOrganizationContent
         * @summary Search content in an organization
         * @request GET:/orgs/{organizationId}/search
         * @secure
         */
        searchOrganizationContent: (organizationId: string, query: {
            /** @maxLength 512 */
            query: string;
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SearchSpaceResult[];
        }, any>>;
        /**
         * No description
         *
         * @tags spaces
         * @name ListSpacesInOrganizationById
         * @summary List all spaces
         * @request GET:/orgs/{organizationId}/spaces
         * @secure
         */
        listSpacesInOrganizationById: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Space[];
        }, any>>;
        /**
         * No description
         *
         * @tags spaces
         * @name CreateSpace
         * @summary Create a space
         * @request POST:/orgs/{organizationId}/spaces
         * @secure
         */
        createSpace: (organizationId: string, data: CreateSpace, params?: RequestParams) => Promise<HttpResponse<Space, any>>;
        /**
         * No description
         *
         * @tags collections
         * @name ListCollectionsInOrganizationById
         * @summary List all collections
         * @request GET:/orgs/{organizationId}/collections
         * @secure
         */
        listCollectionsInOrganizationById: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * If true, all nested collections will be listed
             * @default true
             */
            nested?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Collection[];
        }, any>>;
        /**
         * No description
         *
         * @tags collections
         * @name CreateCollection
         * @summary Create a collection
         * @request POST:/orgs/{organizationId}/collections
         * @secure
         */
        createCollection: (organizationId: string, data: {
            /** @maxLength 50 */
            title?: string;
            /** ID of a parent collection */
            parent?: string;
        }, params?: RequestParams) => Promise<HttpResponse<Collection, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name ListOrganizationIntegrations
         * @summary List all public integrations along with private ones trusted by the specific org.
         * @request GET:/orgs/{organizationId}/integrations
         * @secure
         */
        listOrganizationIntegrations: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** A search string to filter integrations by name */
            search?: string;
            /** Filter the integrations by category */
            category?: IntegrationCategory;
            /**
             * Filter the integrations by block's domains
             * @maxLength 100
             * @pattern ^[a-zA-Z0-9-_.]+$
             */
            blockDomain?: string;
            /** If true, returns only integrations with blocks. If false, returns only integrations without blocks. */
            blocks?: boolean;
            /** If true, returns only integrations with contentSources. If false, returns only integrations without contentSources. */
            contentSources?: boolean;
            /** If defined, only list integrations owned by the given organization. */
            owner?: string;
            /** Filter the integrations by scope */
            scope?: IntegrationScope;
            /** Filter the integrations by target */
            target?: IntegrationTarget;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Integration[];
        }, any>>;
        /**
         * No description
         *
         * @tags integrations
         * @name GetOrganizationIntegrationStatus
         * @summary Get the status of an integration
         * @request GET:/orgs/{organizationId}/integrations/{integrationName}/installation_status
         * @secure
         */
        getOrganizationIntegrationStatus: (organizationId: string, integrationName: string, params?: RequestParams) => Promise<HttpResponse<{
            status: IntegrationInstallationStatus;
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations
         * @name ListOrganizationInstallations
         * @summary List all integration installations
         * @request GET:/orgs/{organizationId}/installations
         * @secure
         */
        listOrganizationInstallations: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** A search string to filter integrations by name */
            search?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: {
                /** Installation of an integration on an account */
                installation: IntegrationInstallation;
                integration: Integration;
            }[];
        }, any>>;
        /**
         * No description
         *
         * @tags integrations, critical
         * @name ListOrganizationIntegrationsStatus
         * @summary List all integration statuses
         * @request GET:/orgs/{organizationId}/integrations/installations-status
         * @secure
         */
        listOrganizationIntegrationsStatus: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** A search string to filter integrations by name */
            search?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: {
                status: IntegrationInstallationStatus;
                integration: Integration;
            }[];
        }, any>>;
        /**
         * @description Lists SAML providers configured for the specified organization.
         *
         * @tags sso
         * @name ListSamlProvidersInOrganizationById
         * @summary List all SAML providers
         * @request GET:/orgs/{organizationId}/saml
         * @secure
         */
        listSamlProvidersInOrganizationById: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OrganizationSAMLProvider[];
        }, any>>;
        /**
         * No description
         *
         * @tags sso
         * @name CreateOrganizationSamlProvider
         * @summary Create a new SAML provider
         * @request POST:/orgs/{organizationId}/saml
         * @secure
         */
        createOrganizationSamlProvider: (organizationId: string, data: {
            label: SAMLProviderLabel;
            entityID?: SAMLProviderEntityID;
            certificate?: SAMLProviderCertificate;
            ssoURL?: URL;
            defaultTeam?: string;
            /** The role of a member in an organization, null for guests */
            defaultRole?: MemberRoleOrGuest;
        }, params?: RequestParams) => Promise<HttpResponse<OrganizationSAMLProvider, any>>;
        /**
         * No description
         *
         * @tags sso
         * @name GetOrganizationSamlProviderById
         * @summary Get a SAML provider by its ID
         * @request GET:/orgs/{organizationId}/saml/{samlProviderId}
         * @secure
         */
        getOrganizationSamlProviderById: (organizationId: string, samlProviderId: string, params?: RequestParams) => Promise<HttpResponse<OrganizationSAMLProvider, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags sso
         * @name UpdateOrganizationSamlProvider
         * @summary Update a SAML provider
         * @request PATCH:/orgs/{organizationId}/saml/{samlProviderId}
         * @secure
         */
        updateOrganizationSamlProvider: (organizationId: string, samlProviderId: string, data: {
            label?: SAMLProviderLabel;
            entityID?: SAMLProviderEntityID;
            certificate?: SAMLProviderCertificate;
            ssoURL?: URL;
            defaultTeam?: string;
            /** The role of a member in an organization, null for guests */
            defaultRole?: MemberRoleOrGuest;
        }, params?: RequestParams) => Promise<HttpResponse<OrganizationSAMLProvider, any>>;
        /**
         * No description
         *
         * @tags sso
         * @name DeleteOrganizationSamlProvider
         * @summary Delete a SAML provider
         * @request DELETE:/orgs/{organizationId}/saml/{samlProviderId}
         * @secure
         */
        deleteOrganizationSamlProvider: (organizationId: string, samlProviderId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags sso
         * @name ListSsoProviderLoginsInOrganization
         * @summary List all SSO provider login infos
         * @request GET:/orgs/{organizationId}/sso
         * @secure
         */
        listSsoProviderLoginsInOrganization: (organizationId: string, params?: RequestParams) => Promise<HttpResponse<{
            items: OrganizationSSOProviderLogin[];
        }, any>>;
        /**
         * @description Ask a question to an AI across spaces that is accessible by the currently authenticated target.
         *
         * @tags organization-ask
         * @name AskInOrganization
         * @summary Ask a question in an organization
         * @request POST:/orgs/{organizationId}/ask
         * @secure
         */
        askInOrganization: (organizationId: string, data: SearchAIQuery, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
            /** Return query details in the result */
            details?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<{
            /** Answer from AI for a question asked on a content. */
            answer?: SearchAIAnswer;
        }, any>>;
        /**
         * No description
         *
         * @tags organization-ask
         * @name GetRecommendedQuestionsInOrganization
         * @summary List recommended questions to ask in an organization
         * @request GET:/orgs/{organizationId}/ask/questions
         * @secure
         */
        getRecommendedQuestionsInOrganization: (organizationId: string, params?: RequestParams) => Promise<HttpResponse<SearchAIRecommendedQuestions, any>>;
        /**
         * No description
         *
         * @tags organization-ask
         * @name StreamRecommendedQuestionsInOrganization
         * @summary List recommended questions to ask in an organization (streamed)
         * @request GET:/orgs/{organizationId}/ask/questions/stream
         * @secure
         */
        streamRecommendedQuestionsInOrganization: (organizationId: string, params?: RequestParams) => EventIterator<SearchAIRecommendedQuestionStream>;
        /**
         * @description Ask a question to an AI across spaces that is accessible by the currently authenticated target and stream the answer as a Server-Sent Events URL.
         *
         * @tags organization-ask
         * @name StreamAskInOrganization
         * @summary Ask a question in an organization (streamed)
         * @request GET:/orgs/{organizationId}/ask/stream
         * @secure
         */
        streamAskInOrganization: (organizationId: string, query: {
            query: string;
            /** Output format for the content. */
            format?: "document" | "markdown";
            /** Return query details in the result */
            details?: boolean;
        }, params?: RequestParams) => EventIterator<SearchAIAnswerStream>;
        /**
         * No description
         *
         * @tags openapi
         * @name ListOpenApiSpecs
         * @summary List all OpenAPI spec
         * @request GET:/orgs/{organizationId}/openapi
         * @secure
         */
        listOpenApiSpecs: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OpenAPISpec[];
        }, any>>;
        /**
         * No description
         *
         * @tags openapi
         * @name CreateOpenApiSpec
         * @summary Create an OpenAPI spec
         * @request POST:/orgs/{organizationId}/openapi
         * @secure
         */
        createOpenApiSpec: (organizationId: string, data: {
            /** Slug used as reference */
            slug: OpenAPISpecSlug;
            /** Create a specification from an URL */
            source: OpenAPISpecSource;
        }, params?: RequestParams) => Promise<HttpResponse<OpenAPISpec, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags openapi
         * @name GetOpenApiSpecBySlug
         * @summary Get an OpenAPI spec by its slug
         * @request GET:/orgs/{organizationId}/openapi/{specSlug}
         * @secure
         */
        getOpenApiSpecBySlug: (organizationId: string, specSlug: string, params?: RequestParams) => Promise<HttpResponse<OpenAPISpec, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags openapi
         * @name CreateOrUpdateOpenApiSpecBySlug
         * @summary Create or update an OpenAPI spec
         * @request PUT:/orgs/{organizationId}/openapi/{specSlug}
         * @secure
         */
        createOrUpdateOpenApiSpecBySlug: (organizationId: string, specSlug: string, data: {
            /** Create a specification from an URL */
            source: OpenAPISpecSource;
        }, params?: RequestParams) => Promise<HttpResponse<OpenAPISpec, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags openapi
         * @name DeleteOpenApiSpecBySlug
         * @summary Delete an OpenAPI spec
         * @request DELETE:/orgs/{organizationId}/openapi/{specSlug}
         * @secure
         */
        deleteOpenApiSpecBySlug: (organizationId: string, specSlug: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags openapi-versions
         * @name ListOpenApiSpecVersions
         * @summary List all OpenAPI spec versions
         * @request GET:/orgs/{organizationId}/openapi/{specSlug}/versions
         * @secure
         */
        listOpenApiSpecVersions: (organizationId: string, specSlug: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: OpenAPISpecVersion[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags openapi-versions
         * @name GetLatestOpenApiSpecVersion
         * @summary Get the latest OpenAPI spec version
         * @request GET:/orgs/{organizationId}/openapi/{specSlug}/versions/latest
         * @secure
         */
        getLatestOpenApiSpecVersion: (organizationId: string, specSlug: string, params?: RequestParams) => Promise<HttpResponse<OpenAPISpecVersion, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags openapi-versions
         * @name GetLatestOpenApiSpecVersionContent
         * @summary Get the latest OpenAPI spec version content
         * @request GET:/orgs/{organizationId}/openapi/{specSlug}/versions/latest/content
         * @secure
         */
        getLatestOpenApiSpecVersionContent: (organizationId: string, specSlug: string, params?: RequestParams) => Promise<HttpResponse<OpenAPISpecContent, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags openapi-versions
         * @name GetOpenApiSpecVersionById
         * @summary Get an OpenAPI spec version by its ID
         * @request GET:/orgs/{organizationId}/openapi/{specSlug}/versions/{versionId}
         * @secure
         */
        getOpenApiSpecVersionById: (organizationId: string, specSlug: string, versionId: string, params?: RequestParams) => Promise<HttpResponse<OpenAPISpecVersion, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags openapi-versions
         * @name GetOpenApiSpecVersionContentById
         * @summary Get an OpenAPI spec version content by its ID
         * @request GET:/orgs/{organizationId}/openapi/{specSlug}/versions/{versionId}/content
         * @secure
         */
        getOpenApiSpecVersionContentById: (organizationId: string, specSlug: string, versionId: string, params?: RequestParams) => Promise<HttpResponse<OpenAPISpecContent, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags agents
         * @name ListConversationsIssuesClusters
         * @summary List conversations issues clusters
         * @request GET:/orgs/{organizationId}/conversations-clusters
         * @secure
         */
        listConversationsIssuesClusters: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * An order for the items in the list
             * @default "desc"
             */
            order?: "asc" | "desc";
            /** @default "updatedAt" */
            orderBy?: "updatedAt" | "issues" | "conversations" | "tasksTotal" | "tasksBacklog" | "tasksStarted";
            /** Filter by status */
            status?: "pending" | "analysing";
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: ConversationsIssuesCluster[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags agents
         * @name GetConversationsIssuesCluster
         * @summary Get a conversations issues cluster by its identifier
         * @request GET:/orgs/{organizationId}/conversations-clusters/{clusterId}
         * @secure
         */
        getConversationsIssuesCluster: (organizationId: string, clusterId: string, params?: RequestParams) => Promise<HttpResponse<ConversationsIssuesCluster, any>>;
        /**
         * No description
         *
         * @tags agents
         * @name ListConversationsIssuesInCluster
         * @summary List conversations issues in a cluster
         * @request GET:/orgs/{organizationId}/conversations-clusters/{clusterId}/issues
         * @secure
         */
        listConversationsIssuesInCluster: (organizationId: string, clusterId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: {
                issue: ConversationIssue;
                conversation: Conversation;
            }[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags conversations
         * @name IngestConversation
         * @summary Ingest conversations
         * @request POST:/orgs/{organizationId}/conversations
         * @secure
         */
        ingestConversation: (organizationId: string, data: ConversationInput | ConversationInput[], params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * @description Get the state of the agent.
         *
         * @tags agents, critical
         * @name GetAgentSetupState
         * @summary Get the agents setup state
         * @request GET:/orgs/{organizationId}/agents-setup
         * @secure
         */
        getAgentSetupState: (organizationId: string, params?: RequestParams) => Promise<HttpResponse<AgentsSetupState, any>>;
        /**
         * No description
         *
         * @tags agents
         * @name ListAgentTasks
         * @summary List agent tasks
         * @request GET:/orgs/{organizationId}/agent-tasks
         * @secure
         */
        listAgentTasks: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** The ID of the conversations issues cluster to filter the agent tasks by */
            cluster?: string;
            /** The ID of the space to filter the agent tasks by */
            space?: string;
            /** The statuses of the agent tasks to filter by */
            status?: AgentTaskStatus[];
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: AgentTask[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags agents
         * @name GetAgentTask
         * @summary Get an agent task by its identifier
         * @request GET:/orgs/{organizationId}/agent-tasks/{agentTaskId}
         * @secure
         */
        getAgentTask: (organizationId: string, agentTaskId: string, params?: RequestParams) => Promise<HttpResponse<AgentTask, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags agents
         * @name UpdateAgentTask
         * @summary Update an agent task by its identifier
         * @request PATCH:/orgs/{organizationId}/agent-tasks/{agentTaskId}
         * @secure
         */
        updateAgentTask: (organizationId: string, agentTaskId: string, data: {
            status: "backlog" | "started" | "canceled";
        }, params?: RequestParams) => Promise<HttpResponse<AgentTask, any>>;
        /**
         * No description
         *
         * @tags translations
         * @name ListTranslationSettings
         * @summary List all the translation settings
         * @request GET:/orgs/{organizationId}/translations
         * @secure
         */
        listTranslationSettings: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: TranslationSettings[];
        }, any>>;
        /**
         * No description
         *
         * @tags translations
         * @name CreateTranslationSettings
         * @summary Create a translation settings
         * @request POST:/orgs/{organizationId}/translations
         * @secure
         */
        createTranslationSettings: (organizationId: string, data: {
            /** The title of the translation settings */
            title: string;
        }, params?: RequestParams) => Promise<HttpResponse<TranslationSettings, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags translations
         * @name GetTranslationSettings
         * @summary Get a translation settings by its ID
         * @request GET:/orgs/{organizationId}/translations/{translationSettingsId}
         * @secure
         */
        getTranslationSettings: (organizationId: string, translationSettingsId: string, params?: RequestParams) => Promise<HttpResponse<TranslationSettings, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags translations
         * @name UpdateTranslationSettings
         * @summary Update a translation settings
         * @request PUT:/orgs/{organizationId}/translations/{translationSettingsId}
         * @secure
         */
        updateTranslationSettings: (organizationId: string, translationSettingsId: string, data: {
            /** The title of the translation settings */
            title: string;
        }, params?: RequestParams) => Promise<HttpResponse<TranslationSettings, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags translations
         * @name DeleteTranslationSettings
         * @summary Delete a translation settings
         * @request DELETE:/orgs/{organizationId}/translations/{translationSettingsId}
         * @secure
         */
        deleteTranslationSettings: (organizationId: string, translationSettingsId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags translation-languages
         * @name ListTranslationLanguages
         * @summary List all translation settings language
         * @request GET:/orgs/{organizationId}/translations/{translationSettingsId}/languages
         * @secure
         */
        listTranslationLanguages: (organizationId: string, translationSettingsId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: TranslationLanguageSettings[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags translation-languages
         * @name GetTranslationLanguage
         * @summary Get a translation settings language
         * @request GET:/orgs/{organizationId}/translations/{translationSettingsId}/languages/{translationLanguage}
         * @secure
         */
        getTranslationLanguage: (organizationId: string, translationSettingsId: string, translationLanguage: TranslationLanguage, params?: RequestParams) => Promise<HttpResponse<TranslationLanguageSettings, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags translation-languages
         * @name CreateOrUpdateTranslationLanguage
         * @summary Create or update a translation settings language
         * @request PUT:/orgs/{organizationId}/translations/{translationSettingsId}/languages/{translationLanguage}
         * @secure
         */
        createOrUpdateTranslationLanguage: (organizationId: string, translationSettingsId: string, translationLanguage: TranslationLanguage, data: {
            instructions: JSONDocument;
        }, params?: RequestParams) => Promise<HttpResponse<TranslationLanguageSettings, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags translation-languages
         * @name DeleteTranslationLanguage
         * @summary Remove a translation settings language
         * @request DELETE:/orgs/{organizationId}/translations/{translationSettingsId}/languages/{translationLanguage}
         * @secure
         */
        deleteTranslationLanguage: (organizationId: string, translationSettingsId: string, translationLanguage: TranslationLanguage, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * @description Generate a pre-signed URL that can be used to upload a file to storage
         *
         * @tags storage
         * @name GenerateStorageUploadUrl
         * @summary Create a signed URL to upload a file
         * @request POST:/orgs/{organizationId}/storage/upload
         * @secure
         */
        generateStorageUploadUrl: (organizationId: string, data: {
            file: StorageFileMetadata;
            kind: StorageUploadKind;
        }, params?: RequestParams) => Promise<HttpResponse<StorageUploadURL, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags custom-fonts
         * @name ListCustomFonts
         * @summary List all custom fonts
         * @request GET:/orgs/{organizationId}/fonts
         * @secure
         */
        listCustomFonts: (organizationId: string, params?: RequestParams) => Promise<HttpResponse<List & {
            items: CustomizationFontDefinition[];
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags custom-fonts
         * @name CreateCustomFont
         * @summary Create a custom font
         * @request PUT:/orgs/{organizationId}/fonts
         * @secure
         */
        createCustomFont: (organizationId: string, data: {
            /** The human-readable font-family name used in CSS (e.g., "Open Sans", "Playfair Display"). */
            fontFamily: FontFamily;
            /**
             * Array of font faces specifying weights and their corresponding storage keys.
             * At least one font face with weight 400 (regular) must be provided.
             * @minItems 1
             */
            fontFaces: {
                /** Numeric representation of the font weight (400=regular, 500=medium, 700=bold, 900=black). */
                weight: FontWeight;
                /** The path of the file in the storage bucket */
                storageKey: StorageFileKey;
            }[];
        }, params?: RequestParams) => Promise<HttpResponse<CustomizationFontDefinition, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 412;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags custom-fonts
         * @name GetCustomFont
         * @summary Get a custom font by its ID
         * @request GET:/orgs/{organizationId}/fonts/{fontId}
         * @secure
         */
        getCustomFont: (organizationId: string, fontId: string, params?: RequestParams) => Promise<HttpResponse<CustomizationFontDefinition, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags custom-fonts
         * @name UpdateCustomFont
         * @summary Update a custom font
         * @request POST:/orgs/{organizationId}/fonts/{fontId}
         * @secure
         */
        updateCustomFont: (organizationId: string, fontId: string, data: {
            /** The human-readable font-family name used in CSS (e.g., "Open Sans", "Playfair Display"). */
            fontFamily?: FontFamily;
            /** Array of font faces specifying weights and their corresponding storage keys. Passing null as the storage key will remove that weight. */
            fontFaces?: {
                /** Numeric representation of the font weight (400=regular, 500=medium, 700=bold, 900=black). */
                weight: FontWeight;
                storageKey: StorageFileKey | null;
            }[];
        }, params?: RequestParams) => Promise<HttpResponse<CustomizationFontDefinition, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 412;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags custom-fonts
         * @name DeleteCustomFont
         * @summary Delete a custom font
         * @request DELETE:/orgs/{organizationId}/fonts/{fontId}
         * @secure
         */
        deleteCustomFont: (organizationId: string, fontId: string, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags sites, critical
         * @name ListSites
         * @summary List all sites
         * @request GET:/orgs/{organizationId}/sites
         * @secure
         */
        listSites: (organizationId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** Identifier of the space to filter the sites by */
            space?: string;
            /** Filter sites by their title */
            title?: string;
            /** Filter sites by their published status */
            published?: boolean;
            /** Filter by site type */
            type?: SiteType[];
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Site[];
        }, any>>;
        /**
         * No description
         *
         * @tags sites
         * @name CreateSite
         * @summary Create a site
         * @request POST:/orgs/{organizationId}/sites
         * @secure
         */
        createSite: (organizationId: string, data: {
            /** The type of the site, defaults to Basic */
            type?: SiteType;
            /** Title of the site */
            title?: SiteTitle;
            /**
             * The visibility setting of the site determines the audience of the site.
             * * `public`: Anyone can access the site, and the site is indexed by search engines.
             * * `unlisted`: Anyone can access the site, and the site is not indexed by search engines
             * * `share-link`: Anyone with a secret token in the url can access the site.
             * * `visitor-auth`: Anyone authenticated through a JWT token can access the site.
             */
            visibility?: SiteVisibility;
            /** ID of spaces to be added to the site */
            spaces?: string[] | "sample" | "empty";
        }, params?: RequestParams) => Promise<HttpResponse<Site, any>>;
        /**
         * No description
         *
         * @tags sites
         * @name GetSiteById
         * @summary Get a site by its ID
         * @request GET:/orgs/{organizationId}/sites/{siteId}
         * @secure
         */
        getSiteById: (organizationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<Site, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags sites
         * @name UpdateSiteById
         * @summary Update a site
         * @request PATCH:/orgs/{organizationId}/sites/{siteId}
         * @secure
         */
        updateSiteById: (organizationId: string, siteId: string, data: {
            /** Title of the site */
            title?: SiteTitle;
            /**
             * The visibility setting of the site determines the audience of the site.
             * * `public`: Anyone can access the site, and the site is indexed by search engines.
             * * `unlisted`: Anyone can access the site, and the site is not indexed by search engines
             * * `share-link`: Anyone with a secret token in the url can access the site.
             * * `visitor-auth`: Anyone authenticated through a JWT token can access the site.
             */
            visibility?: SiteVisibility;
            /** Basename for the site. For e.g. api */
            basename?: SiteBasename;
            adaptiveContent?: SiteAdaptiveContent;
            /**
             * Defines if the site will be included in the agent's context.
             * - `excluded` means that the agent will not be able to access the site.
             * - `included` means that the agent will be able to access the site.
             */
            agentsContext?: SiteAgentsContext;
            /** ID of the site-space to be used as the default at the root level. If site has sections, this will mark the default site space in the site's default section. */
            defaultSiteSpace?: string;
            /** ID of the site-section to be used as the default. */
            defaultSiteSection?: string;
            /**
             * Configure a proxy URL for a site. For example, you can use it to host the site on a subdirectory of your domain like `https://company.com/docs`.
             * Use `null` to remove the proxy.
             */
            proxy?: SiteProxyOrigin | null;
        }, params?: RequestParams) => Promise<HttpResponse<Site, any>>;
        /**
         * No description
         *
         * @tags sites
         * @name DeleteSiteById
         * @summary Delete a site
         * @request DELETE:/orgs/{organizationId}/sites/{siteId}
         * @secure
         */
        deleteSiteById: (organizationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags sites
         * @name GetSiteAdaptiveSchema
         * @summary Get the JSON schema describing the attributes expected for an Adaptive content site visitor.
         * @request GET:/orgs/{organizationId}/sites/{siteId}/adaptive-schema
         * @secure
         */
        getSiteAdaptiveSchema: (organizationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<SiteAdaptiveSchema, Error | {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags sites
         * @name UpdateSiteAdaptiveSchema
         * @summary Update the JSON schema of the attributes expected for an Adaptive content site visitor.
         * @request PUT:/orgs/{organizationId}/sites/{siteId}/adaptive-schema
         * @secure
         */
        updateSiteAdaptiveSchema: (organizationId: string, siteId: string, data: {
            /** The JSON schema to set on the site. */
            jsonSchema: SiteAdaptiveJSONSchema;
        }, params?: RequestParams) => Promise<HttpResponse<SiteAdaptiveSchema, Error | {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags sites
         * @name ListSiteAdaptiveTemplateConditions
         * @summary List templates of conditions generated based on the site visitor schema that can be used in adaptive content expressions.
         * @request GET:/orgs/{organizationId}/sites/{siteId}/adaptive-schema/template-conditions
         * @secure
         */
        listSiteAdaptiveTemplateConditions: (organizationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<{
            items: SiteAdaptiveTemplateCondition[];
        }, any>>;
        /**
         * @description Get the complete profile of a site in an organization to provide the published experience. It includes site, customization, structure, integration scripts etc.
         *
         * @tags sites
         * @name GetPublishedContentSite
         * @summary Get a published site
         * @request GET:/orgs/{organizationId}/sites/{siteId}/published
         * @secure
         */
        getPublishedContentSite: (organizationId: string, siteId: string, query?: {
            /** For sites published via share-links, the share key is useful to resolve published URLs. */
            shareKey?: string;
        }, params?: RequestParams) => Promise<HttpResponse<PublishedContentSite, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags sites
         * @name PublishSite
         * @summary Publish a site
         * @request POST:/orgs/{organizationId}/sites/{siteId}/publish
         * @secure
         */
        publishSite: (organizationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<Site | {
            type: "checkout";
            /** Stripe payment session ID */
            sessionId: string;
        }, any>>;
        /**
         * No description
         *
         * @tags sites
         * @name UnpublishSite
         * @summary Unpublish a site
         * @request POST:/orgs/{organizationId}/sites/{siteId}/unpublish
         * @secure
         */
        unpublishSite: (organizationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<Site, any>>;
        /**
         * No description
         *
         * @tags site-share-links
         * @name ListSiteShareLinks
         * @summary List all share links
         * @request GET:/orgs/{organizationId}/sites/{siteId}/share-links
         * @secure
         */
        listSiteShareLinks: (organizationId: string, siteId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: ShareLink[];
        }, any>>;
        /**
         * No description
         *
         * @tags site-share-links
         * @name CreateSiteShareLink
         * @summary Create a share link
         * @request POST:/orgs/{organizationId}/sites/{siteId}/share-links
         * @secure
         */
        createSiteShareLink: (organizationId: string, siteId: string, data: {
            /** Name of the share link */
            name: ShareLinkName;
        }, params?: RequestParams) => Promise<HttpResponse<ShareLink, any>>;
        /**
         * No description
         *
         * @tags site-share-links
         * @name UpdateSiteShareLinkById
         * @summary Update a share link
         * @request PATCH:/orgs/{organizationId}/sites/{siteId}/share-links/{shareLinkId}
         * @secure
         */
        updateSiteShareLinkById: (organizationId: string, siteId: string, shareLinkId: string, data: {
            active?: boolean;
            /** Name of the share link */
            name?: ShareLinkName;
        }, params?: RequestParams) => Promise<HttpResponse<ShareLink, any>>;
        /**
         * No description
         *
         * @tags site-share-links
         * @name DeleteSiteShareLinkById
         * @summary Deletes a share link
         * @request DELETE:/orgs/{organizationId}/sites/{siteId}/share-links/{shareLinkId}
         * @secure
         */
        deleteSiteShareLinkById: (organizationId: string, siteId: string, shareLinkId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * @description Get the complete structure of a site that includes all its site-sections and site-spaces.
         *
         * @tags site-structure
         * @name GetSiteStructure
         * @summary Get a site structure
         * @request GET:/orgs/{organizationId}/sites/{siteId}/structure
         * @secure
         */
        getSiteStructure: (organizationId: string, siteId: string, query?: {
            /** For sites published via share-links, the share key is useful to resolve published URLs. */
            shareKey?: string;
        }, params?: RequestParams) => Promise<HttpResponse<SiteStructure, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags sites
         * @name SortSiteStructure
         * @summary Move a site space, site section or site section group to a new position in the site structure.
         * @request PATCH:/orgs/{organizationId}/sites/{siteId}/structure/sort
         * @secure
         */
        sortSiteStructure: (organizationId: string, siteId: string, data: {
            /** pointer to the item (site space, site section or site section group) being moved. */
            item: SiteStructureItemPointer;
            /** The position to move the item to. When not provided the item is moved to the end of the site structure. */
            position: SiteStructureItemMovePosition;
        }, params?: RequestParams) => Promise<HttpResponse<SiteStructureItem, Error | {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags site-publishing-auth
         * @name GetSitePublishingAuthById
         * @summary Get a site auth config
         * @request GET:/orgs/{organizationId}/sites/{siteId}/publishing/auth
         * @secure
         */
        getSitePublishingAuthById: (organizationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<SitePublishingAuth, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags site-publishing-auth
         * @name UpdateSitePublishingAuthById
         * @summary Update a site auth config
         * @request PATCH:/orgs/{organizationId}/sites/{siteId}/publishing/auth
         * @secure
         */
        updateSitePublishingAuthById: (organizationId: string, siteId: string, data: SitePublishingAuthUpdate, params?: RequestParams) => Promise<HttpResponse<SitePublishingAuth, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * @description Regenerate the publishing authentication settings for a site. This will re-generate the private key.
         *
         * @tags site-publishing-auth
         * @name RegenerateSitePublishingAuthById
         * @summary Regenerate a site auth
         * @request POST:/orgs/{organizationId}/sites/{siteId}/publishing/auth/regenerate
         * @secure
         */
        regenerateSitePublishingAuthById: (organizationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<SitePublishingAuth, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * @description Generate a URL to preview the published content of a site. The URL will be valid for 1 hour.
         *
         * @tags site-preview
         * @name GetSitePublishingPreviewById
         * @summary Get a site preview URL
         * @request GET:/orgs/{organizationId}/sites/{siteId}/publishing/preview
         * @secure
         */
        getSitePublishingPreviewById: (organizationId: string, siteId: string, query?: {
            /** ID of the site-space to preview. If not provided, the default site-space will be used. */
            siteSpace?: string;
            /** Rison encoded string of attributes/assertions about the visitor for which we want to preview the site. */
            claims?: string;
        }, params?: RequestParams) => Promise<HttpResponse<{
            url: URL;
        }, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags site-customization
         * @name GetSiteCustomizationById
         * @summary Get a site customization settings
         * @request GET:/orgs/{organizationId}/sites/{siteId}/customization
         * @secure
         */
        getSiteCustomizationById: (organizationId: string, siteId: string, query?: {
            /**
             * (Deprecated) Use the getRawCustomizationSettingsById internal endpoint.
             * @deprecated
             * @default false
             */
            unmasked?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<SiteCustomizationSettings, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags site-customization
         * @name UpdateSiteCustomizationById
         * @summary Update a site customization settings
         * @request PUT:/orgs/{organizationId}/sites/{siteId}/customization
         * @secure
         */
        updateSiteCustomizationById: (organizationId: string, siteId: string, data: SiteCustomizationSettings, params?: RequestParams) => Promise<HttpResponse<SiteCustomizationSettings, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations, sites
         * @name ListSiteIntegrationScripts
         * @summary List the scripts to embed in published content for a site.
         * @request GET:/orgs/{organizationId}/sites/{siteId}/integration-scripts
         * @secure
         */
        listSiteIntegrationScripts: (organizationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<SiteIntegrationScript[], {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags integrations, sites
         * @name ListSiteIntegrations
         * @summary List integrations enabled in a site.
         * @request GET:/orgs/{organizationId}/sites/{siteId}/integrations
         * @secure
         */
        listSiteIntegrations: (organizationId: string, siteId: string, query?: {
            /** A search string to filter integrations by name */
            search?: string;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: Integration[];
        }, any>>;
        /**
         * No description
         *
         * @tags site-spaces
         * @name AddSpaceToSite
         * @summary Add a space to a site
         * @request POST:/orgs/{organizationId}/sites/{siteId}/site-spaces
         * @secure
         */
        addSpaceToSite: (organizationId: string, siteId: string, data: {
            /** ID of the space */
            spaceId: string;
            /** ID of the section to add the space to. If not provided, the space will be added to the default section or at the root level if the site has no sections. */
            sectionId?: string;
        }, params?: RequestParams) => Promise<HttpResponse<SiteSpace, any>>;
        /**
         * No description
         *
         * @tags site-spaces, critical
         * @name ListSiteSpaces
         * @summary List all the site spaces
         * @request GET:/orgs/{organizationId}/sites/{siteId}/site-spaces
         * @secure
         */
        listSiteSpaces: (organizationId: string, siteId: string, query?: {
            /** For sites published via share-links, the share key is useful to resolve published URLs. */
            shareKey?: string;
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /** If true, only the default site space will be returned. If false, only the non-default site spaces are returned. If undefined, all site spaces are returned. */
            default?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SiteSpace[];
        }, any>>;
        /**
         * No description
         *
         * @tags site-section-groups
         * @name ListSiteSectionGroups
         * @summary List all site section groups
         * @request GET:/orgs/{organizationId}/sites/{siteId}/section-groups
         * @secure
         */
        listSiteSectionGroups: (organizationId: string, siteId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SiteSectionGroup[];
        }, any>>;
        /**
         * No description
         *
         * @tags site-section-groups
         * @name AddSectionGroupToSite
         * @summary Add a section group to a site
         * @request POST:/orgs/{organizationId}/sites/{siteId}/section-groups
         * @secure
         */
        addSectionGroupToSite: (organizationId: string, siteId: string, data: {
            /** Title of the site section group */
            title: SiteSectionGroupTitle;
            icon?: Icon | null;
            /** IDs of the sections to be added to the section group */
            sections?: string[];
        }, params?: RequestParams) => Promise<HttpResponse<SiteSectionGroup, any>>;
        /**
         * No description
         *
         * @tags site-section-groups
         * @name UpdateSiteSectionGroupById
         * @summary Update a site section group
         * @request PATCH:/orgs/{organizationId}/sites/{siteId}/section-groups/{siteSectionGroupId}
         * @secure
         */
        updateSiteSectionGroupById: (organizationId: string, siteId: string, siteSectionGroupId: string, data: {
            /** Title of the site section group */
            title?: SiteSectionGroupTitle;
            icon?: Icon | null;
        }, params?: RequestParams) => Promise<HttpResponse<SiteSectionGroup, any>>;
        /**
         * No description
         *
         * @tags site-section-groups
         * @name DeleteSiteSectionGroupById
         * @summary Delete a site section group
         * @request DELETE:/orgs/{organizationId}/sites/{siteId}/section-groups/{siteSectionGroupId}
         * @secure
         */
        deleteSiteSectionGroupById: (organizationId: string, siteId: string, siteSectionGroupId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags site-section-groups
         * @name AddSectionToGroup
         * @summary Add a section to a section group
         * @request POST:/orgs/{organizationId}/sites/{siteId}/section-groups/{siteSectionGroupId}/sections
         * @secure
         */
        addSectionToGroup: (organizationId: string, siteId: string, siteSectionGroupId: string, data: {
            /** ID of the section to add to the section group */
            sectionId: string;
        }, params?: RequestParams) => Promise<HttpResponse<SiteSectionGroup, any>>;
        /**
         * No description
         *
         * @tags site-section-groups
         * @name RemoveSectionFromGroup
         * @summary Remove a section from a section group
         * @request DELETE:/orgs/{organizationId}/sites/{siteId}/section-groups/{siteSectionGroupId}/sections/{siteSectionId}
         * @secure
         */
        removeSectionFromGroup: (organizationId: string, siteId: string, siteSectionGroupId: string, siteSectionId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags site-sections
         * @name AddSectionToSite
         * @summary Add a section to a site
         * @request POST:/orgs/{organizationId}/sites/{siteId}/sections
         * @secure
         */
        addSectionToSite: (organizationId: string, siteId: string, data: {
            /** ID of the space to be added to the section as a site space variant */
            spaceId: string;
            title?: SiteSectionTitle | null;
            icon?: Icon | null;
        }, params?: RequestParams) => Promise<HttpResponse<SiteSection, any>>;
        /**
         * No description
         *
         * @tags site-sections
         * @name ListSiteSections
         * @summary List all site sections
         * @request GET:/orgs/{organizationId}/sites/{siteId}/sections
         * @secure
         */
        listSiteSections: (organizationId: string, siteId: string, query?: {
            /** For sites published via share-links, the share key is useful to resolve published URLs. */
            shareKey?: string;
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SiteSection[];
        }, any>>;
        /**
         * No description
         *
         * @tags site-sections
         * @name UpdateSiteSectionById
         * @summary Update a site section
         * @request PATCH:/orgs/{organizationId}/sites/{siteId}/sections/{siteSectionId}
         * @secure
         */
        updateSiteSectionById: (organizationId: string, siteId: string, siteSectionId: string, data: {
            /** Title of the site section */
            title?: SiteSectionTitle;
            /** Path to the section on the site */
            path?: SiteSectionPath;
            /** ID of the site-space to be used as the default in this section. */
            defaultSiteSpace?: string;
            /** Conditional expression used to evaluate whether the site section should be shown to the site's visitor (should evaluate to a boolean). If not set, the condition will remain unchanged. If set to null, the condition will be removed. */
            condition?: Condition | null;
            icon?: Icon | null;
            description?: SiteSectionDescription | null;
        }, params?: RequestParams) => Promise<HttpResponse<SiteSection, any>>;
        /**
         * No description
         *
         * @tags site-sections
         * @name DeleteSiteSectionById
         * @summary Delete a site section
         * @request DELETE:/orgs/{organizationId}/sites/{siteId}/sections/{siteSectionId}
         * @secure
         */
        deleteSiteSectionById: (organizationId: string, siteId: string, siteSectionId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags sites
         * @name SearchSiteContent
         * @summary Search in a site
         * @request POST:/orgs/{organizationId}/sites/{siteId}/search
         * @secure
         */
        searchSiteContent: (organizationId: string, siteId: string, data: {
            /** @maxLength 512 */
            query: string;
        } & ({
            /** Define the scope of the search. */
            scope: SiteSearchScope;
        } | {
            /**
             * Search only in the site spaces provided. Deprecated, use scope instead.
             * @deprecated
             */
            mode?: "specific";
            /** @minLength 1 */
            siteSpaceIds: string[];
        } | {
            /**
             * Search in the current site space and all section's defaults. Deprecated, use scope instead.
             * @deprecated
             */
            mode: "current";
            siteSpaceId: string;
        } | {
            /**
             * Search in all site-spaces. Deprecated, use scope instead.
             * @deprecated
             */
            mode: "all";
        }), query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SearchSpaceResult[];
        }, any>>;
        /**
         * @description The response is streamed.
         *
         * @tags site-ask
         * @name StreamAskInSite
         * @summary Ask a question in a site
         * @request POST:/orgs/{organizationId}/sites/{siteId}/ask
         * @secure
         */
        streamAskInSite: (organizationId: string, siteId: string, data: {
            /** @maxLength 512 */
            question: string;
            /** You may optionally provide additional information about the context of the question. This doesn't affect the scope of the search, but GitBook may use this information to provide a better answer. Generally speaking, you should provide as much context as possible. */
            context?: {
                siteSpaceId?: string;
            };
            scope: SiteSearchScope;
        }, query?: {
            /** Output format for the content. */
            format?: "document" | "markdown";
        }, params?: RequestParams) => EventIterator<SearchAIAnswerStream>;
        /**
         * @description The response is streamed.
         *
         * @tags site-ask
         * @name StreamRecommendedQuestionsInSite
         * @summary List recommended questions to ask in a site
         * @request GET:/orgs/{organizationId}/sites/{siteId}/ask/questions
         * @secure
         */
        streamRecommendedQuestionsInSite: (organizationId: string, siteId: string, params?: RequestParams) => EventIterator<SearchAIRecommendedQuestionStream>;
        /**
         * No description
         *
         * @tags site-spaces
         * @name UpdateSiteSpaceById
         * @summary Update a site space
         * @request PATCH:/orgs/{organizationId}/sites/{siteId}/site-spaces/{siteSpaceId}
         * @secure
         */
        updateSiteSpaceById: (organizationId: string, siteId: string, siteSpaceId: string, data: {
            /** Path to the space on the site */
            path?: SiteSpacePath;
            /** Conditional expression used to evaluate whether the site space should be shown to the site's visitor (should evaluate to a boolean). If not set, the condition will remain unchanged. If set to null, the condition will be removed. */
            condition?: Condition | null;
            /** The content that this site space points to. If not set, the space will remain unchanged. */
            spaceId?: string;
        }, params?: RequestParams) => Promise<HttpResponse<SiteSpace, any>>;
        /**
         * No description
         *
         * @tags site-spaces
         * @name DeleteSiteSpaceById
         * @summary Delete a site space
         * @request DELETE:/orgs/{organizationId}/sites/{siteId}/site-spaces/{siteSpaceId}
         * @secure
         */
        deleteSiteSpaceById: (organizationId: string, siteId: string, siteSpaceId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags site-customization
         * @name GetSiteSpaceCustomizationById
         * @summary Get a site space customization settings
         * @request GET:/orgs/{organizationId}/sites/{siteId}/site-spaces/{siteSpaceId}/customization
         * @secure
         */
        getSiteSpaceCustomizationById: (organizationId: string, siteId: string, siteSpaceId: string, query?: {
            /**
             * (Deprecated) Use the getRawCustomizationSettingsById internal endpoint.
             * @deprecated
             * @default false
             */
            unmasked?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<SiteCustomizationSettings, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags site-customization
         * @name OverrideSiteSpaceCustomizationById
         * @summary Override a site space customization settings
         * @request PATCH:/orgs/{organizationId}/sites/{siteId}/site-spaces/{siteSpaceId}/customization
         * @secure
         */
        overrideSiteSpaceCustomizationById: (organizationId: string, siteId: string, siteSpaceId: string, data: {
            /** Title to use for the published site variant. If not defined, the title will not be changed. If set to null, the title will be unset and will fallback to the content title. */
            title?: SiteTitle | null;
            styling?: {
                /** The site theme. Set to null to reset the override. */
                theme?: CustomizationTheme | null;
                /** The primary color used for links and UI text. Set to null to reset the override. */
                primaryColor?: CustomizationThemedColor | null;
                /** Used for informational messages and neutral alerts. Set to null to reset the override. */
                infoColor?: CustomizationThemedColor | null;
                /** Used for showing positive actions or achievements. Set to null to reset the override. */
                successColor?: CustomizationThemedColor | null;
                /** Used for showing important information or non-critical warnings. Set to null to reset the override. */
                warningColor?: CustomizationThemedColor | null;
                /** Used for destructive actions or raising attention to critical information. Set to null to reset the override. */
                dangerColor?: CustomizationThemedColor | null;
                /** The tint will color the siteâ€™s UI beyond links and buttons, such as header, sidebar and background. By default, the tint colour is the same as your Primary colour, but you can set a custom one too. */
                tint?: CustomizationTint | null;
                /** The style of the corners to use. Set to null to reset the override. */
                corners?: CustomizationCorners | null;
                /** The depth of elements on the site. Set to null to reset the override. */
                depth?: CustomizationDepth | null;
                /** The style for links to use. Set to null to reset the override. */
                links?: CustomizationLinksStyle | null;
                /** The font family to use for the content. Set to null to reset the override. */
                font?: CustomizationFont | null;
                /** The icons style to use for the content. Set to null to reset the override. */
                icons?: CustomizationIconsStyle | null;
                /** Various styles for the sidebar. Each can be Set to null to reset the override. */
                sidebar?: {
                    background?: CustomizationSidebarBackgroundStyle | null;
                    list?: CustomizationSidebarListStyle | null;
                };
                /** Styling for the search button at the top of the site. */
                search?: CustomizationSearchStyle | null;
                /** The style of background to use. Set to null to reset the override. */
                background?: CustomizationBackground | null;
            };
            internationalization?: {
                /** The locale to use for the non-custom elements of the UI. Set to null to reset the override. */
                locale: CustomizationLocale | null;
            };
            /** The favicon to use. Set to null to reset the override. */
            favicon?: CustomizationFavicon | null;
            announcement?: CustomizationAnnouncement;
            header?: {
                /** The theme preset to use. Set to null to reset the override. */
                preset?: CustomizationHeaderPreset | null;
                /** The header logo to use. Set to null to reset the override. */
                logo?: CustomizationThemedURL | null;
                /** The background color used in the header. Set to null to reset the override. */
                backgroundColor?: CustomizationThemedColor | null;
                /** The color used by the links in the header. Set to null to reset the override. */
                linkColor?: CustomizationThemedColor | null;
                /** The links that are displayed in the header. Set to null to reset the override. */
                links?: CustomizationHeaderItem[] | null;
            };
            footer?: {
                /** The logo displayed in the footer. Set to null to reset the override. */
                logo?: CustomizationThemedURL | null;
                /** The links groups that are displayed in the footer. Set to null to reset the override. */
                groups?: CustomizationFooterGroup[] | null;
                /**
                 * The copyright text that is displayed in the footer. Set to null to reset the override.
                 * @maxLength 300
                 */
                copyright?: string | null;
            };
            themes?: {
                /** The theme mode default value. Set to null to reset the override. */
                default?: CustomizationThemeMode | null;
                /** Should the reader be able to switch between dark and light mode. Set to null to reset the override. */
                toggeable?: boolean | null;
            };
            pdf?: {
                /** If true, PDF export is enabled for the published site. Set to null to reset the override. */
                enabled: boolean | null;
            };
            feedback?: {
                /** If true, feedback gathering is enabled. Set to null to reset the override. */
                enabled: boolean | null;
            };
            aiSearch?: {
                /** If true, AI search is enabled. Set to null to reset the override. */
                enabled: boolean | null;
            };
            git?: {
                /** Whether the published site should show a link to edit the content on the git provider set up in the Git Sync. Set to null to reset the override. */
                showEditLink: boolean | null;
            };
            externalLinks?: {
                /** How external links should open. Set to null to reset the override. */
                target: SiteExternalLinksTarget | null;
            };
            pagination?: {
                /** Whether the pagination navigation should be displayed on pages. Set to null to reset the override. */
                enabled: boolean | null;
            };
            trademark?: {
                /** Whether the GitBook trademark ("Powered by GitBook") should be visible. Set to null to reset the override. */
                enabled: boolean | null;
            };
            privacyPolicy?: {
                /** The custom link to the privacy policy. Set to null to reset the override. */
                url?: URL | null;
            };
            socialPreview?: {
                /** The URL for the social preview image. Set to null to reset the override. */
                url?: URL | null;
            };
        }, params?: RequestParams) => Promise<HttpResponse<SiteCustomizationSettings, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags site-customization
         * @name DeleteSiteSpaceCustomizationById
         * @summary Delete a site space customization settings
         * @request DELETE:/orgs/{organizationId}/sites/{siteId}/site-spaces/{siteSpaceId}/customization
         * @secure
         */
        deleteSiteSpaceCustomizationById: (organizationId: string, siteId: string, siteSpaceId: string, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags site-section-groups
         * @name MoveSiteSectionGroup
         * @summary Move a site section group to a new position. (Deprecated) use sortSiteStructure instead.
         * @request POST:/orgs/{organizationId}/sites/{siteId}/section-groups/{siteSectionGroupId}/move
         * @deprecated
         * @secure
         */
        moveSiteSectionGroup: (organizationId: string, siteId: string, siteSectionGroupId: string, data: {
            /** The position where to move the site section group. When not provided the site section group is moved at the end of the site. */
            position?: SiteSectionGroupMovePosition;
        }, params?: RequestParams) => Promise<HttpResponse<SiteSectionGroup, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags site-sections
         * @name MoveSiteSection
         * @summary Move a site section to a new position. (Deprecated) use sortSiteStructure instead.
         * @request POST:/orgs/{organizationId}/sites/{siteId}/sections/{siteSectionId}/move
         * @deprecated
         * @secure
         */
        moveSiteSection: (organizationId: string, siteId: string, siteSectionId: string, data: {
            /** The position where to move the site section. When not provided the site section is moved at the end of the site. */
            position?: SiteSectionMovePosition;
        }, params?: RequestParams) => Promise<HttpResponse<SiteSection, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags site-spaces
         * @name MoveSiteSpace
         * @summary Move a site space to a new position. (Deprecated) use sortSiteStructure instead.
         * @request POST:/orgs/{organizationId}/sites/{siteId}/site-spaces/{siteSpaceId}/move
         * @deprecated
         * @secure
         */
        moveSiteSpace: (organizationId: string, siteId: string, siteSpaceId: string, data: {
            /** The position where to move the site space. When not provided the site space is moved at the end of the site. */
            position?: SiteSpaceMovePosition;
        }, params?: RequestParams) => Promise<HttpResponse<SiteSpace, {
            error: {
                /** @format int32 */
                code: 400;
                message: string;
            };
        } | {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags site-users
         * @name ListPermissionsAggregateInSite
         * @summary List all sites users permissions
         * @request GET:/orgs/{organizationId}/sites/{siteId}/permissions/aggregate
         * @secure
         */
        listPermissionsAggregateInSite: (organizationId: string, siteId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: UserSitePermission[];
        }, any>>;
        /**
         * @description Experimental operation to generate an AI response in a site.
         *
         * @tags sites
         * @name StreamAiResponseInSite
         * @summary Generate an AI response in a site
         * @request POST:/orgs/{organizationId}/sites/{siteId}/ai/response
         * @secure
         */
        streamAiResponseInSite: (organizationId: string, siteId: string, data: {
            /** The ID of the previous response to continue from */
            previousResponseId?: string;
            /** Instructions for the AI */
            instructions?: string;
            input: AIMessageInput[];
            output: AIOutputFormat;
            model?: AIModel;
            /** Tools provided to the AI */
            tools?: AIToolCapabilities;
        }, params?: RequestParams) => EventIterator<AIStreamResponse>;
        /**
         * @description Experimental operation to get an existing AI response in a site.
         *
         * @tags sites
         * @name StreamExistingAiResponseInSite
         * @summary Get an existing AI response in a site
         * @request GET:/orgs/{organizationId}/sites/{siteId}/ai/response/{responseId}
         * @secure
         */
        streamExistingAiResponseInSite: (organizationId: string, siteId: string, responseId: string, params?: RequestParams) => EventIterator<AIStreamResponse>;
        /**
         * No description
         *
         * @tags site-insights
         * @name TrackEventsInSiteById
         * @summary Track site events
         * @request POST:/orgs/{organizationId}/sites/{siteId}/insights/events
         * @secure
         */
        trackEventsInSiteById: (organizationId: string, siteId: string, data: {
            events: SiteInsightsEvent[];
        }, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags site-insights
         * @name AggregateSiteEvents
         * @summary Query site events
         * @request POST:/orgs/{organizationId}/sites/{siteId}/insights/events/aggregate
         * @secure
         */
        aggregateSiteEvents: (organizationId: string, siteId: string, data: SiteInsightsQueryEventsAggregation, params?: RequestParams) => Promise<HttpResponse<SiteInsightsQueryEventsAggregationResult, any>>;
        /**
         * No description
         *
         * @tags site-insights
         * @name ListSiteVisitorSegments
         * @summary List a site visitor segments
         * @request GET:/orgs/{organizationId}/sites/{siteId}/insights/visitor-segments
         * @secure
         */
        listSiteVisitorSegments: (organizationId: string, siteId: string, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SiteInsightsVisitorSegment[];
        }, any>>;
        /**
         * No description
         *
         * @tags site-ads
         * @name UpdateSiteAdsById
         * @summary Update a site ads settings
         * @request POST:/orgs/{organizationId}/sites/{siteId}/ads
         * @secure
         */
        updateSiteAdsById: (organizationId: string, siteId: string, data?: {
            status?: "in-review" | "disabled";
            /** Topic of the content */
            topic?: SiteAdsTopic;
        }, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags site-redirects
         * @name CreateSiteRedirect
         * @summary Create a site redirect
         * @request POST:/orgs/{organizationId}/sites/{siteId}/redirects
         * @secure
         */
        createSiteRedirect: (organizationId: string, siteId: string, data: {
            /** The source path to redirect from. */
            source: SiteRedirectSourcePath;
            destination: SiteRedirectDestination;
        }, params?: RequestParams) => Promise<HttpResponse<SiteRedirect, any>>;
        /**
         * No description
         *
         * @tags site-redirects
         * @name ListSiteRedirects
         * @summary List all site redirects
         * @request GET:/orgs/{organizationId}/sites/{siteId}/redirects
         * @secure
         */
        listSiteRedirects: (organizationId: string, siteId: string, query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: SiteRedirect[];
        }, any>>;
        /**
         * No description
         *
         * @tags site-redirects
         * @name UpdateSiteRedirectById
         * @summary Update a site redirect
         * @request PATCH:/orgs/{organizationId}/sites/{siteId}/redirects/{siteRedirectId}
         * @secure
         */
        updateSiteRedirectById: (organizationId: string, siteId: string, siteRedirectId: string, data: {
            /** The source path to redirect from. */
            source?: SiteRedirectSourcePath;
            destination?: SiteRedirectDestination;
        }, params?: RequestParams) => Promise<HttpResponse<SiteRedirect, any>>;
        /**
         * No description
         *
         * @tags site-redirects
         * @name DeleteSiteRedirectById
         * @summary Delete a site redirect
         * @request DELETE:/orgs/{organizationId}/sites/{siteId}/redirects/{siteRedirectId}
         * @secure
         */
        deleteSiteRedirectById: (organizationId: string, siteId: string, siteRedirectId: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
        /**
         * No description
         *
         * @tags site-redirects
         * @name GetSiteRedirectBySource
         * @summary Get a site redirect by its source
         * @request GET:/orgs/{organizationId}/sites/{siteId}/redirect
         * @secure
         */
        getSiteRedirectBySource: (organizationId: string, siteId: string, query: {
            /** For sites published via share-links, the share key is useful to resolve published URLs. */
            shareKey?: string;
            /** The source path of the redirect. */
            source: SiteRedirectSourcePath;
        }, params?: RequestParams) => Promise<HttpResponse<{
            redirect: SiteRedirect;
            /** URL of the destination of the redirect. */
            target: string;
        }, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
    };
    subdomains: {
        /**
         * No description
         *
         * @tags subdomains
         * @name GetSubdomain
         * @summary Get a subdomain
         * @request GET:/subdomains/{subdomain}
         * @secure
         */
        getSubdomain: (subdomain: string, params?: RequestParams) => Promise<HttpResponse<Subdomain, any>>;
    };
    customHostnames: {
        /**
         * No description
         *
         * @tags custom-hostnames
         * @name GetCustomHostname
         * @summary Get a custom hostname
         * @request GET:/custom-hostnames/{hostname}
         * @secure
         */
        getCustomHostname: (hostname: string, params?: RequestParams) => Promise<HttpResponse<CustomHostname, any>>;
        /**
         * @description Revalidate DNS records and status.
         *
         * @tags custom-hostnames
         * @name DnsRevalidateCustomHostname
         * @summary Revalidate a custom hostname DNS
         * @request PATCH:/custom-hostnames/{hostname}
         * @secure
         */
        dnsRevalidateCustomHostname: (hostname: string, params?: RequestParams) => Promise<HttpResponse<void, {
            error: {
                /** @format int32 */
                code: 409;
                message: string;
            };
        }>>;
        /**
         * @description The custom hostname will continue to point to the content or organization unless it is used for another one.
         *
         * @tags custom-hostnames
         * @name RemoveCustomHostname
         * @summary Remove a custom hostname
         * @request DELETE:/custom-hostnames/{hostname}
         * @secure
         */
        removeCustomHostname: (hostname: string, params?: RequestParams) => Promise<HttpResponse<void, any>>;
    };
    emailDomains: {
        /**
         * No description
         *
         * @tags organizations
         * @name GetOrganizationsForEmailDomain
         * @summary Get all organizations by email domain
         * @request GET:/email-domains/{emailDomain}/orgs
         * @secure
         */
        getOrganizationsForEmailDomain: (emailDomain: string, params?: RequestParams) => Promise<HttpResponse<{
            organizations?: Organization[];
        }, any>>;
    };
    ads: {
        /**
         * No description
         *
         * @tags site-ads
         * @name AdsListSites
         * @summary List all the sites with ads configured
         * @request GET:/ads/sites
         * @secure
         */
        adsListSites: (query?: {
            /** Identifier of the page results to fetch. */
            page?: string;
            /**
             * The number of results per page
             * @min 0
             * @max 1000
             */
            limit?: number;
            /**
             * Filter sites by their ads review status
             * @default "in-review"
             */
            status?: "in-review" | "live" | "rejected";
        }, params?: RequestParams) => Promise<HttpResponse<List & {
            items: ({
                id: string;
                url: string;
                email: string;
                /** Topic of the content */
                topic: SiteAdsTopic;
            } & ({
                status: "in-review";
            } | {
                status: "live";
                /** The ad network zone ID */
                zoneId: string;
            } | {
                status: "rejected";
                /** Reason for the rejection */
                reason?: string;
            }))[];
        }, any>>;
        /**
         * No description
         *
         * @tags site-ads
         * @name AdsUpdateSite
         * @summary Update the Ads configuration for a site
         * @request PATCH:/ads/sites/{siteId}
         * @secure
         */
        adsUpdateSite: (siteId: string, data: {
            status: "live";
            /** ID of the zone */
            zoneId: string;
            /** ID to fetch reporting data */
            reportingId: string;
        } | {
            status: "rejected";
            /**
             * Reason for the rejection
             * @maxLength 512
             */
            reason?: string;
        } | {
            status: "pending";
        }, params?: RequestParams) => Promise<HttpResponse<void, any>>;
    };
    urls: {
        /**
         * No description
         *
         * @tags urls
         * @name GetContentByUrl
         * @summary Resolve a URL to a content (space, collection, page)
         * @request GET:/urls/content
         * @secure
         */
        getContentByUrl: (query: {
            /** URL to resolve */
            url: string;
        }, params?: RequestParams) => Promise<HttpResponse<{
            collection: Collection;
        } | {
            space: Space;
            changeRequest?: ChangeRequest;
            page?: RevisionPageDocument | RevisionPageGroup;
        }, any>>;
        /**
         * No description
         *
         * @tags urls
         * @name GetEmbedByUrl
         * @summary Resolve a URL to an embed
         * @request GET:/urls/embed
         * @secure
         */
        getEmbedByUrl: (query: {
            /** URL to resolve */
            url: string;
        }, params?: RequestParams) => Promise<HttpResponse<Embed, any>>;
        /**
         * No description
         *
         * @tags urls
         * @name GetPublishedContentByUrl
         * @summary Resolve a URL of a published content.
         * @request GET:/urls/published
         * @deprecated
         * @secure
         */
        getPublishedContentByUrl: (query: {
            /** URL to resolve */
            url: URL;
            /** JWT token generated for a authenticated access session */
            visitorAuthToken?: string;
            /**
             * When true redirects the user to the authentication/fallback URL if the access token is invalid
             * @default false
             */
            redirectOnError?: boolean;
        }, params?: RequestParams) => Promise<HttpResponse<PublishedSiteContentLookup, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
        /**
         * No description
         *
         * @tags urls
         * @name ResolvePublishedContentByUrl
         * @summary Resolve a URL of a published content.
         * @request POST:/urls/published
         * @secure
         */
        resolvePublishedContentByUrl: (data: {
            /** URL to resolve */
            url: URL;
            /**
             * When true redirects the user to the authentication/fallback URL if the access token is invalid
             * @default false
             */
            redirectOnError?: boolean;
            /** An object that describes the payload of site visitor info. It can include a jwt token with signed claims and/or a record of its unsigned claims. */
            visitor?: SiteVisitorPayload;
        }, params?: RequestParams) => Promise<HttpResponse<PublishedSiteContentLookup, {
            error: {
                /** @format int32 */
                code: 404;
                message: string;
            };
        }>>;
    };
}
export {};
